<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lucene.Net</name>
    </assembly>
    <members>
        <member name="T:Lucene.Net.Util.Parameter">
            <summary> A serializable Enum class.</summary>
        </member>
        <member name="M:Lucene.Net.Util.Parameter.ReadResolve">
            <summary> Resolves the deserialized instance to the local reference for accurate
            equals() and == comparisons.
            
            </summary>
            <returns> a reference to Parameter as resolved in the local VM
            </returns>
            <throws>  objectStreamException </throws>
        </member>
        <member name="T:Lucene.Net.Store.SimpleFSLockFactory">
            <summary> <p>Implements {@link LockFactory} using {@link
            File#createNewFile()}.  This is the default LockFactory
            for {@link FSDirectory}.</p>
            
            <p><b>NOTE:</b> the <a target="_top" href="http://java.sun.com/j2se/1.4.2/docs/api/java/io/File.html#createNewFile()">javadocs
            for <code>File.createNewFile</code></a> contain a vague
            yet spooky warning about not using the API for file
            locking.  This warning was added due to <a target="_top" href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4676183">this
            bug</a>, and in fact the only known problem with using
            this API for locking is that the Lucene write lock may
            not be released when the JVM exits abnormally.</p>
            <p>When this happens, a {@link LockObtainFailedException}
            is hit when trying to create a writer, in which case you
            need to explicitly clear the lock file first.  You can
            either manually remove the file, or use the {@link
            Lucene.Net.Index.IndexReader#Unlock(Directory)}
            API.  But, first be certain that no writer is in fact
            writing to the index otherwise you can easily corrupt
            your index.</p>
            
            <p>If you suspect that this or any other LockFactory is
            not working properly in your environment, you can easily
            test it by using {@link VerifyingLockFactory}, {@link
            LockVerifyServer} and {@link LockStressTest}.</p>
            
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockFactory">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Store.LockFactory">
            <summary> <p>Base class for Locking implementation.  {@link Directory} uses
            instances of this class to implement locking.</p>
            
            <p>Note that there are some useful tools to verify that
            your LockFactory is working correctly: {@link
            VerifyingLockFactory}, {@link LockStressTest}, {@link
            LockVerifyServer}.</p>
            
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockVerifyServer">
            </seealso>
            <seealso cref="T:Lucene.Net.Store.LockStressTest">
            </seealso>
            <seealso cref="T:Lucene.Net.Store.VerifyingLockFactory">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.LockFactory.SetLockPrefix(System.String)">
            <summary> Set the prefix in use for all locks created in this
            LockFactory.  This is normally called once, when a
            Directory gets this LockFactory instance.  However, you
            can also call this (after this instance is assigned to
            a Directory) to override the prefix in use.  This
            is helpful if you're running Lucene on machines that
            have different mount points for the same shared
            directory.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.LockFactory.GetLockPrefix">
            <summary> Get the prefix in use for all locks created in this LockFactory.</summary>
        </member>
        <member name="M:Lucene.Net.Store.LockFactory.MakeLock(System.String)">
            <summary> Return a new Lock instance identified by lockName.</summary>
            <param name="lockName">name of the lock to be created.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.LockFactory.ClearLock(System.String)">
            <summary> Attempt to clear (forcefully unlock and remove) the
            specified lock.  Only call this at a time when you are
            certain this lock is no longer in use.
            </summary>
            <param name="lockName">name of the lock to be cleared.
            </param>
        </member>
        <member name="F:Lucene.Net.Store.SimpleFSLockFactory.lockDir">
            <summary> Directory specified by <code>Lucene.Net.lockDir</code>
            system property.  If that is not set, then <code>java.io.tmpdir</code>
            system property is used.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor">
            <summary> Create a SimpleFSLockFactory instance, with null (unset)
            lock directory.  This is package-private and is only
            used by FSDirectory when creating this LockFactory via
            the System property
            Lucene.Net.Store.FSDirectoryLockFactoryClass.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor(System.IO.FileInfo)">
            <summary> Instantiate using the provided directory (as a File instance).</summary>
            <param name="lockDir">where lock files should be created.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor(System.String)">
            <summary> Instantiate using the provided directory name (String).</summary>
            <param name="lockDirName">where lock files should be created.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.SetLockDir(System.IO.FileInfo)">
            <summary> Set the lock directory.  This is package-private and is
            only used externally by FSDirectory when creating this
            LockFactory via the System property
            Lucene.Net.Store.FSDirectoryLockFactoryClass.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.Lock" -->
        <member name="F:Lucene.Net.Store.Lock.LOCK_OBTAIN_WAIT_FOREVER">
            <summary>Pass this value to {@link #Obtain(long)} to try
            forever to obtain the lock. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.Lock.LOCK_POLL_INTERVAL">
            <summary>How long {@link #Obtain(long)} waits, in milliseconds,
            in between attempts to acquire the lock. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Obtain">
            <summary>Attempts to obtain exclusive access and immediately return
            upon success or failure.
            </summary>
            <returns> true iff exclusive access is obtained
            </returns>
        </member>
        <member name="F:Lucene.Net.Store.Lock.failureReason">
            <summary> If a lock obtain called, this failureReason may be set
            with the "root cause" Exception as to why the lock was
            not obtained.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Obtain(System.Int64)">
            <summary>Attempts to obtain an exclusive lock within amount of
            time given. Polls once per {@link #LOCK_POLL_INTERVAL}
            (currently 1000) milliseconds until lockWaitTimeout is
            passed.
            </summary>
            <param name="lockWaitTimeout">length of time to wait in
            milliseconds or {@link
            #LOCK_OBTAIN_WAIT_FOREVER} to retry forever
            </param>
            <returns> true if lock was obtained
            </returns>
            <throws>  LockObtainFailedException if lock wait times out </throws>
            <throws>  IllegalArgumentException if lockWaitTimeout is </throws>
            <summary>         out of bounds
            </summary>
            <throws>  IOException if obtain() throws IOException </throws>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Release">
            <summary>Releases exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.IsLocked">
            <summary>Returns true if the resource is currently locked.  Note that one must
            still call {@link #Obtain()} before using the resource. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.Lock.With">
            <summary>Utility class for executing code with exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.#ctor(Lucene.Net.Store.Lock,System.Int64)">
            <summary>Constructs an executor that will grab the named lock. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.DoBody">
            <summary>Code to execute with exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With.Run">
            <summary>Calls {@link #doBody} while <i>lock</i> is obtained.  Blocks if lock
            cannot be obtained immediately.  Retries to obtain lock once per second
            until it is obtained, or until it has tried ten times. Lock is released when
            {@link #doBody} exits.
            </summary>
            <throws>  LockObtainFailedException if lock could not </throws>
            <summary> be obtained
            </summary>
            <throws>  IOException if {@link Lock#obtain} throws IOException </throws>
        </member>
        <member name="T:Lucene.Net.Search.ScoreDoc">
            <summary>Expert: Returned by low-level search implementations.</summary>
            <seealso cref="T:Lucene.Net.Search.TopDocs">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.ScoreDoc.score">
            <summary>Expert: The score of this document for the query. </summary>
        </member>
        <member name="F:Lucene.Net.Search.ScoreDoc.doc">
            <summary>Expert: A hit document's number.</summary>
            <seealso cref="!:Searcher#Doc(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDoc.#ctor(System.Int32,System.Single)">
            <summary>Expert: Constructs a ScoreDoc. </summary>
        </member>
        <member name="T:Lucene.Net.Search.PhrasePositions">
            <summary> Position of a term in a document that takes into account the term offset within the phrase. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePositions.NextPosition">
            <summary> Go to next location of this term current document, and set 
            <code>position</code> as <code>location - offset</code>, so that a 
            matching exact phrase is easily identified when all PhrasePositions 
            have exactly the same <code>position</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiTermQuery" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Query" -->
        <member name="M:Lucene.Net.Search.Query.SetBoost(System.Single)">
            <summary>Sets the boost for this query clause to <code>b</code>.  Documents
            matching this clause will (in addition to the normal weightings) have
            their score multiplied by <code>b</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.GetBoost">
            <summary>Gets the boost for this clause.  Documents matching
            this clause will (in addition to the normal weightings) have their score
            multiplied by <code>b</code>.   The boost is 1.0 by default.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.ToString(System.String)" -->
        <member name="M:Lucene.Net.Search.Query.ToString">
            <summary>Prints a query to a string. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.CreateWeight(Lucene.Net.Search.Searcher)" -->
        <member name="M:Lucene.Net.Search.Query.Weight(Lucene.Net.Search.Searcher)">
            <summary>Expert: Constructs and initializes a Weight for a top-level query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>Expert: called to re-write queries into primitive queries. For example,
            a PrefixQuery will be rewritten into a BooleanQuery that consists
            of TermQuerys.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.Combine(Lucene.Net.Search.Query[])">
            <summary>Expert: called when re-writing queries under MultiSearcher.
            
            Create a single query suitable for use by all subsearchers (in 1-1
            correspondence with queries). This is an optimization of the OR of
            all queries. We handle the common optimization cases of equal
            queries and overlapping clauses of boolean OR queries (as generated
            by MultiTermQuery.rewrite() and RangeQuery.rewrite()).
            Be careful overriding this method as queries[0] determines which
            method will be called and is not necessarily of the same type as
            the other queries.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.ExtractTerms(System.Collections.Hashtable)">
            <summary> Expert: adds all terms occuring in this query to the terms set. Only
            works if this query is in its {@link #rewrite rewritten} form.
            
            </summary>
            <throws>  UnsupportedOperationException if this query is not yet rewritten </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.MergeBooleanQueries(Lucene.Net.Search.Query[])" -->
        <member name="M:Lucene.Net.Search.Query.GetSimilarity(Lucene.Net.Search.Searcher)">
            <summary>Expert: Returns the Similarity implementation to be used for this query.
            Subclasses may override this method to specify their own Similarity
            implementation, perhaps one that delegates through that of the Searcher.
            By default the Searcher's Similarity implementation is returned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.Clone">
            <summary>Returns a clone of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Constructs a query for terms matching <code>term</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.GetTerm">
            <summary>Returns the pattern term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.GetEnum(Lucene.Net.Index.IndexReader)">
            <summary>Construct the enumeration to be used, expanding the pattern term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiSearcher" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Searcher" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Searchable" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,Lucene.Net.Search.HitCollector)" -->
        <member name="M:Lucene.Net.Search.Searchable.Close">
            <summary>Frees resources associated with this Searcher.
            Be careful not to call this method while you are still using objects
            like {@link Hits}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.DocFreq(Lucene.Net.Index.Term)">
            <summary>Expert: Returns the number of documents containing <code>term</code>.
            Called by search code to compute term weights.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.DocFreq(Lucene.Net.Index.Term)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.DocFreqs(Lucene.Net.Index.Term[])">
            <summary>Expert: For each term in the terms array, calculates the number of
            documents containing <code>term</code>. Returns an array with these
            document frequencies. Used to minimize number of remote calls.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.MaxDoc">
            <summary>Expert: Returns one greater than the largest possible document number.
            Called by search code to compute term weights.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.MaxDoc">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,System.Int32)" -->
        <member name="M:Lucene.Net.Search.Searchable.Doc(System.Int32)">
            <summary>Expert: Returns the stored fields of document <code>i</code>.
            Called by {@link HitCollector} implementations.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.Doc(System.Int32,Lucene.Net.Documents.FieldSelector)">
            <summary> Get the {@link Lucene.Net.Documents.Document} at the <code>n</code><sup>th</sup> position. The {@link Lucene.Net.Documents.FieldSelector}
            may be used to determine what {@link Lucene.Net.Documents.Field}s to load and how they should be loaded.
            
            <b>NOTE:</b> If the underlying Reader (more specifically, the underlying <code>FieldsReader</code>) is closed before the lazy {@link Lucene.Net.Documents.Field} is
            loaded an exception may be thrown.  If you want the value of a lazy {@link Lucene.Net.Documents.Field} to be available after closing you must
            explicitly load it or fetch the Document again with a new loader.
            
            
            </summary>
            <param name="n">Get the document at the <code>n</code><sup>th</sup> position
            </param>
            <param name="fieldSelector">The {@link Lucene.Net.Documents.FieldSelector} to use to determine what Fields should be loaded on the Document.  May be null, in which case all Fields will be loaded.
            </param>
            <returns> The stored fields of the {@link Lucene.Net.Documents.Document} at the nth position
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
            <summary> 
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32,Lucene.Net.Documents.FieldSelector)">
            </seealso>
            <seealso cref="T:Lucene.Net.Documents.Fieldable">
            </seealso>
            <seealso cref="T:Lucene.Net.Documents.FieldSelector">
            </seealso>
            <seealso cref="T:Lucene.Net.Documents.SetBasedFieldSelector">
            </seealso>
            <seealso cref="T:Lucene.Net.Documents.LoadFirstFieldSelector">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Searchable.Rewrite(Lucene.Net.Search.Query)">
            <summary>Expert: called to re-write queries into primitive queries.</summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Explain(Lucene.Net.Search.Weight,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)" -->
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query)">
            <summary>Returns the documents matching <code>query</code>. </summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
            
        </member>
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter)">
            <summary>Returns the documents matching <code>query</code> and
            <code>filter</code>.
            </summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Sort)">
            <summary>Returns documents matching <code>query</code> sorted by
            <code>sort</code>.
            </summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.Sort)">
            <summary>Returns documents matching <code>query</code> and <code>filter</code>,
            sorted by <code>sort</code>.
            </summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.HitCollector)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.HitCollector)" -->
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)">
            <summary>Finds the top <code>n</code>
            hits for <code>query</code>, applying <code>filter</code> if non-null.
            </summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,System.Int32)">
            <summary>Finds the top <code>n</code>
            hits for <code>query</code>, applying <code>filter</code> if non-null.
            </summary>
            <throws>  BooleanQuery.TooManyClauses </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.Explain(Lucene.Net.Search.Query,System.Int32)" -->
        <member name="F:Lucene.Net.Search.Searcher.similarity">
            <summary>The Similarity implementation used by this searcher. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Searcher.SetSimilarity(Lucene.Net.Search.Similarity)">
            <summary>Expert: Set the Similarity implementation used by this Searcher.
            
            </summary>
            <seealso cref="!:Similarity#SetDefault(Similarity)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Searcher.GetSimilarity" -->
        <member name="M:Lucene.Net.Search.Searcher.CreateWeight(Lucene.Net.Search.Query)">
            <summary> creates a weight for <code>query</code></summary>
            <returns> new weight
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.#ctor(Lucene.Net.Search.Searchable[])">
            <summary>Creates a searcher which searches <i>searchables</i>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.GetSearchables">
            <summary>Return the array of {@link Searchable}s this searches. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.SubSearcher(System.Int32)">
            <summary>Returns index of the searcher for document <code>n</code> in the array
            used to construct this searcher. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.SubDoc(System.Int32)">
            <summary>Returns the document number of document <code>n</code> within its
            sub-index. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiSearcher.CreateWeight(Lucene.Net.Search.Query)">
            <summary> Create weight in multiple index scenario.
            
            Distributed query processing is done in the following steps:
            1. rewrite query
            2. extract necessary terms
            3. collect dfs for these terms from the Searchables
            4. create query weight using aggregate dfs.
            5. distribute that weight to Searchables
            6. merge results
            
            Steps 1-4 are done here, 5+6 in the search() methods
            
            </summary>
            <returns> rewritten queries
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.HitCollector" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.HitCollector.Collect(System.Int32,System.Single)" -->
        <member name="T:Lucene.Net.Search.MultiSearcher.CachedDfSource">
            <summary> Document Frequency cache acting as a Dummy-Searcher.
            This class is no full-fledged Searcher, but only supports
            the methods necessary to initialize Weights.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery">
            <summary>
            A query that applies a filter to the results of another query.
            <para>
            Note: the bits are retrieved from the filter each time this
            query is used in a search - use a CachingWrapperFilter to avoid
            regenerating the bits every time.
            </para>
            </summary>
            <since>1.4</since>
            <version>$Id:$</version>
            <seealso cref="T:Lucene.Net.Search.CachingWrapperFilter"/>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Filter)">
            <summary> Constructs a new query which applies a filter to the results of the original query.
            Filter.GetDocIdSet() will be called every time this query is used in a search.
            </summary>
            <param name="query"> Query to be filtered, cannot be <code>null</code>.
            </param>
            <param name="filter">Filter to apply to query results, cannot be <code>null</code>.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.CreateWeight(Lucene.Net.Search.Searcher)">
            <summary> Returns a Weight that applies the filter to the enclosed query's Weight.
            This is accomplished by overriding the Scorer returned by the Weight.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>Rewrites the wrapped query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.GetHashCode">
            <summary>Returns a hash code value for this object. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Weight" -->
        <member name="M:Lucene.Net.Search.Weight.GetQuery">
            <summary>The query that this concerns. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.GetValue">
            <summary>The weight for this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.SumOfSquaredWeights">
            <summary>The sum of squared weights of contained query clauses. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Normalize(System.Single)">
            <summary>Assigns the query normalization factor to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Scorer(Lucene.Net.Index.IndexReader)">
            <summary>Constructs a scorer for this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Explain(Lucene.Net.Index.IndexReader,System.Int32)">
            <summary>An explanation of the score computation for the named document. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Scorer">
            <summary> Expert: Common scoring functionality for different types of queries.
            
            <p>
            A <code>Scorer</code> either iterates over documents matching a
            query in increasing order of doc Id, or provides an explanation of
            the score for a query for a given document.
            </p>
            <p>
            Document scores are computed using a given <code>Similarity</code>
            implementation.
            </p>
            </summary>
            <seealso cref="!:BooleanQuery.setAllowDocsOutOfOrder">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSetIterator.Doc">
            <summary>
            Returns the current document number.  This is invalid until Next() is called for the first time.
            </summary>
            <returns>the current doc number</returns> 
        </member>
        <member name="M:Lucene.Net.Search.DocIdSetIterator.Next">
            <summary>
            Moves to the next docId in the set.  Returns true, iff there is such a docId.
            </summary>
            <returns>true if there is a next docId</returns>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSetIterator.SkipTo(System.Int32)">
            <summary>
            Skips entries to the first beyond the current whose document number is
            greater than or equal to <i>target</i>.  Returns true iff there is such
            an entry.
            <p>
            Behaves as if written:
            <pre>
              boolean skipTo(int target) {
                do {
                  if (!next())
                    return false;
                } while (target > doc());
                return true;
              }
            </pre>
            Some implementations are considerably more efficient than that.
            </p>
            </summary>
            <returns>true if there is a docId greater than or equal to target</returns>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.#ctor(Lucene.Net.Search.Similarity)">
            <summary>Constructs a Scorer.</summary>
            <param name="similarity">The <code>Similarity</code> implementation used by this scorer.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.GetSimilarity">
            <summary>Returns the Similarity implementation used by this scorer. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Scorer.Score(Lucene.Net.Search.HitCollector)" -->
        <member name="M:Lucene.Net.Search.Scorer.Score(Lucene.Net.Search.HitCollector,System.Int32)">
            <summary>Expert: Collects matching documents in a range.  Hook for optimization.
            Note that {@link #Next()} must be called once before this method is called
            for the first time.
            </summary>
            <param name="hc">The collector to which all matching documents are passed through
            {@link HitCollector#Collect(int, float)}.
            </param>
            <param name="max">Do not score documents past this.
            </param>
            <returns> true if more matching documents may remain.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.Score">
            <summary>Returns the score of the current document matching the query.
            Initially invalid, until {@link #Next()} or {@link #SkipTo(int)}
            is called the first time.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Scorer.Explain(System.Int32)" -->
        <member name="T:Lucene.Net.Search.Filter">
            <summary>
            Abstract base class providing a mechanism to limit index search results
            to a subset of an index.
            <para>
            Note: In Lucene 3.0, Bits(IndexReader) will be removed and GetDocIdSet(IndexReader)
            will be made abstract.  All implementin classes must therefore implement
            GetDocIdSet(IndexReader) in order to work with Lucene 3.0.
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Filter.Bits(Lucene.Net.Index.IndexReader)">
            <summary>
            Returns a BitSet with true for documents which should be permitted in
            search results, and false for those that should not. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Filter.GetDocIdSet(Lucene.Net.Index.IndexReader)">
            <summary>
            Return a DocIdSet that provides the documents which are permitted
            or prohibited in search results.
            </summary>
            <param name="reader"></param>
            <returns></returns>
            <see cref="T:Lucene.Net.Util.DocIdBitSet"/>
        </member>
        <member name="T:Lucene.Net.QueryParsers.MultiFieldQueryParser">
            <summary> A QueryParser which constructs queries to search multiple fields.
            
            
            </summary>
            <version>  $Revision: 564236 $
            </version>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.QueryParsers.QueryParser" -->
        <member name="T:Lucene.Net.QueryParsers.QueryParserConstants">
            <summary>
            Token literal values and constants.
            Generated by org.javacc.parser.OtherFilesGen#start()
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.EOF">
            <summary>End of File.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants._NUM_CHAR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants._ESCAPED_CHAR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants._TERM_START_CHAR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants._TERM_CHAR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants._WHITESPACE">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants._QUOTED_CHAR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.AND">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.OR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.NOT">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.PLUS">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.MINUS">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.LPAREN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.RPAREN">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.COLON">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.STAR">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.CARAT">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.QUOTED">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.TERM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.FUZZY_SLOP">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.PREFIXTERM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.WILDTERM">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.RANGEIN_START">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.RANGEEX_START">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.NUMBER">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.RANGEIN_TO">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.RANGEIN_END">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.RANGEIN_QUOTED">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.RANGEIN_GOOP">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.RANGEEX_TO">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.RANGEEX_END">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.RANGEEX_QUOTED">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.RANGEEX_GOOP">
            <summary>RegularExpression Id.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.Boost">
            <summary>Lexical state.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.RangeEx">
            <summary>Lexical state.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.RangeIn">
            <summary>Lexical state.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.DEFAULT">
            <summary>Lexical state.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserConstants.tokenImage">
            <summary>
            Literal token values.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParser.AND_OPERATOR">
            <summary>Alternative form of QueryParser.Operator.AND </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParser.OR_OPERATOR">
            <summary>Alternative form of QueryParser.Operator.OR </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParser.operator_Renamed">
            <summary>The actual operator that parser uses to combine query terms </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParser.rangeCollator">
            <summary>
            The Collator to use when determining range inclusion, for use
            when constructin RangeQuerys and ConstantScoreRangeQuerys
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.#ctor(System.String,Lucene.Net.Analysis.Analyzer)">
            <summary>Constructs a query parser.</summary>
            <param name="f"> the default field for query terms.
            </param>
            <param name="a">  used to find terms in the query text.
            </param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.Parse(System.String)">
            <summary>Parses a query string, returning a {@link Lucene.Net.Search.Query}.</summary>
            <param name="query"> the query string to be parsed.
            </param>
            <throws>  ParseException if the parsing fails </throws>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetAnalyzer">
            <returns> Returns the analyzer.
            </returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetField">
            <returns> Returns the field.
            </returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFuzzyMinSim">
            <summary> Get the minimal similarity for fuzzy queries.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetFuzzyMinSim(System.Single)">
            <summary> Set the minimum similarity for fuzzy queries.
            Default is 0.5f.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFuzzyPrefixLength">
            <summary> Get the prefix length for fuzzy queries. </summary>
            <returns> Returns the fuzzyPrefixLength.
            </returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetFuzzyPrefixLength(System.Int32)">
            <summary> Set the prefix length for fuzzy queries. Default is 0.</summary>
            <param name="fuzzyPrefixLength">The fuzzyPrefixLength to set.
            </param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetPhraseSlop(System.Int32)">
            <summary> Sets the default slop for phrases.  If zero, then exact phrase matches
            are required.  Default value is zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetPhraseSlop">
            <summary> Gets the default slop for phrases.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.SetAllowLeadingWildcard(System.Boolean)" -->
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetAllowLeadingWildcard">
            <seealso cref="!:SetAllowLeadingWildcard(boolean)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.SetEnablePositionIncrements(System.Boolean)" -->
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetEnablePositionIncrements">
            <seealso cref="!:SetEnablePositionIncrements(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetDefaultOperator(Lucene.Net.QueryParsers.QueryParser.Operator)">
            <summary> Sets the boolean operator of the QueryParser.
            In default mode (<code>OR_OPERATOR</code>) terms without any modifiers
            are considered optional: for example <code>capital of Hungary</code> is equal to
            <code>capital OR of OR Hungary</code>.<br/>
            In <code>AND_OPERATOR</code> mode terms are considered to be in conjuction: the
            above mentioned query is parsed as <code>capital AND of AND Hungary</code>
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetDefaultOperator">
            <summary> Gets implicit operator setting, which will be either AND_OPERATOR
            or OR_OPERATOR.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetLowercaseExpandedTerms(System.Boolean)">
            <summary> Whether terms of wildcard, prefix, fuzzy and range queries are to be automatically
            lower-cased or not.  Default is <code>true</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetLowercaseExpandedTerms">
            <seealso cref="!:#SetLowercaseExpandedTerms(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetUseOldRangeQuery(System.Boolean)">
            <summary> By default QueryParser uses new ConstantScoreRangeQuery in preference to RangeQuery
            for range queries. This implementation is generally preferable because it 
            a) Runs faster b) Does not have the scarcity of range terms unduly influence score 
            c) avoids any "TooManyBooleanClauses" exception.
            However, if your application really needs to use the old-fashioned RangeQuery and the above
            points are not required then set this option to <code>true</code>
            Default is <code>false</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetUseOldRangeQuery">
            <seealso cref="!:SetUseOldRangeQuery(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetLocale(System.Globalization.CultureInfo)">
            <summary> Set locale used by date range parsing.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetLocale">
            <summary> Returns current locale, allowing access by subclasses.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetDateResolution(Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Sets the default date resolution used by RangeQueries for fields for which no
            specific date resolutions has been set. Field specific resolutions can be set
            with {@link #SetDateResolution(String, DateTools.Resolution)}.
            
            </summary>
            <param name="dateResolution">the default date resolution to set
            </param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetDateResolution(System.String,Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Sets the date resolution used by RangeQueries for a specific field.
            
            </summary>
            <param name="fieldName">field for which the date resolution is to be set 
            </param>
            <param name="dateResolution">date resolution to set
            </param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetDateResolution(System.String)">
            <summary> Returns the date resolution that is used by RangeQueries for the given field. 
            Returns null, if no default or field specific date resolution has been set
            for the given field.
            
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.SetRangeCollator(System.Globalization.CompareInfo)">
            <summary>
            Sets the collator used to determine index term inclusion in ranges
            specified either for ConstantScoreRangeQuery or RangeQuery (if SetUseOldRangeQuery(bool)
            is called with a parameter of true.
            <para>
            WARNING: Setting the rangeCollator to a non-null
            collator using this method will cause every single index Term in the
            Field referenced by lowerTerm and/or upperTerm to be examined.
            Depending on the number of index Terms in this Field, the operation
            could be very slow.
            </para>
            </summary>
            <param name="rc">the collator to use when constructing RangeQuery and ConstantScoreRangeQuery</param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetRangeCollator">
            <summary>
            Returns the collator used to determine index term inclusion in ranges
            specified either for ConstantScoreRangeQuery or RangeQuery (if
            SetUseOldRangeQuery(bool) is called with the parameter true).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFieldQuery(System.String,System.String)">
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFieldQuery(System.String,System.String,System.Int32)">
            <summary> Base implementation delegates to {@link #GetFieldQuery(String,String)}.
            This method may be overridden, for example, to return
            a SpanNearQuery instead of a PhraseQuery.
            
            </summary>
            <exception cref="T:Lucene.Net.QueryParsers.ParseException">throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetRangeQuery(System.String,System.String,System.String,System.Boolean)">
            <exception cref="T:Lucene.Net.QueryParsers.ParseException">throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.newBooleanQuery(System.Boolean)">
            <summary>
            Builds a new BooleanQuery instance.
            </summary>
            <param name="disableCoord"></param>
            <returns>new BooleanQuery instance</returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.newBooleanClause(Lucene.Net.Search.Query,Lucene.Net.Search.BooleanClause.Occur)">
            <summary>
            Builds a new BooleanClause instance.
            </summary>
            <param name="q"></param>
            <param name="occur"></param>
            <returns>new BooleanClause instance</returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.newTermQuery(Lucene.Net.Index.Term)">
            <summary>
            Builds a new TermQuery instance.
            </summary>
            <param name="term"></param>
            <returns>new TermQuery instance</returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.newPhraseQuery">
            <summary>
            Builds a new PhraseQuery instance.
            </summary>
            <returns>new PhraseQuery instance</returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.newMultiPhraseQuery">
            <summary>
            Builds a new MultiPhraseQuery instance.
            </summary>
            <returns>new MultiPhraseQuery instance</returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.newPrefixQuery(Lucene.Net.Index.Term)">
            <summary>
            Builds a new PrefixQuery instance.
            </summary>
            <param name="prefix"></param>
            <returns>new PrefixQuery instance</returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.newFuzzyQuery(Lucene.Net.Index.Term,System.Single,System.Int32)">
            <summary>
            Builds a new FuzzyQuery instance.
            </summary>
            <param name="term"></param>
            <param name="minimumSimilarity"></param>
            <param name="prefixLength"></param>
            <returns>new FuzzyQuery instance</returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.newRangeQuery(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Builds a new RangeQuery instance.
            </summary>
            <param name="field"></param>
            <param name="part1"></param>
            <param name="part2"></param>
            <param name="inclusive"></param>
            <returns>new RangeQuery instance</returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.newMatchAllDocsQuery">
            <summary>
            Builds a new MatchAllDocsQuery instance.
            </summary>
            <returns>new MatchAllDocsQuery instance</returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.newWildcardQuery(Lucene.Net.Index.Term)">
            <summary>
            Builds a new WildcardQuery instance.
            </summary>
            <param name="term"></param>
            <returns>new WildcardQuery instance</returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetBooleanQuery(System.Collections.ArrayList)">
            <summary> Factory method for generating query, given a set of clauses.
            By default creates a boolean query composed of clauses passed in.
            
            Can be overridden by extending classes, to modify query being
            returned.
            
            </summary>
            <param name="clauses">Vector that contains {@link BooleanClause} instances
            to join.
            
            </param>
            <returns> Resulting {@link Query} object.
            </returns>
            <exception cref="T:Lucene.Net.QueryParsers.ParseException">throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetBooleanQuery(System.Collections.ArrayList,System.Boolean)">
            <summary> Factory method for generating query, given a set of clauses.
            By default creates a boolean query composed of clauses passed in.
            
            Can be overridden by extending classes, to modify query being
            returned.
            
            </summary>
            <param name="clauses">Vector that contains {@link BooleanClause} instances
            to join.
            </param>
            <param name="disableCoord">true if coord scoring should be disabled.
            
            </param>
            <returns> Resulting {@link Query} object.
            </returns>
            <exception cref="!:"> ParseException throw in overridden method to disallow
            </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.GetWildcardQuery(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.GetPrefixQuery(System.String,System.String)" -->
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetFuzzyQuery(System.String,System.String,System.Single)">
            <summary> Factory method for generating a query (similar to
            {@link #getWildcardQuery}). Called when parser parses
            an input term token that has the fuzzy suffix (~) appended.
            
            </summary>
            <param name="field">Name of the field query will use.
            </param>
            <param name="termStr">Term token to use for building term for the query
            
            </param>
            <returns> Resulting {@link Query} built for the term
            </returns>
            <exception cref="T:Lucene.Net.QueryParsers.ParseException">throw in overridden method to disallow
            </exception>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.DiscardEscapeChar(System.String)">
            <summary> Returns a String where the escape char has been
            removed, or kept only once if there was a double escape.
            
            Supports escaped unicode characters, e. g. translates
            <code>\\u0041</code> to <code>A</code>.
            
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.HexToInt(System.Char)">
            <summary>Returns the numeric value of the hexadecimal character </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.Escape(System.String)">
            <summary> Returns a String where those characters that QueryParser
            expects to be escaped are escaped by a preceding <code>\</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.QueryParser.Main(System.String[])" -->
        <member name="F:Lucene.Net.QueryParsers.QueryParser.token_source">
            <summary>
            Generated token manager
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParser.token">
            <summary>
            Current token
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParser.jj_nt">
            <summary>
            Next token.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.#ctor(Lucene.Net.QueryParsers.CharStream)">
            <summary>
            Constructor with used supplied CharStream.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.ReInit(Lucene.Net.QueryParsers.CharStream)">
            <summary>
            Reinitialise.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.#ctor(Lucene.Net.QueryParsers.QueryParserTokenManager)">
            <summary>
            Constructor with generated TokenManager.
            </summary>
            <param name="tm"></param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.ReInit(Lucene.Net.QueryParsers.QueryParserTokenManager)">
            <summary>
            Reinitialise.
            </summary>
            <param name="tm"></param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetNextToken">
            <summary>
            Get the next Token.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GetToken(System.Int32)">
            <summary>
            Get the specific Token.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.GenerateParseException">
            <summary>
            Generate ParseException.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.Enable_tracing">
            <summary>
            Enable tracing.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParser.Disable_tracing">
            <summary>
            Disable tracing.
            </summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.QueryParser.Operator">
            <summary>The default operator for parsing queries. 
            Use {@link QueryParser#setDefaultOperator} to change it.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.MultiFieldQueryParser.#ctor(System.String[],Lucene.Net.Analysis.Analyzer,System.Collections.IDictionary)">
            <summary> Creates a MultiFieldQueryParser. 
            Allows passing of a map with term to Boost, and the boost to apply to each term.
            
            <p>It will, when parse(String query)
            is called, construct a query like this (assuming the query consists of
            two terms and you specify the two fields <code>title</code> and <code>body</code>):</p>
            
            <code>
            (title:term1 body:term1) (title:term2 body:term2)
            </code>
            
            <p>When setDefaultOperator(AND_OPERATOR) is set, the result will be:</p>
            
            <code>
            +(title:term1 body:term1) +(title:term2 body:term2)
            </code>
            
            <p>When you pass a boost (title=>5 body=>10) you can get </p>
            
            <code>
            +(title:term1^5.0 body:term1^10.0) +(title:term2^5.0 body:term2^10.0)
            </code>
            
            <p>In other words, all the query's terms must appear, but it doesn't matter in
            what fields they appear.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.MultiFieldQueryParser.#ctor(System.String[],Lucene.Net.Analysis.Analyzer)">
            <summary> Creates a MultiFieldQueryParser.
            
            <p>It will, when parse(String query)
            is called, construct a query like this (assuming the query consists of
            two terms and you specify the two fields <code>title</code> and <code>body</code>):</p>
            
            <code>
            (title:term1 body:term1) (title:term2 body:term2)
            </code>
            
            <p>When setDefaultOperator(AND_OPERATOR) is set, the result will be:</p>
            
            <code>
            +(title:term1 body:term1) +(title:term2 body:term2)
            </code>
            
            <p>In other words, all the query's terms must appear, but it doesn't matter in
            what fields they appear.</p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.MultiFieldQueryParser.Parse(System.String[],System.String[],Lucene.Net.Analysis.Analyzer)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.MultiFieldQueryParser.Parse(System.String,System.String[],Lucene.Net.Search.BooleanClause.Occur[],Lucene.Net.Analysis.Analyzer)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.MultiFieldQueryParser.Parse(System.String[],System.String[],Lucene.Net.Search.BooleanClause.Occur[],Lucene.Net.Analysis.Analyzer)" -->
        <member name="T:Lucene.Net.Index.TermVectorMapper">
            <summary> The TermVectorMapper can be used to map Term Vectors into your own
            structure instead of the parallel array structure used by
            {@link Lucene.Net.Index.IndexReader#GetTermFreqVector(int,String)}.
            <p/>
            It is up to the implementation to make sure it is thread-safe.
            
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorMapper.#ctor(System.Boolean,System.Boolean)">
            <summary> </summary>
            <param name="ignoringPositions">true if this mapper should tell Lucene to ignore positions even if they are stored
            </param>
            <param name="ignoringOffsets">similar to ignoringPositions
            </param>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorMapper.SetExpectations(System.String,System.Int32,System.Boolean,System.Boolean)">
            <summary> Tell the mapper what to expect in regards to field, number of terms, offset and position storage.
            This method will be called once before retrieving the vector for a field.
            
            This method will be called before {@link #Map(String,int,TermVectorOffsetInfo[],int[])}.
            </summary>
            <param name="field">The field the vector is for
            </param>
            <param name="numTerms">The number of terms that need to be mapped
            </param>
            <param name="storeOffsets">true if the mapper should expect offset information
            </param>
            <param name="storePositions">true if the mapper should expect positions info
            </param>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorMapper.Map(System.String,System.Int32,Lucene.Net.Index.TermVectorOffsetInfo[],System.Int32[])">
            <summary> Map the Term Vector information into your own structure</summary>
            <param name="term">The term to add to the vector
            </param>
            <param name="frequency">The frequency of the term in the document
            </param>
            <param name="offsets">null if the offset is not specified, otherwise the offset into the field of the term
            </param>
            <param name="positions">null if the position is not specified, otherwise the position in the field of the term
            </param>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorMapper.IsIgnoringPositions">
            <summary> Indicate to Lucene that even if there are positions stored, this mapper is not interested in them and they
            can be skipped over.  Derived classes should set this to true if they want to ignore positions.  The default
            is false, meaning positions will be loaded if they are stored.
            </summary>
            <returns> false
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorMapper.IsIgnoringOffsets">
            <summary> </summary>
            <seealso cref="!:IsIgnoringPositions() Same principal as &lt;@link #IsIgnoringPositions()&gt;, but applied to offsets.  false by default.">
            </seealso>
            <returns> false
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorMapper.SetDocumentNumber(System.Int32)">
            <summary> Passes down the index of the document whose term vector is currently being mapped,
            once for each top level call to a term vector reader.
            <p/>
            Default implementation IGNORES the document number.  Override if your implementation needs the document number.
            <p/> 
            NOTE: Document numbers are internal to Lucene and subject to change depending on indexing operations.
            
            </summary>
            <param name="documentNumber">index of document currently being mapped
            </param>
        </member>
        <member name="T:Lucene.Net.Index.TermFreqVector">
            <summary>Provides access to stored term vector of 
            a document field.  The vector consists of the name of the field, an array of the terms tha occur in the field of the
            {@link Lucene.Net.Documents.Document} and a parallel array of frequencies.  Thus, getTermFrequencies()[5] corresponds with the
            frequency of getTerms()[5], assuming there are at least 5 terms in the Document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.GetField">
            <summary> The {@link Lucene.Net.Documents.Fieldable} name. </summary>
            <returns> The name of the field this vector is associated with.
            
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.Size">
            <returns> The number of terms in the term vector.
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.GetTerms">
            <returns> An Array of term texts in ascending order.
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.GetTermFrequencies">
            <summary>Array of term frequencies. Locations of the array correspond one to one
            to the terms in the array obtained from <code>getTerms</code>
            method. Each location in the array contains the number of times this
            term occurs in the document or the document field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.IndexOf(System.String)">
            <summary>Return an index in the term numbers array returned from
            <code>getTerms</code> at which the term with the specified
            <code>term</code> appears. If this term does not appear in the array,
            return -1.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermFreqVector.IndexesOf(System.String[],System.Int32,System.Int32)">
            <summary>Just like <code>indexOf(int)</code> but searches for a number of terms
            at the same time. Returns an array that has the same size as the number
            of terms searched for, each slot containing the result of searching for
            that term number.
            
            </summary>
            <param name="terms">array containing terms to look for
            </param>
            <param name="start">index in the array where the list of terms starts
            </param>
            <param name="len">the number of terms in the list
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermVector.GetField">
            <summary> </summary>
            <returns> The number of the field this vector is associated with
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.TermPositionVector">
            <summary>Extends <code>TermFreqVector</code> to provide additional information about
            positions in which each of the terms is found. A TermPositionVector not necessarily
            contains both positions and offsets, but at least one of these arrays exists.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermPositionVector.GetTermPositions(System.Int32)">
            <summary>Returns an array of positions in which the term is found.
            Terms are identified by the index at which its number appears in the
            term String array obtained from the <code>indexOf</code> method.
            May return null if positions have not been stored.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermPositionVector.GetOffsets(System.Int32)">
            <summary> Returns an array of TermVectorOffsetInfo in which the term is found.
            May return null if offsets have not been stored.
            
            </summary>
            <seealso cref="T:Lucene.Net.Analysis.Token">
            
            </seealso>
            <param name="index">The position in the array to get the offsets from
            </param>
            <returns> An array of TermVectorOffsetInfo objects or the empty list
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermPositionVector.GetOffsets(System.Int32)">
            <summary> Returns an array of TermVectorOffsetInfo in which the term is found.
            
            </summary>
            <param name="index">The position in the array to get the offsets from
            </param>
            <returns> An array of TermVectorOffsetInfo objects or the empty list
            </returns>
            <seealso cref="T:Lucene.Net.Analysis.Token">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermPositionVector.GetTermPositions(System.Int32)">
            <summary> Returns an array of positions in which the term is found.
            Terms are identified by the index at which its number appears in the
            term String array obtained from the <code>indexOf</code> method.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.PriorityQueue">
            <summary>A PriorityQueue maintains a partial ordering of its elements such that the
            least element can always be found in constant time.  Put()'s and pop()'s
            require log(size) time. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.LessThan(System.Object,System.Object)">
            <summary>Determines the ordering of objects in this priority queue.  Subclasses
            must define this one method. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Initialize(System.Int32)">
            <summary>Subclass constructors must call this. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Put(System.Object)">
            <summary> Adds an object to a PriorityQueue in log(size) time.
            If one tries to add more objects than maxSize from initialize
            a RuntimeException (ArrayIndexOutOfBound) is thrown.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Insert(System.Object)">
            <summary> Adds element to the PriorityQueue in log(size) time if either
            the PriorityQueue is not full, or not lessThan(element, top()).
            </summary>
            <param name="element">
            </param>
            <returns> true if element is added, false otherwise.
            </returns>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.InsertWithOverflow(System.Object)">
            <summary> insertWithOverflow() is the same as insert() except its
            return value: it returns the object (if any) that was
            dropped off the heap because it was full. This can be
            the given parameter (in case it is smaller than the
            full heap's minimum, and couldn't be added), or another
            object that was previously the smallest value in the
            heap and now has been replaced by a larger one, or null
            if the queue wasn't yet full with maxSize elements.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Top">
            <summary>Returns the least element of the PriorityQueue in constant time. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Pop">
            <summary>Removes and returns the least element of the PriorityQueue in log(size)
            time. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.AdjustTop">
            <summary>Should be called when the object at top changes values.  Still log(n)
            worst case, but it's at least twice as fast to <pre>
            { pq.top().change(); pq.adjustTop(); }
            </pre> instead of <pre>
            { o = pq.pop(); o.change(); pq.push(o); }
            </pre>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Size">
            <summary>Returns the number of elements currently stored in the PriorityQueue. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue.Clear">
            <summary>Removes all entries from the PriorityQueue. </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldInfos">
            <summary>Access to the Fieldable Info file that describes document fields and whether or
            not they are indexed. Each segment has a separate Fieldable Info file. objects
            of this class are thread-safe for multiple readers, but only one thread can
            be adding documents at a time, with no other reader or writer threads
            accessing this object.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary> Construct a FieldInfos object using the directory and the name of the file
            IndexInput
            </summary>
            <param name="d">The directory to open the IndexInput from
            </param>
            <param name="name">The name of the file to open the IndexInput from in the Directory
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Clone">
            <summary> Returns a deep clone of this FieldInfos instance.</summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(Lucene.Net.Documents.Document)">
            <summary>Adds field info for a Document. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.HasProx">
            <summary>
            Returns true if any fields *do not* omit tf.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.AddIndexed(System.Collections.ICollection,System.Boolean,System.Boolean,System.Boolean)">
            <summary> Add fields that are indexed. Whether they have termvectors has to be specified.
            
            </summary>
            <param name="names">The names of the fields
            </param>
            <param name="storeTermVectors">Whether the fields store term vectors or not
            </param>
            <param name="storePositionWithTermVector">treu if positions should be stored.
            </param>
            <param name="storeOffsetWithTermVector">true if offsets should be stored
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.Collections.Generic.ICollection{System.String},System.Boolean)">
            <summary> Assumes the fields are not storing term vectors.
            
            </summary>
            <param name="names">The names of the fields
            </param>
            <param name="isIndexed">Whether the fields are indexed or not
            
            </param>
            <seealso cref="!:Add(string, boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean)">
            <summary> Calls 5 parameter add with false for all TermVector parameters.
            
            </summary>
            <param name="name">The name of the Fieldable
            </param>
            <param name="isIndexed">true if the field is indexed
            </param>
            <seealso cref="!:Add(string, boolean, boolean, boolean, boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean,System.Boolean)">
            <summary> Calls 5 parameter add with false for term vector positions and offsets.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="isIndexed"> true if the field is indexed
            </param>
            <param name="storeTermVector">true if the term vector should be stored
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>If the field is not yet known, adds it. If it is known, checks to make
            sure that the isIndexed flag is the same as was given previously for this
            field. If not - marks it as being indexed.  Same goes for the TermVector
            parameters.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="isIndexed">true if the field is indexed
            </param>
            <param name="storeTermVector">true if the term vector should be stored
            </param>
            <param name="storePositionWithTermVector">true if the term vector with positions should be stored
            </param>
            <param name="storeOffsetWithTermVector">true if the term vector with offsets should be stored
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>If the field is not yet known, adds it. If it is known, checks to make
            sure that the isIndexed flag is the same as was given previously for this
            field. If not - marks it as being indexed.  Same goes for the TermVector
            parameters.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="isIndexed">true if the field is indexed
            </param>
            <param name="storeTermVector">true if the term vector should be stored
            </param>
            <param name="storePositionWithTermVector">true if the term vector with positions should be stored
            </param>
            <param name="storeOffsetWithTermVector">true if the term vector with offsets should be stored
            </param>
            <param name="omitNorms">true if the norms for the indexed field should be omitted
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Add(System.String,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>If the field is not yet known, adds it. If it is known, checks to make
            sure that the isIndexed flag is the same as was given previously for this
            field. If not - marks it as being indexed.  Same goes for the TermVector
            parameters.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="isIndexed">true if the field is indexed
            </param>
            <param name="storeTermVector">true if the term vector should be stored
            </param>
            <param name="storePositionWithTermVector">true if the term vector with positions should be stored
            </param>
            <param name="storeOffsetWithTermVector">true if the term vector with offsets should be stored
            </param>
            <param name="omitNorms">true if the norms for the indexed field should be omitted
            </param>
            <param name="storePayloads">true if payloads should be stored for this field
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldName(System.Int32)">
            <summary> Return the fieldName identified by its number.
            
            </summary>
            <param name="">fieldNumber
            </param>
            <returns> the fieldName or an empty string when the field
            with the given number doesn't exist.
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldInfo(System.Int32)">
            <summary> Return the fieldinfo object referenced by the fieldNumber.</summary>
            <param name="fieldNumber">
            </param>
            <returns> the FieldInfo object or null when the given fieldNumber
            doesn't exist.
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriter">
                 * This class accepts multiple added documents and directly
                 * writes a single segment file.  It does this more
                 * efficiently than creating a single segment per document
                 * (with DocumentWriter) and doing standard merges on those
                 * segments.
                 *
                 * Each added document is passed to the {@link DocConsumer},
                 * which in turn processes the document and interacts with
                 * other consumers in the indexing chain.  Certain
                 * consumers, like {@link StoredFieldsWriter} and {@link
                 * TermVectorsTermsWriter}, digest a document and
                 * immediately write bytes to the "doc store" files (ie,
                 * they do not consume RAM per document, except while they
                 * are processing the document).
                 *
                 * Other consumers, eg {@link FreqProxTermsWriter} and
                 * {@link NormsWriter}, buffer bytes in RAM and flush only
                 * when a new segment is produced.
            
                 * Once we have used our allowed RAM buffer, or the number
                 * of added docs is large enough (in the case we are
                 * flushing by doc count instead of RAM usage), we create a
                 * real segment and flush it to the Directory.
                 *
                 * Threads:
                 *
                 * Multiple threads are allowed into addDocument at once.
                 * There is an initial synchronized call to getThreadState
                 * which allocates a ThreadState for this thread.  The same
                 * thread will get the same ThreadState over time (thread
                 * affinity) so that if there are consistent patterns (for
                 * example each thread is indexing a different content
                 * source) then we make better use of RAM.  Then
                 * processDocument is called on that ThreadState without
                 * synchronization (most of the "heavy lifting" is in this
                 * call).  Finally the synchronized "finishDocument" is
                 * called to flush changes to the directory.
                 *
                 * When flush is called by IndexWriter, or, we flush
                 * internally when autoCommit=false, we forcefully idle all
                 * threads and flush only once they are all idle.  This
                 * means you can call flush with a given thread even while
                 * other threads are actively adding/deleting documents.
                 *
                 *
                 * Exceptions:
                 *
                 * Because this class directly updates in-memory posting
                 * lists, and flushes stored fields and term vectors
                 * directly to files in the directory, there are certain
                 * limited times when an exception can corrupt this state.
                 * For example, a disk full while flushing stored fields
                 * leaves this file in a corrupt state.  Or, an OOM
                 * exception while appending to the in-memory posting lists
                 * can corrupt that posting list.  We call such exceptions
                 * "aborting exceptions".  In these cases we must call
                 * abort() to discard all docs added since the last flush.
                 *
                 * All other exceptions ("non-aborting exceptions") can
                 * still partially update the index structures.  These
                 * updates are consistent, but, they represent only a part
                 * of the document seen up until the exception was hit.
                 * When this happens, we immediately mark the document as
                 * deleted so that the document is always atomically ("all
                 * or none") added to the index.
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.HasProx">
            Returns true if any of the fields in the current
            buffered docs have omitTf==false 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.SetInfoStream(System.IO.TextWriter)">
            If non-null, various details of indexing are printed
            here. 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.SetRAMBufferSizeMB(System.Double)">
            Set how much RAM we can use before flushing. 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.SetMaxBufferedDocs(System.Int32)">
            Set max buffered docs, which means we will flush by
            doc count instead of by RAM usage. 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.GetSegment">
            Get current segment name we are writing. 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.GetNumDocsInRAM">
            Returns how many docs are currently buffered in RAM. 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.GetDocStoreSegment">
            Returns the current doc store segment we are writing
            to.  This will be the same as segment when autoCommit
            * is true. 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.GetDocStoreOffset">
            Returns the doc offset into the shared doc store for
            the current buffered docs. 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.CloseDocStore">
            Closes the current open doc stores an returns the doc
            store segment name.  This returns null if there are *
            no buffered documents. 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.Abort">
            Called if we hit an exception at a bad time (when
            updating the index files) and must discard all
            currently buffered docs.  This resets our state,
            discarding any docs added since last flush. 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.DoAfterFlush">
            Reset after a flush 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.Flush(System.Boolean)">
            Flush all pending docs to a new segment 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.CreateCompoundFile(System.String)">
            Build compound file for the segment we just flushed 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.SetFlushPending">
            Set flushPending if it is not already set and returns
            whether it was set. This is used by IndexWriter to
            trigger a single flush even when multiple threads are
            trying to do so. 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.GetThreadState(Lucene.Net.Documents.Document,Lucene.Net.Index.Term)">
            Returns a free (idle) ThreadState that may be used for
            indexing this one document.  This call also pauses if a
            flush is pending.  If delTerm is non-null then we
            buffer this deleted term after the thread state has
            been acquired. 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.AddDocument(Lucene.Net.Documents.Document,Lucene.Net.Analysis.Analyzer)">
            Returns true if the caller (IndexWriter) should now
            flush. 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.RemapDeletes(Lucene.Net.Index.SegmentInfos,System.Int32[][],System.Int32[],Lucene.Net.Index.MergePolicy.OneMerge,System.Int32)">
            Called whenever a merge has completed and the merged segments had deletions 
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.FinishDocument(Lucene.Net.Index.DocumentsWriterThreadState,Lucene.Net.Index.DocumentsWriter.DocWriter)">
            Does the synchronized work to finish/flush the
            inverted document. 
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriter.DocWriter">
            Consumer returns this on each doc.  This holds any
            state that must be flushed synchronized "in docID
            order".  We gather these and flush them in order. 
        </member>
        <member name="T:Lucene.Net.Index.ByteBlockPool">
            <summary>
             Class that Posting and PostingVector use to write byte
             streams into shared fixed-size byte[] arrays.  The idea
             is to allocate slices of increasing lengths For
             example, the first slice is 5 bytes, the next slice is
             14, etc.  We start by writing our bytes into the first
             5 bytes.  When we hit the end of the slice, we allocate
             the next slice and then write the address of the new
             slice into the last 4 bytes of the previous slice (the
             "forwarding address").
            
             Each slice is filled with 0's initially, and we mark
             the end with a non-zero byte.  This way the methods
             that are writing into the slice don't need to record
             its length and instead allocate a new slice once they
             hit a non-zero byte.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocFieldProcessorPerField">
            <summary>
            Holds all per thread, per field state.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.FieldSelectorResult">
            <summary>  Provides information about what should be done with this Field 
            
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldSelectorResult.LOAD">
            <summary> Load this {@link Field} every time the {@link Document} is loaded, reading in the data as it is encounterd.
            {@link Document#GetField(String)} and {@link Document#GetFieldable(String)} should not return null.
            <p/>
            {@link Document#Add(Fieldable)} should be called by the Reader.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldSelectorResult.LAZY_LOAD">
            <summary> Lazily load this {@link Field}.  This means the {@link Field} is valid, but it may not actually contain its data until
            invoked.  {@link Document#GetField(String)} SHOULD NOT BE USED.  {@link Document#GetFieldable(String)} is safe to use and should
            return a valid instance of a {@link Fieldable}.
            <p/>
            {@link Document#Add(Fieldable)} should be called by the Reader.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldSelectorResult.NO_LOAD">
            <summary> Do not load the {@link Field}.  {@link Document#GetField(String)} and {@link Document#GetFieldable(String)} should return null.
            {@link Document#Add(Fieldable)} is not called.
            <p/>
            {@link Document#Add(Fieldable)} should not be called by the Reader.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldSelectorResult.LOAD_AND_BREAK">
            <summary> Load this field as in the {@link #LOAD} case, but immediately return from {@link Field} loading for the {@link Document}.  Thus, the
            Document may not have its complete set of Fields.  {@link Document#GetField(String)} and {@link Document#GetFieldable(String)} should
            both be valid for this {@link Field}
            <p/>
            {@link Document#Add(Fieldable)} should be called by the Reader.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldSelectorResult.LOAD_FOR_MERGE">
            <summary> Behaves much like {@link #LOAD} but does not uncompress any compressed data.  This is used for internal purposes.
            {@link Document#GetField(String)} and {@link Document#GetFieldable(String)} should not return null.
            <p/>
            {@link Document#Add(Fieldable)} should be called by the Reader.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldSelectorResult.SIZE">
            <summary>Expert:  Load the size of this {@link Field} rather than its value.
            Size is measured as number of bytes required to store the field == bytes for a binary or any compressed value, and 2*chars for a String value.
            The size is stored as a binary value, represented as an int in a byte[], with the higher order byte first in [0]
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.FieldSelectorResult.SIZE_AND_BREAK">
            <summary>Expert: Like {@link #SIZE} but immediately break from the field loading loop, i.e., stop loading further fields, after the size is loaded </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.StopAnalyzer">
            <summary>Filters LetterTokenizer with LowerCaseFilter and StopFilter. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Analyzer" -->
        <member name="M:Lucene.Net.Analysis.Analyzer.TokenStream(System.String,System.IO.TextReader)">
            <summary>Creates a TokenStream which tokenizes all the text in the provided
            Reader.  Must be able to handle null field name for backward compatibility. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.ReusableTokenStream(System.String,System.IO.TextReader)">
            <summary>Creates a TokenStream that is allowed to be re-used
            from the previous time that the same thread called
            this method.  Callers that do not need to use more
            than one TokenStream at the same time from this
            analyzer should use this method for better
            performance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GetPreviousTokenStream">
            <summary>Used by Analyzers that implement reusableTokenStream
            to retrieve previously saved TokenStreams for re-use
            by the same thread. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.SetPreviousTokenStream(System.Object)">
            <summary>Used by Analyzers that implement reusableTokenStream
            to save a TokenStream for later re-use by the same
            thread. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GetPositionIncrementGap(System.String)">
            <summary> Invoked before indexing a Fieldable instance if
            terms have already been added to that field.  This allows custom
            analyzers to place an automatic position increment gap between
            Fieldable instances using the same field name.  The default value
            position increment gap is 0.  With a 0 position increment gap and
            the typical default token position increment of 1, all terms in a field,
            including across Fieldable instances, are in successive positions, allowing
            exact PhraseQuery matches, for instance, across Fieldable instance boundaries.
            
            </summary>
            <param name="fieldName">Fieldable name being indexed.
            </param>
            <returns> position increment gap, added to the next token emitted from {@link #TokenStream(String,Reader)}
            </returns>
        </member>
        <member name="F:Lucene.Net.Analysis.StopAnalyzer.ENGLISH_STOP_WORDS">
            <summary>An array containing some common English words that are not usually useful
            for searching. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.#ctor">
            <summary>Builds an analyzer which removes words in ENGLISH_STOP_WORDS. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.#ctor(System.Collections.Hashtable)">
            <summary>Builds an analyzer with the stop words from the given set.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.#ctor(System.String[])">
            <summary>Builds an analyzer which removes words in the provided array. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.#ctor(System.IO.FileInfo)">
            <summary>Builds an analyzer with the stop words from the given file.</summary>
            <seealso cref="!:WordlistLoader.GetWordSet(File)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.#ctor(System.IO.TextReader)">
            <summary>Builds an analyzer with the stop words from the given reader.</summary>
            <seealso cref="!:WordlistLoader.GetWordSet(Reader)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.StopAnalyzer.TokenStream(System.String,System.IO.TextReader)">
            <summary>Filters LowerCaseTokenizer with StopFilter. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.StopAnalyzer.SavedStreams">
            <summary>Filters LowerCaseTokenizer with StopFilter. </summary>
        </member>
        <member name="T:Lucene.Net.Util.DocIdBitSet">
            <summary>Simple DocIdSet and DocIdSetIterator backed by a BitArray</summary>
        </member>
        <member name="T:Lucene.Net.Search.DocIdSet">
            <summary>
            A DocIdSet contains a set of doc ids.  Implementing classes
            must provide a DocIdSetIterator to access the set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.DocIdBitSet.GetBitSet">
            <summary>Returns the underlying BitArray.</summary>
        </member>
        <member name="T:Lucene.Net.Store.IndexInput">
            <summary>Abstract base class for input from a file in a {@link Directory}.  A
            random-access input stream.  Used for all Lucene index input operations.
            </summary>
            <seealso cref="T:Lucene.Net.Store.Directory">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadByte">
            <summary>Reads and returns a single byte.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.WriteByte(System.Byte)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a specified number of bytes into an array at the specified offset.</summary>
            <param name="b">the array to read bytes into
            </param>
            <param name="offset">the offset in the array to start storing bytes
            </param>
            <param name="len">the number of bytes to read
            </param>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.WriteBytes(System.Byte[],System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadBytes(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>Reads a specified number of bytes into an array at the
            specified offset with control over whether the read
            should be buffered (callers who have their own buffer
            should pass in "false" for useBuffer).  Currently only
            {@link BufferedIndexInput} respects this parameter.
            </summary>
            <param name="b">the array to read bytes into
            </param>
            <param name="offset">the offset in the array to start storing bytes
            </param>
            <param name="len">the number of bytes to read
            </param>
            <param name="useBuffer">set to false if the caller will handle
            buffering.
            </param>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.WriteBytes(System.Byte[],System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadInt">
            <summary>Reads four bytes and returns an int.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.WriteInt(System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadVInt">
            <summary>Reads an int stored in variable-length format.  Reads between one and
            five bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            </summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.WriteVInt(System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadLong">
            <summary>Reads eight bytes and returns a long.</summary>
            <seealso cref="!:IndexOutput#WriteLong(long)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadVLong">
            <summary>Reads a long stored in variable-length format.  Reads between one and
            nine bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.SetModifiedUTF8StringsMode">
            <summary>
            Set to read strings in the deprecated modified UTF-8 format
            (length in Java chars and Java's modified UTF-8 encoding).
            Used for pre-2.4.0 indexes.  See JIRA LUCENE-510 for details.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadString">
            <summary>Reads a string.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.WriteString(System.String)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ReadChars(System.Char[],System.Int32,System.Int32)">
            <summary>Reads Lucene's old "modified UTF-8" encoded characters into an array.</summary>
            <param name="buffer">the array to read characters into
            </param>
            <param name="start">the offset in the array to start storing characters
            </param>
            <param name="length">the number of characters to read
            </param>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.WriteChars(System.String,System.Int32,System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.SkipChars(System.Int32)">
            <summary> Expert
            
            Similar to {@link #ReadChars(char[], int, int)} but does not do any conversion operations on the bytes it is reading in.  It still
            has to invoke {@link #ReadByte()} just as {@link #ReadChars(char[], int, int)} does, but it does not need a buffer to store anything
            and it does not have to do any of the bitwise operations, since we don't actually care what is in the byte except to determine
            how many more bytes to read
            </summary>
            <param name="length">The number of chars to read
            </param>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Close">
            <summary>Closes the stream to futher operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.GetFilePointer">
            <summary>Returns the current position in this file, where the next read will
            occur.
            </summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.Seek(System.Int64)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Seek(System.Int64)">
            <summary>Sets current position in this file, where the next read will occur.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.GetFilePointer">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Length">
            <summary>The number of bytes in the file. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.IndexInput.Clone" -->
        <member name="T:Lucene.Net.Search.RemoteSearchable">
            <summary> A remote searchable implementation.
            
            </summary>
            <version>  $Id: RemoteSearchable.java 472959 2006-11-09 16:21:50Z yonik $
            </version>
        </member>
        <member name="M:Lucene.Net.Search.RemoteSearchable.#ctor(Lucene.Net.Search.Searchable)">
            <summary>Constructs and exports a remote searcher. </summary>
        </member>
        <member name="M:Lucene.Net.Search.RemoteSearchable.Main(System.String[])">
            <summary>Exports a searcher for the index in args[0] named
            "//localhost/Searchable". 
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.MatchAllDocsQuery">
            <summary>
            A query that matches all documents.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionMaxQuery">
            <summary> A query that generates the union of documents produced by its subqueries, and that scores each document with the maximum
            score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries.
            This is useful when searching for a word in multiple fields with different boost factors (so that the fields cannot be
            combined equivalently into a single search field).  We want the primary score to be the one associated with the highest boost,
            not the sum of the field scores (as BooleanQuery would give).
            If the query is "albino elephant" this ensures that "albino" matching one field and "elephant" matching
            another gets a higher score than "albino" matching both fields.
            To get this result, use both BooleanQuery and DisjunctionMaxQuery:  for each term a DisjunctionMaxQuery searches for it in
            each field, while the set of these DisjunctionMaxQuery's is combined into a BooleanQuery.
            The tie breaker capability allows results that include the same term in multiple fields to be judged better than results that
            include this term in only the best of those multiple fields, without confusing this with the better case of two different terms
            in the multiple fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.#ctor(System.Single)">
            <summary>Creates a new empty DisjunctionMaxQuery.  Use add() to add the subqueries.</summary>
            <param name="tieBreakerMultiplier">the score of each non-maximum disjunct for a document is multiplied by this weight
            and added into the final score.  If non-zero, the value should be small, on the order of 0.1, which says that
            10 occurrences of word in a lower-scored field that is also in a higher scored field is just as good as a unique
            word in the lower scored field (i.e., one that is not in any higher scored field.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionMaxQuery.#ctor(System.Collections.ICollection,System.Single)" -->
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Add(Lucene.Net.Search.Query)">
            <summary>Add a subquery to this disjunction</summary>
            <param name="query">the disjunct added
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionMaxQuery.Add(System.Collections.ICollection)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionMaxQuery.Iterator" -->
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>Optimize our representation and our subqueries representations</summary>
            <param name="reader">the IndexReader we query
            </param>
            <returns> an optimized copy of us (which may not be a copy if there is nothing to optimize) 
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Clone">
            <summary>Create a shallow copy of us -- used in rewriting if necessary</summary>
            <returns> a copy of us (but reuse, don't copy, our subqueries) 
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.ToString(System.String)">
            <summary>Prettyprint us.</summary>
            <param name="field">the field to which we are applied
            </param>
            <returns> a string that shows what we do, of the form "(disjunct1 | disjunct2 | ... | disjunctn)^boost"
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Equals(System.Object)">
            <summary>Return true iff we represent the same query as o</summary>
            <param name="o">another object
            </param>
            <returns> true iff o is a DisjunctionMaxQuery with the same boost and the same subqueries, in the same order, as us
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.GetHashCode">
            <summary>Compute a hash code for hashing us</summary>
            <returns> the hash code
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.ComplexExplanation">
            <summary>
            Expert: Describes the score computation for document and query, and
            can distinguish a match independent of a positive value.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Explanation">
            <summary>Expert: Describes the score computation for document and query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.IsMatch">
            <summary> Indicates whether or not this Explanation models a good match.
            
            <p>
            By default, an Explanation represents a "match" if the value is positive.
            </p>
            </summary>
            <seealso cref="M:Lucene.Net.Search.Explanation.GetValue">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetValue">
            <summary>The value assigned to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.SetValue(System.Single)">
            <summary>Sets the value assigned to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetDescription">
            <summary>A description of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.SetDescription(System.String)">
            <summary>Sets the description of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetSummary">
            <summary> A short one line summary which should contain all high level
            information about this Explanation, without the "Details"
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetDetails">
            <summary>The sub-nodes of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.AddDetail(Lucene.Net.Search.Explanation)">
            <summary>Adds a sub-node to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.ToString">
            <summary>Render an explanation as text. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.ToHtml">
            <summary>Render an explanation as HTML. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ComplexExplanation.GetMatch">
            <summary> The match status of this explanation node.</summary>
            <returns> May be null if match status is unknown
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.ComplexExplanation.SetMatch(System.Boolean)">
            <summary> Sets the match status assigned to this explanation node.</summary>
            <param name="match">May be null if match status is unknown
            </param>
        </member>
        <member name="M:Lucene.Net.Search.ComplexExplanation.IsMatch">
            <summary> Indicates whether or not this Explanation models a good match.
            
            <p>
            If the match statis is explicitly set (ie: not null) this method
            uses it; otherwise it defers to the superclass.
            </p>
            </summary>
            <seealso cref="M:Lucene.Net.Search.ComplexExplanation.GetMatch">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermsHashConsumerPerField" -->
        <member name="M:Lucene.Net.Index.DocFieldConsumerPerField.processFields(Lucene.Net.Documents.Fieldable[],System.Int32)">
            <summary>
            Processes all occurrences of a single field
            </summary>
            <param name="fields"></param>
            <param name="count"></param>
        </member>
        <member name="T:Lucene.Net.Index.RawPostingList">
            This is the base class for an in-memory posting list,
            keyed by a Token.  {@link TermsHash} maintains a hash
            table holding one instance of this per unique Token.
            Consumers of TermsHash (@link TermsHashConsumer} must
            subclass this class with its own concrete class.
            {@link FreqProxTermsWriter.RawPostingList} is the
            subclass used for the freq/prox postings, and {@link
            TermVectorsTermsWriter.PostingList} is the subclass
            used to hold TermVectors postings. 
        </member>
        <member name="T:Lucene.Net.Index.ByteSliceWriter">
            <summary>
            Class to write byte streams into slices of shared
            byte[].  This is used by DocumentsWriter to hold the
            posting list for many terms in RAM.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ByteSliceWriter.Init(System.Int32)">
            <summary>
            Set up the writer to write at address.
            </summary>
            <param name="address"></param>
        </member>
        <member name="M:Lucene.Net.Index.ByteSliceWriter.WriteByte(System.Byte)">
            <summary> 
            Write byte into byte slice stream
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ByteSliceReader">
            <summary>
            IndexInput that knows how to read the byte slices written
            by Posting and PostingVector.  We read the bytes in
            each slice until we hit the end of that slice at which
            point we read the forwarding address of the next slice
            and then jump to it.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.DateField" -->
        <member name="M:Lucene.Net.Documents.DateField.DateToString(System.DateTime)">
            <summary> Converts a Date to a string suitable for indexing.</summary>
            <throws>  SystemException if the date specified in the </throws>
            <summary> method argument is before 1970
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateField.TimeToString(System.Int64)">
            <summary> Converts a millisecond time to a string suitable for indexing.</summary>
            <throws>  SystemException if the time specified in the </throws>
            <summary> method argument is negative, that is, before 1970
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateField.StringToTime(System.String)">
            <summary>Converts a string-encoded date into a millisecond time. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateField.StringToDate(System.String)">
            <summary>Converts a string-encoded date into a Date object. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Standard.StandardTokenizer" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Tokenizer" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.TokenStream" -->
        <member name="M:Lucene.Net.Analysis.TokenStream.Next">
            <summary>Returns the next token in the stream, or null at EOS.
            @deprecated The returned Token is a "full private copy" (not
            re-used across calls to next()) but will be slower
            than calling {@link #Next(Token)} instead.. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.TokenStream.Next(Lucene.Net.Analysis.Token)" -->
        <member name="M:Lucene.Net.Analysis.TokenStream.Reset">
            <summary>Resets this stream to the beginning. This is an
            optional operation, so subclasses may or may not
            implement this method. Reset() is not needed for
            the standard indexing process. However, if the Tokens 
            of a TokenStream are intended to be consumed more than 
            once, it is necessary to implement reset().
            once, it is necessary to implement reset().  Note that
            if your TokenStream caches tokens and feeds them back
            again after a reset, it is imperative that you
            clone the tokens when you store them away (on the
            first pass) as well as when you return them (on future
            passes after reset()).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.Close">
            <summary>Releases resources associated with this stream. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Tokenizer.input">
            <summary>The text source for this Tokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.#ctor">
            <summary>Construct a tokenizer with null input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a token stream processing the given input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.Close">
            <summary>By default, closes the input Reader. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.Reset(System.IO.TextReader)">
            <summary>Expert: Reset the tokenizer to a new reader.  Typically, an
            analyzer (in its reusableTokenStream method) will use
            this to re-use a previously created tokenizer. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizer.ACRONYM_DEP">
            <deprecated> this solves a bug where HOSTs that end with '.' are identified
            as ACRONYMs. It is deprecated and will be removed in the next
            release.
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizer.scanner">
            <summary>A private instance of the JFlex-constructed scanner </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizer.tokenImage">
            @deprecated Please use {@link #TOKEN_TYPES} instead 
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizer.replaceInvalidAcronym">
            <summary> Specifies whether deprecated acronyms should be replaced with HOST type.
            This is false by default to support backward compatibility.
            <p/>
            See http://issues.apache.org/jira/browse/LUCENE-1068
            
            </summary>
            <deprecated> this should be removed in the next release (3.0).
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizer.SetMaxTokenLength(System.Int32)">
            <summary>Set the max allowed token length.  Any token longer
            than this is skipped. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizer.GetMaxTokenLength">
            <seealso cref="!:setMaxTokenLength">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizer.#ctor(System.IO.TextReader)">
            <summary> Creates a new instance of the {@link StandardTokenizer}. Attaches the
            <code>input</code> to a newly created JFlex scanner.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizer.#ctor(System.IO.TextReader,System.Boolean)">
            <summary> Creates a new instance of the {@link Lucene.Net.Analysis.Standard.StandardTokenizer}.  Attaches
            the <code>input</code> to the newly created JFlex scanner.
            
            </summary>
            <param name="input">The input reader
            </param>
            <param name="replaceInvalidAcronym">Set to true to replace mischaracterized acronyms with HOST.
            
            See http://issues.apache.org/jira/browse/LUCENE-1068
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizer.IsReplaceInvalidAcronym">
            <summary> Prior to https://issues.apache.org/jira/browse/LUCENE-1068, StandardTokenizer mischaracterized as acronyms tokens like www.abc.com
            when they should have been labeled as hosts instead.
            </summary>
            <returns> true if StandardTokenizer now returns these tokens as Hosts, otherwise false
            
            </returns>
            <deprecated> Remove in 3.X and make true the only valid value
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizer.SetReplaceInvalidAcronym(System.Boolean)">
            <summary> </summary>
            <param name="replaceInvalidAcronym">Set to true to replace mischaracterized acronyms as HOST.
            </param>
            <deprecated> Remove in 3.X and make true the only valid value
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            </deprecated>
        </member>
        <member name="T:Lucene.Net.Analysis.Standard.StandardAnalyzer">
            <summary> Filters {@link StandardTokenizer} with {@link StandardFilter}, {@link
            LowerCaseFilter} and {@link StopFilter}, using a list of English stop words.
            
            </summary>
            <version>  $Id: StandardAnalyzer.java 613280 2008-01-18 21:27:10Z gsingers $
            </version>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardAnalyzer.DEFAULT_MAX_TOKEN_LENGTH">
            <summary>Default maximum allowed token length </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardAnalyzer.STOP_WORDS">
            <summary>An array containing some common English words that are usually not
            useful for searching. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.GetDefaultReplaceInvalidAcronym">
            <summary>
            see https://issues.apache.org/jira/browse/LUCENE-1068
            </summary>
            <returns>true if new instances of StandardTokenizer will replace mischaracterized acronyms</returns>
            <deprecated>this will be removed (hardwired to true) in 3.0</deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.SetDefaultReplaceInvalidAcronym(System.Boolean)">
            <summary>
            set to true to have new instances of StandardTokenizer
            replace mischaracerized acronyms by default.  Set to 
            false to preserve the previous (before 2.4) buggy behavior.
            Alternatively, set the system property 
            Lucene.Net.Analysis.Standard.StandardAnalyzer.replaceInvalidAcronym
            to false.
            </summary>
            <param name="replaceInvalidAcronym"/>
            <deprecated>this will be removed (hardwired to true) in 3.0</deprecated>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardAnalyzer.replaceInvalidAcronym">
            <summary> Specifies whether deprecated acronyms should be replaced with HOST type.
            This is false by default to support backward compatibility.
            
            </summary>
            <deprecated> this should be removed in the next release (3.0).
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor">
            <summary>Builds an analyzer with the default stop words ({@link #STOP_WORDS}). </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.Collections.Hashtable)">
            <summary>Builds an analyzer with the given stop words. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.String[])">
            <summary>Builds an analyzer with the given stop words. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.IO.FileInfo)">
            <summary>Builds an analyzer with the stop words from the given file.</summary>
            <seealso cref="!:WordlistLoader.GetWordSet(File)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.IO.TextReader)">
            <summary>Builds an analyzer with the stop words from the given reader.</summary>
            <seealso cref="!:WordlistLoader.GetWordSet(Reader)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.Boolean)">
            <summary> </summary>
            <param name="replaceInvalidAcronym">Set to true if this analyzer should replace mischaracterized acronyms in the StandardTokenizer
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            
            </param>
            <deprecated> Remove in 3.X and make true the only valid value
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.IO.TextReader,System.Boolean)">
            <param name="stopwords">The stopwords to use
            </param>
            <param name="replaceInvalidAcronym">Set to true if this analyzer should replace mischaracterized acronyms in the StandardTokenizer
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            
            </param>
            <deprecated> Remove in 3.X and make true the only valid value
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.IO.FileInfo,System.Boolean)">
            <param name="stopwords">The stopwords to use
            </param>
            <param name="replaceInvalidAcronym">Set to true if this analyzer should replace mischaracterized acronyms in the StandardTokenizer
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            
            </param>
            <deprecated> Remove in 3.X and make true the only valid value
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.String[],System.Boolean)">
            <summary> </summary>
            <param name="stopwords">The stopwords to use
            </param>
            <param name="replaceInvalidAcronym">Set to true if this analyzer should replace mischaracterized acronyms in the StandardTokenizer
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            
            </param>
            <deprecated> Remove in 3.X and make true the only valid value
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.#ctor(System.Collections.Hashtable,System.Boolean)">
            <param name="stopwords">The stopwords to use
            </param>
            <param name="replaceInvalidAcronym">Set to true if this analyzer should replace mischaracterized acronyms in the StandardTokenizer
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            
            </param>
            <deprecated> Remove in 3.X and make true the only valid value
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.TokenStream(System.String,System.IO.TextReader)">
            <summary>Constructs a {@link StandardTokenizer} filtered by a {@link
            StandardFilter}, a {@link LowerCaseFilter} and a {@link StopFilter}. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.SetMaxTokenLength(System.Int32)">
            <summary> Set maximum allowed token length.  If a token is seen
            that exceeds this length then it is discarded.  This
            setting only takes effect the next time tokenStream or
            reusableTokenStream is called.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.GetMaxTokenLength">
            <seealso cref="!:setMaxTokenLength">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.IsReplaceInvalidAcronym">
            <summary> </summary>
            <returns> true if this Analyzer is replacing mischaracterized acronyms in the StandardTokenizer
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            </returns>
            <deprecated>this will be removed (hardwired to true) in 3.0</deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardAnalyzer.SetReplaceInvalidAcronym(System.Boolean)">
            <summary> </summary>
            <param name="replaceInvalidAcronym">Set to true if this Analyzer is replacing mischaracterized acronyms in the StandardTokenizer
            
            See https://issues.apache.org/jira/browse/LUCENE-1068
            </param>
            <deprecated>this will be removed (hardwired to true) in 3.0</deprecated>
        </member>
        <member name="T:Lucene.Net.Util.StringHelper">
            <summary>
            Methods for manipulating strings.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.bytesDifference(System.Byte[],System.Int32,System.Byte[],System.Int32)">
            <summary>
            Compares two byte arrays, starting at their 0th elements, and returns the 
            number of common elements before encountering a difference.
            </summary>
            <param name="bytes1"></param>
            <param name="len1"></param>
            <param name="bytes2"></param>
            <param name="len2"></param>
            <returns>the number of common elements</returns>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.StringDifference(System.String,System.String)">
            <summary> Compares two strings, character by character, and returns the
            first position where the two strings differ from one another.
            
            </summary>
            <param name="s1">The first string to compare
            </param>
            <param name="s2">The second string to compare
            </param>
            <returns> The first position where the two strings differ.
            </returns>
        </member>
        <member name="T:Lucene.Net.Util.SmallFloat">
            <summary>
            Floating point numbers smaller than 32 bits.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SmallFloat.FloatToByte(System.Single,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Util.SmallFloat.ByteToFloat(System.Byte,System.Int32,System.Int32)">
            <summary>Converts an 8 bit float to a 32 bit float. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SmallFloat.FloatToByte315(System.Single)" -->
        <member name="M:Lucene.Net.Util.SmallFloat.Byte315ToFloat(System.Byte)">
            <summary>byteToFloat(b, mantissaBits=3, zeroExponent=15) </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SmallFloat.FloatToByte52(System.Single)" -->
        <member name="M:Lucene.Net.Util.SmallFloat.Byte52ToFloat(System.Byte)">
            <summary>byteToFloat(b, mantissaBits=5, zeroExponent=2) </summary>
        </member>
        <member name="T:Lucene.Net.Store.RAMInputStream">
            <summary> A memory-resident {@link IndexInput} implementation.
            
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedIndexOutput">
            <summary>Base implementation class for buffered {@link IndexOutput}. </summary>
        </member>
        <member name="T:Lucene.Net.Store.IndexOutput">
            <summary>Abstract base class for output to a file in a Directory.  A random-access
            output stream.  Used for all Lucene index output operations.
            </summary>
            <seealso cref="T:Lucene.Net.Store.Directory">
            </seealso>
            <seealso cref="T:Lucene.Net.Store.IndexInput">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteByte(System.Byte)">
            <summary>Writes a single byte.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadByte">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteBytes(System.Byte[],System.Int32)">
            <summary>Writes an array of bytes.</summary>
            <param name="b">the bytes to write
            </param>
            <param name="length">the number of bytes to write
            </param>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Writes an array of bytes.</summary>
            <param name="b">the bytes to write
            </param>
            <param name="offset">the offset in the byte array
            </param>
            <param name="length">the number of bytes to write
            </param>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteInt(System.Int32)">
            <summary>Writes an int as four bytes.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadInt">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteVInt(System.Int32)">
            <summary>Writes an int in a variable-length format.  Writes between one and
            five bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            </summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadVInt">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteLong(System.Int64)">
            <summary>Writes a long as eight bytes.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadLong">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteVLong(System.Int64)">
            <summary>Writes an long in a variable-length format.  Writes between one and five
            bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            </summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadVLong">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteString(System.String)">
            <summary>Writes a string.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadString">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteChars(System.String,System.Int32,System.Int32)">
            <summary>Writes a sub sequence of chars from s as "modified UTF-8" encoded bytes.</summary>
            <param name="s">the source of the characters</param>
            <param name="start">the first character in the sequence</param>
            <param name="length">the number of characters in the sequence</param>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.WriteChars(System.Char[],System.Int32,System.Int32)">
            <summary>Writes a sub sequence of chars from s as "modified UTF-8" encoded bytes.</summary>
            <param name="s">the source of the characters</param>
            <param name="start">the first character in the sequence</param>
            <param name="length">the number of characters in the sequence</param>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.CopyBytes(Lucene.Net.Store.IndexInput,System.Int64)">
            <summary>Copy numBytes bytes from input to ourself. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Flush">
            <summary>Forces any buffered output to be written. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Close">
            <summary>Closes this stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.GetFilePointer">
            <summary>Returns the current position in this file, where the next write will
            occur.
            </summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.Seek(System.Int64)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Seek(System.Int64)">
            <summary>Sets current position in this file, where the next write will occur.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.GetFilePointer">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Length">
            <summary>The number of bytes in the file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.SetLength(System.Int64)">
            <summary>
            Set the file length. By default, this method does
            nothing (it's optional for a Directory to implement
            it).  But, certain Directory implementations (for
            example @see FSDirectory) can use this to inform the
            underlying IO system to pre-allocate the file to the
            specified size.  If the length is longer than the
            current file length, the bytes added to the file are
            undefined.  Otherwise the file is truncated.
            <param name="length">file length</param>
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.WriteByte(System.Byte)">
            <summary>Writes a single byte.</summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadByte">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Writes an array of bytes.</summary>
            <param name="b">the bytes to write
            </param>
            <param name="length">the number of bytes to write
            </param>
            <seealso cref="M:Lucene.Net.Store.IndexInput.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.Flush">
            <summary>Forces any buffered output to be written. </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.FlushBuffer(System.Byte[],System.Int32)">
            <summary>Expert: implements buffer write.  Writes bytes at the current position in
            the output.
            </summary>
            <param name="b">the bytes to write
            </param>
            <param name="len">the number of bytes to write
            </param>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.FlushBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>Expert: implements buffer write.  Writes bytes at the current position in
            the output.
            </summary>
            <param name="b">the bytes to write
            </param>
            <param name="offset">the offset in the byte array
            </param>
            <param name="len">the number of bytes to write
            </param>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.Close">
            <summary>Closes this stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.GetFilePointer">
            <summary>Returns the current position in this file, where the next write will
            occur.
            </summary>
            <seealso cref="M:Lucene.Net.Store.BufferedIndexOutput.Seek(System.Int64)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.Seek(System.Int64)">
            <summary>Sets current position in this file, where the next write will occur.</summary>
            <seealso cref="M:Lucene.Net.Store.BufferedIndexOutput.GetFilePointer">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.Length">
            <summary>The number of bytes in the file. </summary>
        </member>
        <member name="T:Lucene.Net.Store.AlreadyClosedException">
            <summary> This exception is thrown when there is an attempt to
            access something that has already been closed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopDocs">
            <summary>Expert: Returned by low-level search implementations.</summary>
            <seealso cref="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.totalHits">
            <summary>Expert: The total number of hits for the query.</summary>
            <seealso cref="M:Lucene.Net.Search.Hits.Length">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.scoreDocs">
            <summary>Expert: The top hits for the query. </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.maxScore">
            <summary>Expert: Stores the maximum score value encountered, needed for normalizing. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocs.GetMaxScore">
            <summary>Expert: Returns the maximum score value encountered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocs.SetMaxScore(System.Single)">
            <summary>Expert: Sets the maximum score value encountered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocs.#ctor(System.Int32,Lucene.Net.Search.ScoreDoc[],System.Single)">
            <summary>Expert: Constructs a TopDocs.</summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanScorer">
            <summary> Public for extension only.</summary>
        </member>
        <member name="T:Lucene.Net.Search.RangeQuery">
            <summary> A Query that matches documents within an exclusive range. A RangeQuery
            is built by QueryParser for input like <code>[010 TO 120]</code> but only if the QueryParser has 
            the useOldRangeQuery property set to true. The QueryParser default behaviour is to use
            the newer ConstantScoreRangeQuery class. This is generally preferable because:
            <ul>
            <li>It is faster than RangeQuery</li>
            <li>Unlike RangeQuery, it does not cause a BooleanQuery.TooManyClauses exception if the range of values is large</li>
            <li>Unlike RangeQuery it does not influence scoring based on the scarcity of individual terms that may match</li>
            </ul>
            
            
            </summary>
            <seealso cref="T:Lucene.Net.Search.ConstantScoreRangeQuery"/>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.#ctor(Lucene.Net.Index.Term,Lucene.Net.Index.Term,System.Boolean)">
            <summary>Constructs a query selecting all terms greater than
            <code>lowerTerm</code> but less than <code>upperTerm</code>.
            There must be at least one term and either term may be null,
            in which case there is no bound on that side, but if there are
            two terms, both terms <b>must</b> be for the same field.
            </summary>
            <param name="lowerTerm">term at the lower end of the range</param>
            <param name="upperTerm">term at the upper end of the range</param>
            <param name="inclusive">if true, both lowerTerm and upperTerm will be included in the range</param>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetField">
            <summary>Returns the field name for this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetLowerTerm">
            <summary>Returns the lower term of this range query </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetUpperTerm">
            <summary>Returns the upper term of this range query </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.IsInclusive">
            <summary>Returns <code>true</code> if the range query is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetCollator">
            <summary>
            Returns the collator used to determine range inclusion, if any.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.ExtendedFieldCacheImpl">
            <summary> 
            
            
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl">
            <summary>
            Expert: The default cache implementation, storing all values in memory.
            A WeakHashMap is used for storage.
            </summary>
            <since>lucene 1.4</since>
            <version>$Id:$</version>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetBytes(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>field</code> as a single byte and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the single byte values.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetBytes(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.ByteParser)">
            <summary>Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <code>field</code> as bytes and returns an array of
            size <code>reader.maxDoc()</code> of the value each document has in the
            given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the bytes.
            </param>
            <param name="parser"> Computes byte for string values.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetShorts(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>field</code> as shorts and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the shorts.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetShorts(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.ShortParser)">
            <summary>Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <code>field</code> as shorts and returns an array of
            size <code>reader.maxDoc()</code> of the value each document has in the
            given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the shorts.
            </param>
            <param name="parser"> Computes short for string values.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetInts(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>field</code> as integers and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the integers.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetInts(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.IntParser)">
            <summary>Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <code>field</code> as integers and returns an array of
            size <code>reader.maxDoc()</code> of the value each document has in the
            given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the integers.
            </param>
            <param name="parser"> Computes integer for string values.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetFloats(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <code>field</code> as floats and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the floats.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetFloats(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.FloatParser)">
            <summary>Checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <code>field</code> as floats and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the floats.
            </param>
            <param name="parser"> Computes float for string values.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetStrings(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none
            is found, reads the term values in <code>field</code> and returns an array
            of size <code>reader.maxDoc()</code> containing the value each document
            has in the given field.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the strings.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetStringIndex(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if none
            is found reads the term values in <code>field</code> and returns
            an array of them in natural order, along with an array telling
            which element in the term array each document uses.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the strings.
            </param>
            <returns> Array of terms and index into the array for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetAuto(Lucene.Net.Index.IndexReader,System.String)">
            <summary>Checks the internal cache for an appropriate entry, and if
            none is found reads <code>field</code> to see if it contains integers, floats
            or strings, and then calls one of the other methods in this class to get the
            values.  For string values, a StringIndex is returned.  After
            calling this method, there is an entry in the cache for both
            type <code>AUTO</code> and the actual found type.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the values.
            </param>
            <returns> int[], float[] or StringIndex.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.GetCustom(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.SortComparator)">
            <summary>Checks the internal cache for an appropriate entry, and if none
            is found reads the terms out of <code>field</code> and calls the given SortComparator
            to get the sort values.  A hit in the cache will happen if <code>reader</code>,
            <code>field</code>, and <code>comparator</code> are the same (using <code>equals()</code>)
            as a previous call to this method.
            </summary>
            <param name="reader"> Used to get field values.
            </param>
            <param name="field">  Which field contains the values.
            </param>
            <param name="comparator">Used to convert terms into something to sort by.
            </param>
            <returns> Array of sort objects, one for each document.
            </returns>
            <throws>  IOException  If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetAuto(Lucene.Net.Index.IndexReader,System.String)">
            <summary>The pattern used to detect float values in a field </summary>
            <summary> removed for java 1.3 compatibility
            protected static final object pFloats = Pattern.compile ("[0-9+\\-\\.eEfFdD]+");
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ByteParser">
            <summary>Interface to parse bytes from document fields.</summary>
            <seealso cref="!:FieldCache.GetBytes(IndexReader, String, FieldCache.ByteParser)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.ByteParser.ParseByte(System.String)">
            <summary>Return a single Byte representation of this field's value. </summary>
        </member>
        <member name="T:Lucene.Net.Search.ShortParser">
            <summary>Interface to parse shorts from document fields.</summary>
            <seealso cref="!:FieldCache.GetShorts(IndexReader, String, FieldCache.ShortParser)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.ShortParser.ParseShort(System.String)">
            <summary>Return a short representation of this field's value. </summary>
        </member>
        <member name="T:Lucene.Net.Search.IntParser">
            <summary>Interface to parse ints from document fields.</summary>
            <seealso cref="!:FieldCache.GetInts(IndexReader, String, FieldCache.IntParser)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.IntParser.ParseInt(System.String)">
            <summary>Return an integer representation of this field's value. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FloatParser">
            <summary>Interface to parse floats from document fields.</summary>
            <seealso cref="!:FieldCache.GetFloats(IndexReader, String, FieldCache.FloatParser)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.FloatParser.ParseFloat(System.String)">
            <summary>Return an float representation of this field's value. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Cache">
            <summary>Expert: Internal cache. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Entry">
            <summary>Expert: Every composite-key in the internal cache is of this type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.#ctor(System.String,System.Int32,System.Globalization.CultureInfo)">
            <summary>Creates one of these objects. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.#ctor(System.String,System.Object)">
            <summary>Creates one of these objects for a custom comparator. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.Equals(System.Object)">
            <summary>Two of these are equal iff they reference the same field and type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Entry.GetHashCode">
            <summary>Composes a hashcode based on the field and type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ExtendedFieldCache.GetLongs(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>field</code> as longs and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            
            </summary>
            <param name="reader">Used to get field values.
            </param>
            <param name="field"> Which field contains the longs.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  java.io.IOException If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.ExtendedFieldCache.GetLongs(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.LongParser)">
            <summary> Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <code>field</code> as longs and returns an array of
            size <code>reader.maxDoc()</code> of the value each document has in the
            given field.
            
            </summary>
            <param name="reader">Used to get field values.
            </param>
            <param name="field"> Which field contains the longs.
            </param>
            <param name="parser">Computes integer for string values.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.ExtendedFieldCache.GetDoubles(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>field</code> as integers and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            
            </summary>
            <param name="reader">Used to get field values.
            </param>
            <param name="field"> Which field contains the doubles.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.ExtendedFieldCache.GetDoubles(Lucene.Net.Index.IndexReader,System.String,Lucene.Net.Search.DoubleParser)">
            <summary> Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <code>field</code> as doubles and returns an array of
            size <code>reader.maxDoc()</code> of the value each document has in the
            given field.
            
            </summary>
            <param name="reader">Used to get field values.
            </param>
            <param name="field"> Which field contains the doubles.
            </param>
            <param name="parser">Computes integer for string values.
            </param>
            <returns> The values in the given field for each document.
            </returns>
            <throws>  IOException If any error occurs. </throws>
        </member>
        <member name="M:Lucene.Net.Search.LongParser.ParseLong(System.String)">
            <summary> Return an long representation of this field's value.</summary>
        </member>
        <member name="M:Lucene.Net.Search.DoubleParser.ParseDouble(System.String)">
            <summary> Return an long representation of this field's value.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermDocs" -->
        <member name="M:Lucene.Net.Index.TermDocs.Seek(Lucene.Net.Index.Term)">
            <summary>Sets this to the data for a term.
            The enumeration is reset to the start of the data for this term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermDocs.Seek(Lucene.Net.Index.TermEnum)">
            <summary>Sets this to the data for the current term in a {@link TermEnum}.
            This may be optimized in some implementations.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Doc" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Freq" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Next" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.Read(System.Int32[],System.Int32[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermDocs.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Index.TermDocs.Close">
            <summary>Frees associated resources. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiLevelSkipListWriter">
            <summary> This abstract class writes skip lists with multiple levels.
            
            Example for skipInterval = 3:
            c            (skip level 2)
            c                 c                 c            (skip level 1) 
            x     x     x     x     x     x     x     x     x     x      (skip level 0)
            d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  (posting list)
            3     6     9     12    15    18    21    24    27    30     (df)
            
            d - document
            x - skip data
            c - skip data with child pointer
            
            Skip level i contains every skipInterval-th entry from skip level i-1.
            Therefore the number of entries on level i is: floor(df / ((skipInterval ^ (i + 1))).
            
            Each skip entry on a level i>0 contains a pointer to the corresponding skip entry in list i-1.
            This guarantess a logarithmic amount of skips to find the target document.
            
            While this class takes care of writing the different skip levels,
            subclasses must define the actual format of the skip data.
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListWriter.WriteSkipData(System.Int32,Lucene.Net.Store.IndexOutput)">
            <summary> Subclasses must implement the actual skip data encoding in this method.
            
            </summary>
            <param name="level">the level skip data shall be writting for
            </param>
            <param name="skipBuffer">the skip buffer to write to
            </param>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListWriter.BufferSkip(System.Int32)">
            <summary> Writes the current skip data to the buffers. The current document frequency determines
            the max level is skip data is to be written to. 
            
            </summary>
            <param name="df">the current document frequency 
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListWriter.WriteSkip(Lucene.Net.Store.IndexOutput)">
            <summary> Writes the buffered skip lists to the given output.
            
            </summary>
            <param name="output">the IndexOutput the skip lists shall be written to 
            </param>
            <returns> the pointer the skip list starts
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.MultiLevelSkipListReader">
            <summary> This abstract class reads skip lists with multiple levels.
            
            See {@link MultiLevelSkipListWriter} for the information about the encoding 
            of the multi level skip lists. 
            
            Subclasses must implement the abstract method {@link #ReadSkipData(int, IndexInput)}
            which defines the actual format of the skip data.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListReader.GetDoc">
            <summary>Returns the id of the doc to which the last call of {@link #SkipTo(int)}
            has skipped.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListReader.SkipTo(System.Int32)">
            <summary>Skips entries to the first beyond the current whose document number is
            greater than or equal to <i>target</i>. Returns the current doc count. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListReader.SeekChild(System.Int32)">
            <summary>Seeks the skip entry on the given level </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListReader.Init(System.Int64,System.Int32)">
            <summary>initializes the reader </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListReader.LoadSkipLevels">
            <summary>Loads the skip levels  </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListReader.ReadSkipData(System.Int32,Lucene.Net.Store.IndexInput)">
            <summary> Subclasses must implement the actual skip data encoding in this method.
            
            </summary>
            <param name="level">the level skip data shall be read from
            </param>
            <param name="skipStream">the skip stream to read from
            </param>
        </member>
        <member name="M:Lucene.Net.Index.MultiLevelSkipListReader.SetLastSkipData(System.Int32)">
            <summary>Copies the values of the last read skip entry on this level </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiLevelSkipListReader.SkipBuffer">
            <summary>used to buffer the top skip levels </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocInverterPerField">
            <summary>
            Holds state for inverting all occurrences of a single
            field in the document.  This class doesn't do anything
            itself; instead, it forwards the tokens produced by
            analysis to its own consumer
            (InvertedDocConsumerPerField).  It also interacts with an
            endConsumer (InvertedDocEndConsumerPerField).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldConsumer.flush(System.Collections.Generic.IDictionary{System.Object,System.Collections.Generic.ICollection{System.Object}},Lucene.Net.Index.DocumentsWriter.FlushState)">
            <summary>
            Called when DocumentsWriter decides to create a new
            segment
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldConsumer.closeDocStore(Lucene.Net.Index.DocumentsWriter.FlushState)">
            <summary>
            Called when DocumentsWriter decides to close the doc
            stores
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldConsumer.Abort">
            <summary>
            Called when an aborting exception is hit
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldConsumer.addThread(Lucene.Net.Index.DocFieldProcessorPerThread)">
            <summary>
            Add a new thread
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldConsumer.freeRAM">
            <summary>
            Called when DocumentsWriter is using too much RAM.
            The consumer should free RAM, if possible, returning
            true if any RAM was in fact freed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Standard.StandardTokenizerImpl">
            <summary> This class is a scanner generated by 
            <a href="http://www.jflex.de/">JFlex</a> 1.4.1
            on 12/18/07 9:22 PM from the specification file
            <tt>/Volumes/User/grantingersoll/projects/lucene/java/lucene-clean/src/java/org/apache/lucene/analysis/standard/StandardTokenizerImpl.jflex</tt>
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.YYEOF">
            <summary>This character denotes the end of file </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZZ_BUFFERSIZE">
            <summary>initial size of the lookahead buffer </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.YYINITIAL">
            <summary>lexical states </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZZ_CMAP_PACKED">
            <summary> Translates characters to character classes</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ACRONYM_DEP">
            <deprecated> this solves a bug where HOSTs that end with '.' are identified
            as ACRONYMs. It is deprecated and will be removed in the next
            release.
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZZ_CMAP">
            <summary> Translates characters to character classes</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZZ_ACTION">
            <summary> Translates DFA states to action switch labels.</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZZ_ROWMAP">
            <summary> Translates a state to a row index in the transition table</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZZ_TRANS">
            <summary> The transition table of the DFA</summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZZ_ATTRIBUTE">
            <summary> ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code></summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzReader">
            <summary>the input device </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzState">
            <summary>the current state of the DFA </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzLexicalState">
            <summary>the current lexical state </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzBuffer">
            <summary>this buffer contains the current text to be matched and is
            the source of the yytext() string 
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzMarkedPos">
            <summary>the textposition at the last accepting state </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzPushbackPos">
            <summary>the textposition at the last state to be included in yytext </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzCurrentPos">
            <summary>the current text position in the buffer </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzStartRead">
            <summary>startRead marks the beginning of the yytext() string in the buffer </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzEndRead">
            <summary>endRead marks the last character in the buffer, that has been read
            from input 
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.yyline">
            <summary>number of newlines encountered up to the start of the matched text </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.yychar">
            <summary>the number of characters up to the start of the matched text </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.yycolumn">
            <summary> the number of characters from the last newline up to the start of the 
            matched text
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzAtBOL" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.zzAtEOF" -->
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.GetText(Lucene.Net.Analysis.Token)">
            <summary> Fills Lucene token with the current token text.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.#ctor(System.IO.TextReader)">
            <summary> Creates a new scanner
            There is also a java.io.InputStream version of this constructor.
            
            </summary>
            <param name="in"> the java.io.Reader to read input from.
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.#ctor(System.IO.Stream)">
            <summary> Creates a new scanner.
            There is also java.io.Reader version of this constructor.
            
            </summary>
            <param name="in"> the java.io.Inputstream to read input from.
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZzUnpackCMap(System.String)">
            <summary> Unpacks the compressed character translation table.
            
            </summary>
            <param name="packed">  the packed character translation table
            </param>
            <returns>         the unpacked character translation table
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZzRefill">
            <summary> Refills the input buffer.
            
            </summary>
            <returns>      <code>false</code>, iff there was new input.
            
            </returns>
            <exception cref="!:java.io.IOException"> if any I/O-Error occurs
            </exception>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yyclose">
            <summary> Closes the input stream.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yyreset(System.IO.TextReader)">
            <summary> Resets the scanner to read from a new input stream.
            Does not close the old reader.
            
            All internal variables are reset, the old input stream 
            <b>cannot</b> be reused (internal buffer is discarded and lost).
            Lexical state is set to <tt>ZZ_INITIAL</tt>.
            
            </summary>
            <param name="reader">  the new input stream 
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yystate">
            <summary> Returns the current lexical state.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yybegin(System.Int32)">
            <summary> Enters a new lexical state
            
            </summary>
            <param name="newState">the new lexical state
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yytext">
            <summary> Returns the text matched by the current regular expression.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yycharat(System.Int32)">
            <summary> Returns the character at position <tt>pos</tt> from the 
            matched text. 
            
            It is equivalent to yytext().charAt(pos), but faster
            
            </summary>
            <param name="pos">the position of the character to fetch. 
            A value from 0 to yylength()-1.
            
            </param>
            <returns> the character at position pos
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yylength">
            <summary> Returns the length of the matched text region.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.ZzScanError(System.Int32)">
            <summary> Reports an error that occured while scanning.
            
            In a wellformed scanner (no or only correct usage of 
            yypushback(int) and a match-all fallback rule) this method 
            will only be called with things that "Can't Possibly Happen".
            If this method is called, something is seriously wrong
            (e.g. a JFlex bug producing a faulty scanner etc.).
            
            Usual syntax/scanner level error handling should be done
            in error fallback rules.
            
            </summary>
            <param name="errorCode"> the code of the errormessage to display
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.Yypushback(System.Int32)">
            <summary> Pushes the specified amount of characters back into the input stream.
            
            They will be read again by then next call of the scanning method
            
            </summary>
            <param name="number"> the number of characters to be read again.
            This number must not be greater than yylength()!
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardTokenizerImpl.GetNextToken">
            <summary> Resumes scanning until the next regular expression is matched,
            the end of input is encountered or an I/O-Error occurs.
            
            </summary>
            <returns>      the next token
            </returns>
            <exception cref="!:java.io.IOException"> if any I/O-Error occurs
            </exception>
        </member>
        <member name="T:Lucene.Net.Analysis.SimpleAnalyzer">
            <summary>An Analyzer that filters LetterTokenizer with LowerCaseFilter. </summary>
        </member>
        <member name="T:Lucene.Net.Util.UnicodeUtil">
             Class to encode java's UTF16 char[] into UTF8 byte[]
             without always allocating a new byte[] as
             String.getBytes("UTF-8") does.
            
             <p><b>WARNING</b>: This API is a new and experimental and
             may suddenly change. </p>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF16toUTF8(System.Char[],System.Int32,Lucene.Net.Util.UnicodeUtil.UTF8Result)">
            Encode characters from a char[] source, starting at
            offset and stopping when the character 0xffff is seen.
            Returns the number of bytes written to bytesOut. 
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF16toUTF8(System.Char[],System.Int32,System.Int32,Lucene.Net.Util.UnicodeUtil.UTF8Result)">
            Encode characters from a char[] source, starting at
            offset for length chars.  Returns the number of bytes
            written to bytesOut. 
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF16toUTF8(System.String,System.Int32,System.Int32,Lucene.Net.Util.UnicodeUtil.UTF8Result)">
            Encode characters from this String, starting at offset
            for length characters.  Returns the number of bytes
            written to bytesOut. 
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF8toUTF16(System.Byte[],System.Int32,System.Int32,Lucene.Net.Util.UnicodeUtil.UTF16Result)">
            Convert UTF8 bytes into UTF16 characters.  If offset
            is non-zero, conversion starts at that starting point
            in utf8, re-using the results from the previous call
            up until offset. 
        </member>
        <member name="T:Lucene.Net.Store.ChecksumIndexInput">
            Writes bytes through to a primary IndexOutput, computing
            checksum as it goes. Note that you cannot use seek(). 
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TopFieldDocCollector" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TopDocCollector" -->
        <member name="F:Lucene.Net.Search.TopDocCollector.totalHits">
            <summary>
            The total number of hits the collector encountered.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocCollector.hq">
            <summary>
            The priority queue which holds the top-scoring document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocCollector.#ctor(System.Int32)">
            <summary>Construct to collect a given number of hits.</summary>
            <param name="numHits">the maximum number of hits to collect
            </param>
        </member>
        <member name="M:Lucene.Net.Search.TopDocCollector.#ctor(Lucene.Net.Util.PriorityQueue)">
            <summary>
            Constructor to collect the top-scoring documents by using the given PriorityQueue.
            </summary>
            <param name="hq"></param>
        </member>
        <member name="M:Lucene.Net.Search.TopDocCollector.GetTotalHits">
            <summary>The total number of documents that matched this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocCollector.TopDocs">
            <summary>The top-scoring hits. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopFieldDocCollector.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Search.Sort,System.Int32)">
            <summary>Construct to collect a given number of hits.</summary>
            <param name="reader">the index to be searched
            </param>
            <param name="sort">the sort criteria
            </param>
            <param name="numHits">the maximum number of hits to collect
            </param>
        </member>
        <member name="T:Lucene.Net.Search.TermScorer">
            <summary>Expert: A <code>Scorer</code> for documents matching a <code>Term</code>.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.#ctor(Lucene.Net.Search.Weight,Lucene.Net.Index.TermDocs,Lucene.Net.Search.Similarity,System.Byte[])" -->
        <member name="M:Lucene.Net.Search.TermScorer.Doc">
            <summary>Returns the current document number matching the query.
            Initially invalid, until {@link #next()} is called the first time.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.Next" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.SkipTo(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.Explain(System.Int32)" -->
        <member name="M:Lucene.Net.Search.TermScorer.ToString">
            <summary>Returns a string representation of this <code>TermScorer</code>. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanFirstQuery">
            <summary>Matches spans near the beginning of a field. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanQuery">
            <summary>Base class for span-based queries. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetSpans(Lucene.Net.Index.IndexReader)">
            <summary>Expert: Returns the matches for this query in an index.  Used internally
            to search for spans. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetPayloadSpans(Lucene.Net.Index.IndexReader)">
            <summary>
            Returns the matches for this query in an index, including access to any payloads
            at thos positions.  Implementin classes that want access to the payloads will need
            to implement this.
            <para>
            WARNING: The status of the Payloads feature is experimental.
            The APIs introduced here might change in the future and will not be
            supported anymore in such a cse.
            </para>
            </summary>
            <param name="reader">the reader to use to access spans/payloads</param>
            <returns>null</returns>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetField">
            <summary>Returns the name of the field matched by this query.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetTerms">
            <summary>Returns a collection of all terms matched by this query.</summary>
            <deprecated> use extractTerms instead
            </deprecated>
            <seealso cref="!:Query#ExtractTerms(Set)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,System.Int32)">
            <summary>Construct a SpanFirstQuery matching spans in <code>match</code> whose end
            position is less than or equal to <code>end</code>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.GetMatch">
            <summary>Return the SpanQuery whose matches are filtered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.GetEnd">
            <summary>Return the maximum end position permitted in a match. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.GetTerms">
            <summary>Returns a collection of all terms matched by this query.</summary>
            <deprecated> use extractTerms instead
            </deprecated>
            <seealso cref="!:#ExtractTerms(Set)">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Search.Spans.PayloadSpans">
             <summary>
               <font color="#FF0000">
             WARNING: The status of the <b>Payloads</b> feature is experimental.
             The APIs introduced here might change in the future and will not be
             supported anymore in such a case.</font>
            
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.Spans">
            <summary>Expert: an enumeration of span matches.  Used to implement span searching.
            Each span represents a range of term positions within a document.  Matches
            are enumerated in order, by increasing document number, within that by
            increasing start position and finally by increasing end position. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.Next">
            <summary>Move to the next match, returning true iff any such exists. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.Spans.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Search.Spans.Spans.Doc">
            <summary>Returns the document number of the current match.  Initially invalid. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.Start">
            <summary>Returns the start position of the current match.  Initially invalid. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.End">
            <summary>Returns the end position of the current match.  Initially invalid. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.PayloadSpans.GetPayload" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.PayloadSpans.IsPayloadAvailable" -->
        <member name="T:Lucene.Net.Search.SpanFilterResult">
            <summary>  The results of a SpanQueryFilter.  Wraps the BitSet and the position infomration from the SpanQuery
            
            <p/>
            NOTE: This API is still experimental and subject to change. 
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SpanFilterResult.#ctor(System.Collections.BitArray,System.Collections.IList)">
            <summary> </summary>
            <param name="bits">The bits for the Filter
            </param>
            <param name="positions">A List of {@link Lucene.Net.Search.SpanFilterResult.PositionInfo} objects
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SpanFilterResult.#ctor(Lucene.Net.Search.DocIdSet,System.Collections.IList)">
            <summary></summary>
            <param name="docIdSet">The DocIdSet for the Filter</param>
            <param name="positions">A List of {@link Lucene.Net.Search.SpanFilterResult.PositionInfo} objects</param>
        </member>
        <member name="M:Lucene.Net.Search.SpanFilterResult.GetPositions">
            <summary> The first entry in the array corresponds to the first "on" bit.
            Entries are increasing by document order
            </summary>
            <returns> A List of PositionInfo objects
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SpanFilterResult.GetDocIdSet">
            <summary>
            Returns the DocIdSet.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Search.SpanFilterResult.PositionInfo.GetPositions">
            <summary> </summary>
            <returns> A List of {@link Lucene.Net.Search.SpanFilterResult.StartEnd} objects
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SpanFilterResult.StartEnd.GetEnd">
            <summary> </summary>
            <returns> The end position of this match
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SpanFilterResult.StartEnd.GetStart">
            <summary> The Start position</summary>
            <returns> The start position of this match
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.QueryWrapperFilter" -->
        <member name="M:Lucene.Net.Search.QueryWrapperFilter.#ctor(Lucene.Net.Search.Query)">
            <summary>Constructs a filter which only matches documents matching
            <code>query</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.FloatFieldSource" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.FieldCacheSource" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.ValueSource" -->
        <member name="M:Lucene.Net.Search.Function.ValueSource.GetValues(Lucene.Net.Index.IndexReader)">
            <summary> Return the DocValues used by the function query.</summary>
            <param name="reader">the IndexReader used to read these values.
            If any caching is involved, that caching would also be IndexReader based.  
            </param>
            <throws>  IOException for any error. </throws>
        </member>
        <member name="M:Lucene.Net.Search.Function.ValueSource.Description">
            <summary> description of field, used in explain() </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.ValueSource.Equals(System.Object)">
            <summary> Needed for possible caching of query results - used by {@link ValueSourceQuery#equals(object)}.</summary>
            <seealso cref="!:object.equals(object)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Function.ValueSource.GetHashCode">
            <summary> Needed for possible caching of query results - used by {@link ValueSourceQuery#hashCode()}.</summary>
            <seealso cref="!:object.hashCode()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Function.FieldCacheSource.#ctor(System.String)">
            <summary> Create a cached field source for the input field.  </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.FieldCacheSource.GetCachedFieldValues(Lucene.Net.Search.FieldCache,System.String,Lucene.Net.Index.IndexReader)">
            <summary> Return cached DocValues for input field and reader.</summary>
            <param name="cache">FieldCache so that values of a field are loaded once per reader (RAM allowing)
            </param>
            <param name="field">Field for which values are required.
            </param>
            <seealso cref="T:Lucene.Net.Search.Function.ValueSource">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Function.FieldCacheSource.CachedFieldSourceEquals(Lucene.Net.Search.Function.FieldCacheSource)">
            <summary> Check if equals to another {@link FieldCacheSource}, already knowing that cache and field are equal.  </summary>
            <seealso cref="!:object.equals(java.lang.object)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Function.FieldCacheSource.CachedFieldSourceHashCode">
            <summary> Return a hash code of a {@link FieldCacheSource}, without the hash-codes of the field 
            and the cache (those are taken care of elsewhere).  
            </summary>
            <seealso cref="!:object.hashCode()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Function.FloatFieldSource.#ctor(System.String)">
            <summary> Create a cached float field source with default string-to-float parser. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.FloatFieldSource.#ctor(System.String,Lucene.Net.Search.FloatParser)">
            <summary> Create a cached float field source with a specific string-to-float parser. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.DocValues" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.DocValues.FloatVal(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.DocValues.IntVal(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.DocValues.LongVal(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.DocValues.DoubleVal(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.DocValues.StrVal(System.Int32)" -->
        <member name="M:Lucene.Net.Search.Function.DocValues.ToString(System.Int32)">
            <summary> Return a string representation of a doc value, as reuired for Explanations.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.DocValues.Explain(System.Int32)">
            <summary> Explain the scoring value for the input doc.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.DocValues.GetInnerArray" -->
        <member name="M:Lucene.Net.Search.Function.DocValues.GetMinValue">
            <summary> Optional op.
            Returns the minimum of all values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.DocValues.GetMaxValue">
            <summary> Optional op.
            Returns the maximum of all values. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.DocValues.GetAverageValue">
            <summary> Returns the average of all values. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.Reset(Lucene.Net.Index.SegmentInfo)">
            <summary> Copy everything from src SegmentInfo into our instance.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.#ctor(Lucene.Net.Store.Directory,System.Int32,Lucene.Net.Store.IndexInput)">
            <summary> Construct a new SegmentInfo instance by reading a
            previously saved SegmentInfo from input.
            
            </summary>
            <param name="dir">directory to load from
            </param>
            <param name="format">format of the segments info file
            </param>
            <param name="input">input handle to read segment info from
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.SizeInBytes">
            <summary>Returns total size in bytes of all of files used by
            this segment. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfo.HasSeparateNorms(System.Int32)" -->
        <member name="M:Lucene.Net.Index.SegmentInfo.HasSeparateNorms">
            <summary> Returns true if any fields in this segment have separate norms.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.AdvanceNormGen(System.Int32)">
            <summary> Increment the generation count for the norms file for
            this field.
            
            </summary>
            <param name="fieldIndex">field whose norm file will be rewritten
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.GetNormFileName(System.Int32)">
            <summary> Get the file name for the norms file for this field.
            
            </summary>
            <param name="number">field index
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.SetUseCompoundFile(System.Boolean)">
            <summary> Mark whether this segment is stored as a compound file.
            
            </summary>
            <param name="isCompoundFile">true if this is a compound file;
            else, false
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.GetUseCompoundFile">
            <summary> Returns true if this segment is stored as a compound
            file; else, false.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.Write(Lucene.Net.Store.IndexOutput)">
            <summary> Save this segment's info.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.SegString(Lucene.Net.Store.Directory)">
            <summary>Used for debugging </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.Equals(System.Object)">
            <summary>We consider another SegmentInfo instance equal if it
            has the same dir and same name. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.Payload" -->
        <member name="F:Lucene.Net.Index.Payload.data">
            <summary>the byte array containing the payload data </summary>
        </member>
        <member name="F:Lucene.Net.Index.Payload.offset">
            <summary>the offset within the byte array </summary>
        </member>
        <member name="F:Lucene.Net.Index.Payload.length">
            <summary>the length of the payload data </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.#ctor">
            <summary>Creates an empty payload and does not allocate a byte array. </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.#ctor(System.Byte[])">
            <summary> Creates a new payload with the the given array as data.
            A reference to the passed-in array is held, i. e. no 
            copy is made.
            
            </summary>
            <param name="data">the data of this payload
            </param>
        </member>
        <member name="M:Lucene.Net.Index.Payload.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary> Creates a new payload with the the given array as data. 
            A reference to the passed-in array is held, i. e. no 
            copy is made.
            
            </summary>
            <param name="data">the data of this payload
            </param>
            <param name="offset">the offset in the data byte array
            </param>
            <param name="length">the length of the data
            </param>
        </member>
        <member name="M:Lucene.Net.Index.Payload.SetData(System.Byte[])">
            <summary> Sets this payloads data. 
            A reference to the passed-in array is held, i. e. no 
            copy is made.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary> Sets this payloads data. 
            A reference to the passed-in array is held, i. e. no 
            copy is made.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.GetData">
            <summary> Returns a reference to the underlying byte array
            that holds this payloads data.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.GetOffset">
            <summary> Returns the offset in the underlying byte array </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.Length">
            <summary> Returns the length of the payload data. </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.ByteAt(System.Int32)">
            <summary> Returns the byte at the given index.</summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.ToByteArray">
            <summary> Allocates a new byte array, copies the payload data into it and returns it. </summary>
        </member>
        <member name="M:Lucene.Net.Index.Payload.CopyTo(System.Byte[],System.Int32)">
            <summary> Copies the payload data to a byte array.
            
            </summary>
            <param name="target">the target byte array
            </param>
            <param name="targetOffset">the offset in the target byte array
            </param>
        </member>
        <member name="M:Lucene.Net.Index.Payload.Clone">
            <summary> Clones this payload by creating a copy of the underlying
            byte array.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldReaderException">
            <summary> 
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldReaderException.#ctor">
            <summary> Constructs a new runtime exception with <code>null</code> as its
            detail message.  The cause is not initialized, and may subsequently be
            initialized by a call to {@link #initCause}.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.FieldReaderException.#ctor(System.Exception)" -->
        <member name="M:Lucene.Net.Index.FieldReaderException.#ctor(System.String)">
            <summary> Constructs a new runtime exception with the specified detail message.
            The cause is not initialized, and may subsequently be initialized by a
            call to {@link #initCause}.
            
            </summary>
            <param name="message">the detail message. The detail message is saved for
            later retrieval by the {@link #getMessage()} method.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.FieldReaderException.#ctor(System.String,System.Exception)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.Token" -->
        <member name="F:Lucene.Net.Analysis.Token.termText">
            <deprecated>
            We will remove this when we remove the deprecated APIs. 
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Analysis.Token.termBuffer">
            <summary>
            Characters for the term text.
            </summary>
            <deprecated>
            This will be made private.  Instead, use:
            {@link #setTermBuffer(char[], int, int)},
            {@link #setTermBuffer(String)}, or
            {@link #setTermBuffer(String, int, int)},
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Analysis.Token.termLength">
            <summary>
            Length of term text in the buffer.
            </summary>
            <deprecated>
            This will be made private.  Instead, use:
            {@link termLength()} or {@link setTermLength(int)}
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Analysis.Token.startOffset">
            <summary>
            Start in source text.
            </summary>
            <deprecated>
            This will be made private.  Instead, use:
            {@link startOffset()} or {@link setStartOffset(int)}
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Analysis.Token.endOffset">
            <summary>
            End in source text.
            </summary>
            <deprecated>
            This will be made private.  Instead, use:
            {@link endOffset()} or {@link setEndOffset(int)}
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Analysis.Token.type">
            <summary>
            The lexical type of the token.
            </summary>
            <deprecated>
            This will be made private.  Instead, use:
            {@link type()} or {@link setType(String)}
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Analysis.Token.payload">
            <deprecated>
            This will be made private. Instead, use:
            {@link getPayload()} or {@link setPayload(Payload)}.
            </deprecated>
        </member>
        <member name="F:Lucene.Net.Analysis.Token.positionIncrement">
            <deprecated>
            This will be made private. Instead, use:
            {@link getPositionIncrement()} or {@link setPositionIncrement(String)}.
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor">
            <summary>Constructs a Token will null text. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.Int32,System.Int32,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.#ctor(System.Int32,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Constructs a Token with the given term text, and start
            and end offsets.  The type defaults to "word."
            <b>NOTE:</b> for better indexing speed you should
            instead use the char[] termBuffer methods to set the
            term text.
            </summary>
            <param name="text">term text</param>
            <param name="start">start offset</param>
            <param name="end">end offset</param>
            <deprecated></deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Constructs a Token with the given term text, start
            and end offsets, and type.
            <b>NOTE:</b> for better indexing speed you should
            instead use the char[] termBuffer methods to set the
            term text.
            </summary>
            <param name="text">term text</param>
            <param name="start">start offset</param>
            <param name="end">end offset</param>
            <param name="typ">token type</param>
            <deprecated></deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a Token with the given term text, start
            and end offsets, and flags.
            <b>NOTE:</b> for better indexing speed you should
            instead use the char[] termBuffer methods to set the
            term text.
            </summary>
            <param name="text">term text</param>
            <param name="start">start offset</param>
            <param name="end">end offset</param>
            <param name="flags">the bits to set for this Token</param>
            <deprecated></deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a Token with the given term buffer (offset and length), start and end offsets.
            </summary>
            <param name="startTermBuffer"></param>
            <param name="termBufferOffset"></param>
            <param name="termBufferLength"></param>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.SetPositionIncrement(System.Int32)" -->
        <member name="M:Lucene.Net.Analysis.Token.GetPositionIncrement">
            <summary>Returns the position increment of this Token.</summary>
            <seealso cref="!:setPositionIncrement">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetTermText(System.String)">
            <summary>Sets the Token's term text.  <b>NOTE:</b> for better
            indexing speed you should instead use the char[]
            termBuffer methods to set the term text. 
            </summary>
            <deprecated>
            use {@link #setTermBuffer(char[], int, int)}, 
                {@link #setTermBuffer(string)}, or
                {@link #setTermBuffer(string, int, int)}.
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.TermText">
            <summary>
            Returns the Token's term text.
            This method has a performance penalty because the text is stored
            internally in a char[].  If possible, use {@link #termBuffer()}
            and {@link #termLength()} directly instead.  If you really need
            a string, use {@link #Term()}.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Term">
            <summary>
            Returns the Token's term text.
            This method has a performance penalty because the text is stored
            internally in a char[].  If possible, use {@link #termBuffer()}
            and {@link #termLength()} directly instead.  If you really need
            a string, use this method which is nothing more than a
            convenience cal to <b>new String(token.TermBuffer(), o, token.TermLength())</b>.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetTermBuffer(System.Char[],System.Int32,System.Int32)">
            <summary>
            Copies the contents of buffer, starting at offset for
            length characters, into the termBuffer array.
            </summary>
            <param name="buffer"/>
            <param name="offset"/>
            <param name="length"/>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetTermBuffer(System.String)">
            <summary>
            Copies the contents of buffer, starting at offset for
            length characters, into the termBuffer array.
            </summary>
            <param name="buffer"/>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetTermBuffer(System.String,System.Int32,System.Int32)">
            <summary>
            Copies the contents of buffer, starting at offset for
            length characters, into the termBuffer array.
            </summary>
            <param name="buffer"/>
            <param name="offset"/>
            <param name="length"/>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.TermBuffer">
            <summary>Returns the internal termBuffer character array which
            you can then directly alter.  If the array is too
            small for your token, use {@link
            #ResizeTermBuffer(int)} to increase it.  After
            altering the buffer be sure to call {@link
            #setTermLength} to record the number of valid
            characters that were placed into the termBuffer. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.ResizeTermBuffer(System.Int32)">
            <summary>
            Grows the termBuffer to at least size newSize, preserving the
            existing content.  Note: If the next operation is to change
            the contents of the term buffer use
            {@link #setTermBuffer(char[], int, int)},
            {@link #setTermBuffer(String)}, or
            {@link #setTermBuffer(String, int, int)},
            to optimally combine the resize with the setting of the termBuffer.
            </summary>
            <param name="newSize">minimum size of the new termBuffer</param>
            <returns> newly created termBuffer with length >= newSize</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.GrowTermBuffer(System.Int32)">
            <summary>
            Allocates a buffer char[] of at least newSize.
            </summary>
            <param name="newSize">minimum size of the buffer</param>
            <returns>newly created buffer with length >= newSize or null if the current termBuffer is big enough</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.TermLength">
            <summary>Return number of valid characters (length of the term)
            in the termBuffer array. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetTermLength(System.Int32)">
            <summary>Set number of valid characters (length of the term) in
            the termBuffer array.  Use this to truncate the termBuffer
            or to synchronize with external manipulation of the termBuffer.
            Note: to grow the size of the array use {@link #resizeTermBuffer(int)} first.
            </summary>
            <param name="length">the truncated length</param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.StartOffset">
            <summary>Returns this Token's starting offset, the position of the first character
            corresponding to this token in the source text.
            Note that the difference between endOffset() and startOffset() may not be
            equal to termText.length(), as the term text may have been altered by a
            stemmer or some other filter. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetStartOffset(System.Int32)">
            <summary>Set the starting offset.</summary>
            <seealso cref="M:Lucene.Net.Analysis.Token.StartOffset">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.EndOffset">
            <summary>Returns this Token's ending offset, one greater than the position of the
            last character corresponding to this token in the source text.  The length of the
            token in the source text is (endOffset - startOffset).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetEndOffset(System.Int32)">
            <summary>Set the ending offset.</summary>
            <seealso cref="M:Lucene.Net.Analysis.Token.EndOffset">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Type">
            <summary>Returns this Token's lexical type.  Defaults to "word". </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetType(System.String)">
            <summary>Set the lexical type.</summary>
            <seealso cref="M:Lucene.Net.Analysis.Token.Type">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.GetFlags">
            
             <summary>
             EXPERIMENTAL:  While we think this is here to stay, we may want to change it to be a long.
             Get the bitset for any bits that have been set.  This is completely distinct from {@link #type()}, although they do share similar purposes.
             The flags can be used to encode information about the token for use by other {@link org.apache.lucene.analysis.TokenFilter}s.
             </summary>
             <returns>The bits</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetFlags(System.Int32)">
            
             <seealso cref="M:Lucene.Net.Analysis.Token.GetFlags"/>
            
        </member>
        <member name="M:Lucene.Net.Analysis.Token.GetPayload">
            <summary> Returns this Token's payload.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetPayload(Lucene.Net.Index.Payload)">
            <summary> Sets this Token's payload.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Clear">
            <summary>Resets the term text, payload, and positionIncrement to default.
            Other fields such as startOffset, endOffset and the token type are
            not reset since they are normally overwritten by the tokenizer. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Token.Clone(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            Shorthand for calling {@link #clear},
            {@link #setTermBuffer(char[], int, int)},
            {@link #setStartOffset},
            {@link #setEndOffset},
            {@link #setType}
            @return this Token instance 
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            Shorthand for calling {@link #clear},
            {@link #SetTermBuffer(char[], int, int)},
            {@link #setStartOffset},
            {@link #setEndOffset}
            {@link #setType} on Token.DEFAULT_TYPE
            @return this Token instance 
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32,System.String)">
            Shorthand for calling {@link #clear},
            {@link #SetTermBuffer(String)},
            {@link #setStartOffset},
            {@link #setEndOffset}
            {@link #setType}
            @return this Token instance 
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            Shorthand for calling {@link #clear},
            {@link #SetTermBuffer(String, int, int)},
            {@link #setStartOffset},
            {@link #setEndOffset}
            {@link #setType}
            @return this Token instance 
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32)">
            Shorthand for calling {@link #clear},
            {@link #SetTermBuffer(String)},
            {@link #setStartOffset},
            {@link #setEndOffset}
            {@link #setType} on Token.DEFAULT_TYPE
            @return this Token instance 
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            Shorthand for calling {@link #clear},
            {@link #SetTermBuffer(String, int, int)},
            {@link #setStartOffset},
            {@link #setEndOffset}
            {@link #setType} on Token.DEFAULT_TYPE
            @return this Token instance 
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(Lucene.Net.Analysis.Token)">
            Copy the prototype token's fields into this one. Note: Payloads are shared.
            @param prototype
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(Lucene.Net.Analysis.Token,System.String)">
            Copy the prototype token's fields into this one, with a different term. Note: Payloads are shared.
            @param prototype
            @param newTerm
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(Lucene.Net.Analysis.Token,System.Char[],System.Int32,System.Int32)">
            Copy the prototype token's fields into this one, with a different term. Note: Payloads are shared.
            @param prototype
            @param newTermBuffer
            @param offset
            @param length
        </member>
        <member name="T:Lucene.Net.Analysis.Standard.StandardFilter">
            <summary>Normalizes tokens extracted with {@link StandardTokenizer}. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.TokenFilter" -->
        <member name="F:Lucene.Net.Analysis.TokenFilter.input">
            <summary>The source of tokens for this filter. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.#ctor(Lucene.Net.Analysis.TokenStream)">
            <summary>Construct a token stream filtering the given input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.Close">
            <summary>Close the input TokenStream. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.Reset">
            <summary>
            Reset the filter as well as the input TokenStream.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Standard.StandardFilter.#ctor(Lucene.Net.Analysis.TokenStream)">
            <summary>Construct filtering <i>in</i>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.Standard.StandardFilter.Next(Lucene.Net.Analysis.Token)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.LowerCaseTokenizer" -->
        <member name="T:Lucene.Net.Analysis.LetterTokenizer">
            <summary>A LetterTokenizer is a tokenizer that divides text at non-letters.  That's
            to say, it defines tokens as maximal strings of adjacent letters, as defined
            by java.lang.Character.isLetter() predicate.
            Note: this does a decent job for most European languages, but does a terrible
            job for some Asian languages, where words are not separated by spaces. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.CharTokenizer">
            <summary>An abstract base class for simple, character-oriented tokenizers.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharTokenizer.IsTokenChar(System.Char)">
            <summary>Returns true iff a character should be included in a token.  This
            tokenizer generates as tokens adjacent sequences of characters which
            satisfy this predicate.  Characters for which this is false are used to
            define token boundaries and are not included in tokens. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharTokenizer.Normalize(System.Char)">
            <summary>Called on each token character to normalize it before it is added to the
            token.  The default implementation does nothing.  Subclasses may use this
            to, e.g., lowercase tokens. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LetterTokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a new LetterTokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LetterTokenizer.IsTokenChar(System.Char)">
            <summary>Collects only characters which satisfy
            {@link Character#isLetter(char)}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LowerCaseTokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a new LowerCaseTokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LowerCaseTokenizer.Normalize(System.Char)">
            <summary>Collects only characters which satisfy
            {@link Character#isLetter(char)}.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Cache.Cache">
            Base class for cache implementations.
        </member>
        <member name="M:Lucene.Net.Util.Cache.Cache.SynchronizedCache_Renamed(Lucene.Net.Util.Cache.Cache)">
            Returns a thread-safe cache backed by the specified cache. 
            In order to guarantee thread-safety, all access to the backed cache must
            be accomplished through the returned cache.
        </member>
        <member name="M:Lucene.Net.Util.Cache.Cache.Put(System.Object,System.Object)">
            Puts a (key, value)-pair into the cache. 
        </member>
        <member name="M:Lucene.Net.Util.Cache.Cache.Get(System.Object)">
            Returns the value for the given key. 
        </member>
        <member name="M:Lucene.Net.Util.Cache.Cache.ContainsKey(System.Object)">
            Returns whether the given key is in this cache. 
        </member>
        <member name="M:Lucene.Net.Util.Cache.Cache.Close">
            Closes the cache.
        </member>
        <member name="M:Lucene.Net.Util.Cache.Cache.GetSynchronizedCache">
            Called by {@link #synchronizedCache(Cache)}. This method
            returns a {@link SynchronizedCache} instance that wraps
            this instance by default and can be overridden to return
            e. g. subclasses of {@link SynchronizedCache} or this
            in case this cache is already synchronized.
        </member>
        <member name="T:Lucene.Net.Util.Cache.Cache.SynchronizedCache">
            Simple Cache wrapper that synchronizes all
            calls that access the cache. 
        </member>
        <member name="T:NIOFSDirectory">
             * NIO version of FSDirectory.  Uses FileChannel.read(ByteBuffer dst, long position) method
             * which allows multiple threads to read from the file without synchronizing.  FSDirectory
             * synchronizes in the FSIndexInput.readInternal method which can cause pileups when there
             * are many threads accessing the Directory concurrently.  
             *
             * This class only uses FileChannel when reading; writing
             * with an IndexOutput is inherited from FSDirectory.
             * 
             * Note: NIOFSDirectory is not recommended on Windows because of a bug
             * in how FileChannel.read is implemented in Sun's JRE.
             * Inside of the implementation the position is apparently
             * synchronized.  See here for details:
            
             * http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6265734 
             * 
             * @see FSDirectory
        </member>
        <member name="T:Lucene.Net.Store.FSDirectory">
            <summary> Straightforward implementation of {@link Directory} as a directory of files.
            Locking implementation is by default the {@link SimpleFSLockFactory}, but
            can be changed either by passing in a {@link LockFactory} instance to
            <code>getDirectory</code>, or specifying the LockFactory class by setting
            <code>Lucene.Net.Store.FSDirectoryLockFactoryClass</code> Java system
            property, or by calling {@link #setLockFactory} after creating
            the Directory.
            <p>Directories are cached, so that, for a given canonical
            path, the same FSDirectory instance will always be
            returned by <code>getDirectory</code>.  This permits
            synchronization on directories.</p>
            
            </summary>
            <seealso cref="T:Lucene.Net.Store.Directory">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.Directory" -->
        <member name="F:Lucene.Net.Store.Directory.lockFactory">
            <summary>Holds the LockFactory instance (implements locking for
            this Directory instance). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.List">
            <summary>Returns an array of strings, one for each file in the
            directory.  This method may return null (for example for
            {@link FSDirectory} if the underlying directory doesn't
            exist in the filesystem or there are permissions
            problems).
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileExists(System.String)">
            <summary>Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileModified(System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.TouchFile(System.String)">
            <summary>Set the modified time of an existing file to now. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.DeleteFile(System.String)">
            <summary>Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.RenameFile(System.String,System.String)">
            <summary>Renames an existing file in the directory.
            If a file already exists with the new name, then it is replaced.
            This replacement is not guaranteed to be atomic.
            </summary>
            <deprecated> 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileLength(System.String)">
            <summary>Returns the length of a file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.CreateOutput(System.String)">
            <summary>Creates a new, empty file in the directory with the given name.
            Returns a stream writing this file. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Sync(System.String)">
            <summary>
            Ensure that any writes to the file are moved to
            stable storage.  Lucene uses this to properly commit
            chages to the index, to prevent a machine/OS crash
            from corrupting the index.
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.OpenInput(System.String)">
            <summary>Returns a stream reading an existing file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.OpenInput(System.String,System.Int32)">
            <summary>Returns a stream reading an existing file, with the
            specified read buffer size.  The particular Directory
            implementation may ignore the buffer size.  Currently
            the only Directory implementations that respect this
            parameter are {@link FSDirectory} and {@link
            Lucene.Net.Index.CompoundFileReader}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.MakeLock(System.String)">
            <summary>Construct a {@link Lock}.</summary>
            <param name="name">the name of the lock file
            </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.ClearLock(System.String)">
            <summary> Attempt to clear (forcefully unlock and remove) the
            specified lock.  Only call this at a time when you are
            certain this lock is no longer in use.
            </summary>
            <param name="name">name of the lock to be cleared.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Close">
            <summary>Closes the store. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.SetLockFactory(Lucene.Net.Store.LockFactory)">
            <summary> Set the LockFactory that this Directory instance should
            use for its locking implementation.  Each * instance of
            LockFactory should only be used for one directory (ie,
            do not share a single instance across multiple
            Directories).
            
            </summary>
            <param name="lockFactory">instance of {@link LockFactory}.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.GetLockFactory">
            <summary> Get the LockFactory that this Directory instance is
            using for its locking implementation.  Note that this
            may be null for Directory implementations that provide
            their own locking implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.GetLockID">
            <summary> Return a string identifier that uniquely differentiates
            this Directory instance from other Directory instances.
            This ID should be the same if two Directory instances
            (even in different JVMs and/or on different machines)
            are considered "the same index".  This is how locking
            "scopes" to the right index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Copy(Lucene.Net.Store.Directory,Lucene.Net.Store.Directory,System.Boolean)">
            <summary> Copy contents of a directory src to a directory dest.
            If a file in src already exists in dest then the
            one in dest will be blindly overwritten.
            
            </summary>
            <param name="src">source directory
            </param>
            <param name="dest">destination directory
            </param>
            <param name="closeDirSrc">if <code>true</code>, call {@link #close()} method on source directory
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Store.Directory.EnsureOpen">
            <summary>
            Throws AlreadyClosedException if this Directory is closed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.DIRECTORIES">
            <summary>This cache of directories ensures that there is a unique Directory
            instance per path, so that synchronization on the Directory can be used to
            synchronize access between readers and writers.  We use
            refcounts to ensure when the last use of an FSDirectory
            instance for a given canonical path is closed, we remove the
            instance from the cache.  See LUCENE-776
            for some relevant discussion.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.SetDisableLocks(System.Boolean)">
            <summary> Set whether Lucene's use of lock files is disabled. By default, 
            lock files are enabled. They should only be disabled if the index
            is on a read-only medium like a CD-ROM.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.GetDisableLocks">
            <summary> Returns whether Lucene's use of lock files is disabled.</summary>
            <returns> true if locks are disabled, false if locks are enabled.
            </returns>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.IMPL">
            <summary>The default class which implements filesystem-based directories. </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.buffer">
            <summary>A buffer optionally used in renameTo method </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.GetDirectory(System.String)">
            <summary>Returns the directory instance for the named location.</summary>
            <param name="path">the path to the directory.
            </param>
            <returns> the FSDirectory for the named file.  
            </returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.GetDirectory(System.String,Lucene.Net.Store.LockFactory)">
            <summary>Returns the directory instance for the named location.</summary>
            <param name="path">the path to the directory.
            </param>
            <param name="lockFactory">instance of {@link LockFactory} providing the
            locking implementation.
            </param>
            <returns> the FSDirectory for the named file.  
            </returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.GetDirectory(System.IO.FileInfo)">
            <summary>Returns the directory instance for the named location.</summary>
            <param name="file">the path to the directory.
            </param>
            <returns> the FSDirectory for the named file.  
            </returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.GetDirectory(System.IO.FileInfo,Lucene.Net.Store.LockFactory)">
            <summary>Returns the directory instance for the named location.</summary>
            <param name="file">the path to the directory.
            </param>
            <param name="lockFactory">instance of {@link LockFactory} providing the
            locking implementation.
            </param>
            <returns> the FSDirectory for the named file.  
            </returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.GetDirectory(System.String,System.Boolean)">
            <summary>Returns the directory instance for the named location.
            
            </summary>
            <deprecated> Use IndexWriter's create flag, instead, to
            create a new index.
            
            </deprecated>
            <param name="path">the path to the directory.
            </param>
            <param name="create">if true, create, or erase any existing contents.
            </param>
            <returns> the FSDirectory for the named file.  
            </returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.GetDirectory(System.IO.FileInfo,System.Boolean)">
            <summary>Returns the directory instance for the named location.
            
            </summary>
            <deprecated> Use IndexWriter's create flag, instead, to
            create a new index.
            
            </deprecated>
            <param name="file">the path to the directory.
            </param>
            <param name="create">if true, create, or erase any existing contents.
            </param>
            <returns> the FSDirectory for the named file.  
            </returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.List">
            <summary>Returns an array of strings, one for each Lucene index file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileExists(System.String)">
            <summary>Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileModified(System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileModified(System.IO.FileInfo,System.String)">
            <summary>Returns the time the named file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.TouchFile(System.String)">
            <summary>Set the modified time of an existing file to now. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileLength(System.String)">
            <summary>Returns the length in bytes of a file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.DeleteFile(System.String)">
            <summary>Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.RenameFile(System.String,System.String)">
            <summary>Renames an existing file in the directory. 
            Warning: This is not atomic.
            </summary>
            <deprecated> 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.CreateOutput(System.String)">
            <summary>Creates a new, empty file in the directory with the given name.
            Returns a stream writing this file. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.HEX_DIGITS">
            <summary> So we can do some byte-to-hexchar conversion below</summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.Close">
            <summary>Closes the store to future operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.ToString">
            <summary>For debug output. </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedIndexInput">
            <summary>Base implementation class for buffered {@link IndexInput}. </summary>
        </member>
        <member name="F:Lucene.Net.Store.BufferedIndexInput.BUFFER_SIZE">
            <summary>Default buffer size </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.#ctor(System.Int32)">
            <summary>Inits BufferedIndexInput with a specific bufferSize </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.SetBufferSize(System.Int32)">
            <summary>Change the buffer size used by this IndexInput </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.GetBufferSize">
            <seealso cref="!:setBufferSize">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>Expert: implements buffer refill.  Reads bytes from the current position
            in the input.
            </summary>
            <param name="b">the array to read bytes into
            </param>
            <param name="offset">the offset in the array to start storing bytes
            </param>
            <param name="length">the number of bytes to read
            </param>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.SeekInternal(System.Int64)">
            <summary>Expert: implements seek.  Sets current position in this file, where the
            next {@link #ReadInternal(byte[],int,int)} will occur.
            </summary>
            <seealso cref="M:Lucene.Net.Store.BufferedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>IndexInput methods </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexInput.IsFDValid">
            <summary>Method used for testing. Returns true if the underlying
            file descriptor is valid.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexOutput.FlushBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>output methods: </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexOutput.Seek(System.Int64)">
            <summary>Random-access methods </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.LockStressTest" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Sort" -->
        <member name="F:Lucene.Net.Search.Sort.RELEVANCE">
            <summary> Represents sorting by computed relevance. Using this sort criteria returns
            the same results as calling
            {@link Searcher#Search(Query) Searcher#search()}without a sort criteria,
            only with slightly more overhead.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Sort.INDEXORDER">
            <summary>Represents sorting by index order. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor">
            <summary> Sorts by computed relevance. This is the same sort criteria as calling
            {@link Searcher#Search(Query) Searcher#search()}without a sort criteria,
            only with slightly more overhead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(System.String)">
            <summary> Sorts by the terms in <code>field</code> then by index order (document
            number). The type of value in <code>field</code> is determined
            automatically.
            
            </summary>
            <seealso cref="!:SortField#AUTO">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(System.String,System.Boolean)">
            <summary> Sorts possibly in reverse by the terms in <code>field</code> then by
            index order (document number). The type of value in <code>field</code> is
            determined automatically.
            
            </summary>
            <seealso cref="!:SortField#AUTO">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(System.String[])">
            <summary> Sorts in succession by the terms in each field. The type of value in
            <code>field</code> is determined automatically.
            
            </summary>
            <seealso cref="!:SortField#AUTO">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(Lucene.Net.Search.SortField)">
            <summary>Sorts by the criteria in the given SortField. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(Lucene.Net.Search.SortField[])">
            <summary>Sorts in succession by the criteria in each SortField. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(System.String)">
            <summary> Sets the sort to the terms in <code>field</code> then by index order
            (document number).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(System.String,System.Boolean)">
            <summary> Sets the sort to the terms in <code>field</code> possibly in reverse,
            then by index order (document number).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(System.String[])">
            <summary>Sets the sort to the terms in each field in succession. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(Lucene.Net.Search.SortField)">
            <summary>Sets the sort to the given criteria. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(Lucene.Net.Search.SortField[])">
            <summary>Sets the sort to the given criteria in succession. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.GetSort">
            <summary> Representation of the sort criteria.</summary>
            <returns> Array of SortField objects used in this sort criteria
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.PhraseScorer" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.PhraseScorer.PhraseFreq" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SloppyPhraseScorer.PhraseFreq" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SloppyPhraseScorer.InitPhrasePositions" -->
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.TermPositionsDiffer(Lucene.Net.Search.PhrasePositions)">
            <summary>
            We disallow two PPs having the same TermPosition, thereby verifying multiple occurrences
            in the query of the same word would go elsewhere in the matched doc.
            </summary>
            <param name="pp"></param>
            <returns>null if differ (i.e., valid) otherwise return the higher offset PhrasePositions
            our of the first two PPs found to not differ</returns>
        </member>
        <member name="T:Lucene.Net.Search.QueryTermVector">
            <summary> 
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.QueryTermVector.#ctor(System.String[])">
            <summary> </summary>
            <param name="queryTerms">The original list of terms from the query, can contain duplicates
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FilteredTermEnum" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermEnum" -->
        <member name="M:Lucene.Net.Index.TermEnum.Next">
            <summary>Increments the enumeration to the next element.  True if one exists.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermEnum.Term">
            <summary>Returns the current Term in the enumeration.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermEnum.DocFreq">
            <summary>Returns the docFreq of the current Term in the enumeration.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermEnum.Close">
            <summary>Closes the enumeration to further activity, freeing resources. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermEnum.SkipTo(Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Search.FilteredTermEnum.TermCompare(Lucene.Net.Index.Term)">
            <summary>Equality compare on the term </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Difference">
            <summary>Equality measure on the term </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.EndEnum">
            <summary>Indicates the end of the enumeration has been reached </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.DocFreq">
            <summary> Returns the docFreq of the current Term in the enumeration.
            Returns -1 if no Term matches or all terms have been enumerated.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Next">
            <summary>Increments the enumeration to the next element.  True if one exists. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Term">
            <summary>Returns the current Term in the enumeration.
            Returns null if no Term matches or all terms have been enumerated. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredTermEnum.Close">
            <summary>Closes the enumeration to further activity, freeing resources.  </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanScorer.BucketTable">
            <summary>A simple hash table of document scores within a range. </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery">
            <summary>A Query that matches documents matching boolean combinations of other
            queries, e.g. {@link TermQuery}s, {@link PhraseQuery}s or other
            BooleanQuerys.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetMaxClauseCount">
            <summary>Return the maximum number of clauses permitted, 1024 by default.
            Attempts to add more than the permitted number of clauses cause {@link
            TooManyClauses} to be thrown.
            </summary>
            <seealso cref="!:#SetMaxClauseCount(int)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanQuery.SetMaxClauseCount(System.Int32)" -->
        <member name="M:Lucene.Net.Search.BooleanQuery.#ctor">
            <summary>Constructs an empty boolean query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.#ctor(System.Boolean)">
            <summary>Constructs an empty boolean query.
            
            {@link Similarity#Coord(int,int)} may be disabled in scoring, as
            appropriate. For example, this score factor does not make sense for most
            automatically generated queries, like {@link WildcardQuery} and {@link
            FuzzyQuery}.
            
            </summary>
            <param name="disableCoord">disables {@link Similarity#Coord(int,int)} in scoring.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.IsCoordDisabled">
            <summary>Returns true iff {@link Similarity#Coord(int,int)} is disabled in
            scoring for this query instance.
            </summary>
            <seealso cref="!:#BooleanQuery(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.SetMinimumNumberShouldMatch(System.Int32)">
            <summary> Specifies a minimum number of the optional BooleanClauses
            which must be satisfied.
            
            <p>
            By default no optional clauses are necessary for a match
            (unless there are no required clauses).  If this method is used,
            then the specified number of clauses is required.
            </p>
            <p>
            Use of this method is totally independent of specifying that
            any specific clauses are required (or prohibited).  This number will
            only be compared against the number of matching optional clauses.
            </p>
            <p>
            EXPERT NOTE: Using this method may force collecting docs in order,
            regardless of whether setAllowDocsOutOfOrder(true) has been called.
            </p>
            
            </summary>
            <param name="min">the number of optional clauses that must match
            </param>
            <seealso cref="!:setAllowDocsOutOfOrder">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetMinimumNumberShouldMatch">
            <summary> Gets the minimum number of the optional BooleanClauses
            which must be satisifed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.Query,Lucene.Net.Search.BooleanClause.Occur)">
            <summary>Adds a clause to a boolean query.
            
            </summary>
            <throws>  TooManyClauses if the new number of clauses exceeds the maximum clause number </throws>
            <seealso cref="!:#GetMaxClauseCount()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.BooleanClause)">
            <summary>Adds a clause to a boolean query.</summary>
            <throws>  TooManyClauses if the new number of clauses exceeds the maximum clause number </throws>
            <seealso cref="!:#GetMaxClauseCount()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetClauses">
            <summary>Returns the set of clauses in this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Clauses">
            <summary>Returns the list of clauses in this query. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanQuery.allowDocsOutOfOrder">
            <summary>Whether hit docs may be collected out of docid order. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.SetAllowDocsOutOfOrder(System.Boolean)">
            <summary> Expert: Indicates whether hit docs may be collected out of docid
            order.
            
            <p>
            Background: although the contract of the Scorer class requires that
            documents be iterated in order of doc id, this was not true in early
            versions of Lucene.  Many pieces of functionality in the current
            Lucene code base have undefined behavior if this contract is not
            upheld, but in some specific simple cases may be faster.  (For
            example: disjunction queries with less than 32 prohibited clauses;
            This setting has no effect for other queries.)
            </p>
            
            <p>
            Specifics: By setting this option to true, calls to 
            {@link HitCollector#Collect(int,float)} might be
            invoked first for docid N and only later for docid N-1.
            Being static, this setting is system wide.
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetAllowDocsOutOfOrder">
            <summary> Whether hit docs may be collected out of docid order.</summary>
            <seealso cref="!:SetAllowDocsOutOfOrder(boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.SetUseScorer14(System.Boolean)">
            <deprecated> Use {@link #SetAllowDocsOutOfOrder(boolean)} instead. 
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetUseScorer14">
            <deprecated> Use {@link #GetAllowDocsOutOfOrder()} instead.
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.SimilarityDelegator">
            <summary>Expert: Delegating scoring implementation.  Useful in {@link
            Query#GetSimilarity(Searcher)} implementations, to override only certain
            methods of a Searcher's Similiarty implementation.. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarity" -->
        <member name="F:Lucene.Net.Search.Similarity.defaultImpl">
            <summary>The Similarity implementation used by default. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarity.SetDefault(Lucene.Net.Search.Similarity)">
            <summary>Set the default Similarity implementation used by indexing and search
            code.
            
            </summary>
            <seealso cref="!:Searcher#SetSimilarity(Similarity)">
            </seealso>
            <seealso cref="!:IndexWriter#SetSimilarity(Similarity)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.GetDefault" -->
        <member name="F:Lucene.Net.Search.Similarity.NORM_TABLE">
            <summary>Cache of decoded bytes. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarity.DecodeNorm(System.Byte)">
            <summary>Decodes a normalization factor stored in an index.</summary>
            <seealso cref="!:#EncodeNorm(float)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Similarity.GetNormDecoder">
            <summary>Returns a table for decoding normalization bytes.</summary>
            <seealso cref="!:#EncodeNorm(float)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.LengthNorm(System.String,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.QueryNorm(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.EncodeNorm(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Tf(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.SloppyFreq(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Tf(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Idf(Lucene.Net.Index.Term,Lucene.Net.Search.Searcher)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Idf(System.Collections.ICollection,Lucene.Net.Search.Searcher)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Idf(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.Coord(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarity.ScorePayload(System.String,System.Byte[],System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Search.SimilarityDelegator.#ctor(Lucene.Net.Search.Similarity)">
            <summary>Construct a {@link Similarity} that delegates all methods to another.
            
            </summary>
            <param name="delegee">the Similarity implementation to delegate to
            </param>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery.TooManyClauses">
            <summary>Thrown when an attempt is made to add more than {@link
            #GetMaxClauseCount()} clauses. This typically happens if
            a PrefixQuery, FuzzyQuery, WildcardQuery, or RangeQuery 
            is expanded to many terms during search. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.BooleanWeight.Scorer(Lucene.Net.Index.IndexReader)">
            <returns> Returns BooleanScorer2 that uses and provides skipTo(),
            and scores documents in document number order.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.QueryParsers.FastCharStream" -->
        <member name="T:Lucene.Net.QueryParsers.CharStream">
            <summary> This interface describes a character stream that maintains line and
            column number positions of the characters.  It also has the capability
            to backup the stream to some extent.  An implementation of this
            interface is used in the TokenManager implementation generated by
            JavaCCParser.
            
            All the methods except backup can be implemented in any fashion. backup
            needs to be implemented correctly for the correct operation of the lexer.
            Rest of the methods are all used to get information like line number,
            column number and the String that constitutes a token and are not used
            by the lexer. Hence their implementation won't affect the generated lexer's
            operation.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.ReadChar">
            <summary> Returns the next character from the selected input.  The method
            of selecting the input is the responsibility of the class
            implementing this interface.  Can throw any java.io.IOException.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetColumn">
            <summary> Returns the column position of the character last read.</summary>
            <seealso cref="!:#getEndColumn">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetLine">
            <summary> Returns the line number of the character last read.</summary>
            <seealso cref="M:Lucene.Net.QueryParsers.CharStream.GetEndLine">
            </seealso>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetEndColumn">
            <summary> Returns the column number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetEndLine">
            <summary> Returns the line number of the last character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetBeginColumn">
            <summary> Returns the column number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetBeginLine">
            <summary> Returns the line number of the first character for current token (being
            matched after the last call to BeginTOken).
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.Backup(System.Int32)">
            <summary> Backs up the input stream by amount steps. Lexer calls this method if it
            had already read some characters, but could not use them to match a
            (longer) token. So, they will be used again as the prefix of the next
            token and it is the implemetation's responsibility to do this right.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.BeginToken">
            <summary> Returns the next character that marks the beginning of the next token.
            All characters must remain in the buffer between two successive calls
            to this method to implement backup correctly.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetImage">
            <summary> Returns a string made up of characters from the marked token beginning 
            to the current buffer position. Implementations have the choice of returning
            anything that they want to. For example, for efficiency, one might decide
            to just return null, which is a valid implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.GetSuffix(System.Int32)">
            <summary> Returns an array of characters that make up the suffix of length 'len' for
            the currently matched token. This is used to build up the matched string
            for use in actions in the case of MORE. A simple and inefficient
            implementation of this is as follows :
            
            {
            String t = GetImage();
            return t.substring(t.length() - len, t.length()).toCharArray();
            }
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.CharStream.Done">
            <summary> The lexer calls this function to indicate that it is done with the stream
            and hence implementations can free any resources held by this class.
            Again, the body of this function can be just empty and it will not
            affect the lexer's operation.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.FastCharStream.#ctor(System.IO.TextReader)">
            <summary>Constructs from a Reader. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermsHash">
            This class implements {@link InvertedDocConsumer}, which
            is passed each token produced by the analyzer on each
            field.  It stores these tokens in a hash table, and
            allocates separate byte streams per token.  Consumers of
            this class, eg {@link FreqProxTermsWriter} and {@link
            TermVectorsTermsWriter}, write their own byte streams
            under each term.
        </member>
        <member name="M:Lucene.Net.Index.InvertedDocConsumer.addThread(Lucene.Net.Index.DocInverterPerThread)">
            <summary>  Add a new thread </summary>
        </member>
        <member name="M:Lucene.Net.Index.InvertedDocConsumer.abort">
            <summary>  Abort (called after hitting AbortException) </summary>
        </member>
        <member name="M:Lucene.Net.Index.InvertedDocConsumer.flush(System.Collections.Generic.IDictionary{System.Object,System.Collections.Generic.ICollection{System.Object}},Lucene.Net.Index.DocumentsWriter.FlushState)">
            <summary>  Flush a new segment </summary>
        </member>
        <member name="M:Lucene.Net.Index.InvertedDocConsumer.closeDocStore(Lucene.Net.Index.DocumentsWriter.FlushState)">
            <summary>  Close doc stores </summary>
        </member>
        <member name="M:Lucene.Net.Index.InvertedDocConsumer.freeRAM">
            <summary>  Attempt to free RAM, returning true if any RAM was freed </summary>
        </member>
        <member name="T:Lucene.Net.Index.StoredFieldsWriter">
            This is a DocFieldConsumer that writes stored fields. 
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldsWriter.fill(System.Int32)">
            Fills in any hole in the docIDs 
        </member>
        <member name="T:Lucene.Net.Index.DirectoryIndexReader">
            <summary> IndexReader implementation that has access to a Directory. 
            Instances that have a SegmentInfos object (i. e. segmentInfos != null)
            "own" the directory, which means that they try to acquire a write lock
            whenever index modifications are performed.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.IndexReader" -->
        <member name="M:Lucene.Net.Index.IndexReader.IncRef">
            <summary>
            Expert: increments the refCount of this IndexReader
            instance.  RefCounts are used to determine when a
            reader can be closed safely, i.e. as soon as there are
            no more references.  Be sure to always call a
            corresponding {@link #decRef}, in a finally clause;
            otherwise the reader may never be closed.  Note that
            {@link #close} simply calls decRef(), which means that
            the IndexReader will not really be closed until {@link
            #decRef} has been called for all outstanding
            references.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DecRef">
            <summary>
            Expert: decreases the refCount of this IndexReader
            instance.  If the refCount drops to 0, then pending
            changes (if any) are committed to the index and this
            reader is closed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.directory">
            <seealso cref="M:Lucene.Net.Index.IndexReader.Directory"></seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.#ctor(Lucene.Net.Store.Directory)" -->
        <member name="M:Lucene.Net.Index.IndexReader.EnsureOpen">
            <throws>  AlreadyClosedException if this IndexReader is closed </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(System.String)">
            <summary>
            Returns a read/write IndexReader reading the index in an FSDirectory in the named path.
            <para>NOTE: Starting in 3.0 this will return a readOnly IndexReader.</para>
            <para>Throws CorruptIndexException if the index is corrupt.</para>
            <para>Throws IOException if there is a low-level IO error.</para>
            </summary>
            <param name="path">the path to the index directory</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(System.IO.FileInfo)">
            <summary>
            Returns a read/write IndexReader reading the index in an FSDirectory in the named path.
            <para>NOTE: Starting in 3.0 this will return a readOnly IndexReader.</para>
            <para>Throws CorruptIndexException if the index is corrupt.</para>
            <para>Throws IOException if there is a low-level IO error.</para>
            </summary>
            <param name="path">the path to the index directory</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Store.Directory)">
            <summary>
            Returns a read/write IndexReader reading the index in the given Directory.
            <para>NOTE: Starting in 3.0 this will return a readOnly IndexReader.</para>
            <para>Throws CorruptIndexException if the index is corrupt.</para>
            <para>Throws IOException if there is a low-level IO error.</para>
            </summary>
            <param name="directory">the index directory</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Store.Directory,System.Boolean)">
            <summary>
            Returns a read/write or read only IndexReader using the index in the given Directory.
            <para>Throws CorruptIndexException if the index is corrupt.</para>
            <para>Throws IOException if there is a low-level IO error.</para>
            </summary>
            <param name="directory">the index directory</param>
            <param name="readOnly">true if no changes (deletions, norms) will be made with this IndexReader</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Index.IndexCommit)">
            <summary>
            Expert: Returns a read/write IndexReader reading the index in the given IndexCommit.
            <para>NOTE: Starting in 3.0 this will return a readOnly IndexReader.</para>
            <para>Throws CorruptIndexException if the index is corrupt.</para>
            <para>Throws IOException if there is a low-level IO error.</para>
            </summary>
            <param name="commit">the commit point to open</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexDeletionPolicy)">
            <summary>
            Expert: Returns a read/write IndexReader reading the index in the given
            Directory, with a custom IndexDeletionPolicy.
            <para>NOTE: Starting in 3.0 this will return a readOnly IndexReader.</para>
            <para>Throws CorruptIndexException if the index is corrupt.</para>
            <para>Throws IOException if there is a low-level IO error.</para>
            </summary>
            <param name="directory">the index directory</param>
            <param name="deletionPolicy">a custom deletion policy (only used if performing deletes or setting norms)</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexDeletionPolicy,System.Boolean)">
            <summary>
            Expert: Returns a read/write or read only IndexReader using the index in the given
            Directory, with a custom IndexDeletionPolicy.
            <para>Throws CorruptIndexException if the index is corrupt.</para>
            <para>Throws IOException if there is a low-level IO error.</para>
            </summary>
            <param name="directory">the index directory</param>
            <param name="deletionPolicy">a custom deletion policy (only used if performing deletes or setting norms)</param>
            <param name="readOnly">true if no changes (deletions, norms) will be made with this IndexReader</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Index.IndexCommit,Lucene.Net.Index.IndexDeletionPolicy)">
            <summary>
            Expert: Returns a read/write IndexReader reading the index in the given
            Directory, using a specific commit and with a custom IndexDeletionPolicy.
            <para>NOTE: Starting in 3.0 this will return a readOnly IndexReader.</para>
            <para>Throws CorruptIndexException if the index is corrupt.</para>
            <para>Throws IOException if there is a low-level IO error.</para>
            </summary>
            <param name="commit">the commit point to open</param>
            <param name="deletionPolicy">a custom deletion policy (only used if performing deletes or setting norms)</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Index.IndexCommit,Lucene.Net.Index.IndexDeletionPolicy,System.Boolean)">
            <summary>
            Expert: Returns a read/write or read only IndexReader reading the index in the given
            Directory, using a specific commit and with a custom IndexDeletionPolicy.
            <para>NOTE: Starting in 3.0 this will return a readOnly IndexReader.</para>
            <para>Throws CorruptIndexException if the index is corrupt.</para>
            <para>Throws IOException if there is a low-level IO error.</para>
            </summary>
            <param name="commit">the commit point to open</param>
            <param name="deletionPolicy">a custom deletion policy (only used if performing deletes or setting norms)</param>
            <param name="readOnly">true if no changes (deletions, norms) will be made with this IndexReader</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.Reopen" -->
        <member name="M:Lucene.Net.Index.IndexReader.Directory">
            <summary> Returns the directory associated with this index.  The Default 
            implementation returns the directory specified by subclasses when 
            delegating to the IndexReader(Directory) constructor, or throws an 
            UnsupportedOperationException if one was not specified.
            </summary>
            <throws>  UnsupportedOperationException if no directory </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.LastModified(System.String)">
            <summary> Returns the time the index in the named directory was last modified.
            Do not use this to check whether the reader is still up-to-date, use
            {@link #IsCurrent()} instead. 
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.LastModified(System.IO.FileInfo)">
            <summary> Returns the time the index in the named directory was last modified. 
            Do not use this to check whether the reader is still up-to-date, use
            {@link #IsCurrent()} instead. 
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.LastModified(Lucene.Net.Store.Directory)">
            <summary> Returns the time the index in the named directory was last modified. 
            Do not use this to check whether the reader is still up-to-date, use
            {@link #IsCurrent()} instead. 
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetCurrentVersion(System.String)">
            <summary> Reads version number from segments files. The version number is
            initialized with a timestamp and then increased by one for each change of
            the index.
            
            </summary>
            <param name="directory">where the index resides.
            </param>
            <returns> version number.
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetCurrentVersion(System.IO.FileInfo)">
            <summary> Reads version number from segments files. The version number is
            initialized with a timestamp and then increased by one for each change of
            the index.
            
            </summary>
            <param name="directory">where the index resides.
            </param>
            <returns> version number.
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetCurrentVersion(Lucene.Net.Store.Directory)">
            <summary> Reads version number from segments files. The version number is
            initialized with a timestamp and then increased by one for each change of
            the index.
            
            </summary>
            <param name="directory">where the index resides.
            </param>
            <returns> version number.
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetVersion">
            <summary> Version number when this IndexReader was opened. Not implemented in the IndexReader base class.</summary>
            <throws>  UnsupportedOperationException unless overridden in subclass </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.SetTermInfosIndexDivisor(System.Int32)">
            <summary><p>For IndexReader implementations that use
            TermInfosReader to read terms, this sets the
            indexDivisor to subsample the number of indexed terms
            loaded into memory.  This has the same effect as {@link
            IndexWriter#setTermIndexInterval} except that setting
            must be done at indexing time while this setting can be
            set per reader.  When set to N, then one in every
            N*termIndexInterval terms in the index is loaded into
            memory.  By setting this to a value > 1 you can reduce
            memory usage, at the expense of higher latency when
            loading a TermInfo.  The default value is 1.</p>
            
            <b>NOTE:</b> you must call this before the term
            index is loaded.  If the index is already loaded, 
            an IllegalStateException is thrown.
            </summary>
            <throws>  IllegalStateException if the term index has already been loaded into memory </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.GetTermInfosIndexDivisor" -->
        <member name="M:Lucene.Net.Index.IndexReader.IsCurrent">
            <summary> Check whether this IndexReader is still using the
            current (i.e., most recently committed) version of the
            index.  If a writer has committed any changes to the
            index since this reader was opened, this will return
            <code>false</code>, in which case you must open a new
            IndexReader in order to see the changes.  See the
            description of the <a href="IndexWriter.html#autoCommit"><code>autoCommit</code></a>
            flag which controls when the {@link IndexWriter}
            actually commits changes to the index.
            
            <p>
            Not implemented in the IndexReader base class.
            </p>
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
            <throws>  UnsupportedOperationException unless overridden in subclass </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IsOptimized">
            <summary> Checks is the index is optimized (if it has a single segment and 
            no deletions).  Not implemented in the IndexReader base class.
            </summary>
            <returns> <code>true</code> if the index is optimized; <code>false</code> otherwise
            </returns>
            <throws>  UnsupportedOperationException unless overridden in subclass </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermFreqVectors(System.Int32)">
            <summary>  Return an array of term frequency vectors for the specified document.
            The array contains a vector for each vectorized field in the document.
            Each vector contains terms and frequencies for all terms in a given vectorized field.
            If no such fields existed, the method returns null. The term vectors that are
            returned my either be of type TermFreqVector or of type TermPositionsVector if
            positions or offsets have been stored.
            
            </summary>
            <param name="docNumber">document for which term frequency vectors are returned
            </param>
            <returns> array of term frequency vectors. May be null if no term vectors have been
            stored for the specified document.
            </returns>
            <throws>  IOException if index cannot be accessed </throws>
            <seealso cref="T:Lucene.Net.Documents.Field.TermVector">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermFreqVector(System.Int32,System.String)">
            <summary>  Return a term frequency vector for the specified document and field. The
            returned vector contains terms and frequencies for the terms in
            the specified field of this document, if the field had the storeTermVector
            flag set. If termvectors had been stored with positions or offsets, a 
            TermPositionsVector is returned.
            
            </summary>
            <param name="docNumber">document for which the term frequency vector is returned
            </param>
            <param name="field">field for which the term frequency vector is returned.
            </param>
            <returns> term frequency vector May be null if field does not exist in the specified
            document or term vector was not stored.
            </returns>
            <throws>  IOException if index cannot be accessed </throws>
            <seealso cref="T:Lucene.Net.Documents.Field.TermVector">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermFreqVector(System.Int32,System.String,Lucene.Net.Index.TermVectorMapper)">
            <summary> Load the Term Vector into a user-defined data structure instead of relying on the parallel arrays of
            the {@link TermFreqVector}.
            </summary>
            <param name="docNumber">The number of the document to load the vector for
            </param>
            <param name="field">The name of the field to load
            </param>
            <param name="mapper">The {@link TermVectorMapper} to process the vector.  Must not be null
            </param>
            <throws>  IOException if term vectors cannot be accessed or if they do not exist on the field and doc. specified. </throws>
            <summary> 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermFreqVector(System.Int32,Lucene.Net.Index.TermVectorMapper)">
            <summary> Map all the term vectors for all fields in a Document</summary>
            <param name="docNumber">The number of the document to load the vector for
            </param>
            <param name="mapper">The {@link TermVectorMapper} to process the vector.  Must not be null
            </param>
            <throws>  IOException if term vectors cannot be accessed or if they do not exist on the field and doc. specified. </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IndexExists(System.String)">
            <summary> Returns <code>true</code> if an index exists at the specified directory.
            If the directory does not exist or if there is no index in it.
            <code>false</code> is returned.
            </summary>
            <param name="directory">the directory to check for an index
            </param>
            <returns> <code>true</code> if an index exists; <code>false</code> otherwise
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IndexExists(System.IO.FileInfo)">
            <summary> Returns <code>true</code> if an index exists at the specified directory.
            If the directory does not exist or if there is no index in it.
            </summary>
            <param name="directory">the directory to check for an index
            </param>
            <returns> <code>true</code> if an index exists; <code>false</code> otherwise
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IndexExists(Lucene.Net.Store.Directory)">
            <summary> Returns <code>true</code> if an index exists at the specified directory.
            If the directory does not exist or if there is no index in it.
            </summary>
            <param name="directory">the directory to check for an index
            </param>
            <returns> <code>true</code> if an index exists; <code>false</code> otherwise
            </returns>
            <throws>  IOException if there is a problem with accessing the index </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.NumDocs">
            <summary>Returns the number of documents in this index. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.MaxDoc">
            <summary>Returns one greater than the largest possible document number.
            This may be used to, e.g., determine how big to allocate an array which
            will have an element for every document number in an index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.NumDeletedDocs">
            <summary>
            Returns the number of deleted docs.
            </summary>
            <returns>the number of deleted docs</returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Document(System.Int32)">
            <summary>Returns the stored fields of the <code>n</code><sup>th</sup>
            <code>Document</code> in this index.
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Document(System.Int32,Lucene.Net.Documents.FieldSelector)">
            <summary> Get the {@link Lucene.Net.Documents.Document} at the <code>n</code><sup>th</sup> position. The {@link Lucene.Net.Documents.FieldSelector}
            may be used to determine what {@link Lucene.Net.Documents.Field}s to load and how they should be loaded.
            
            <b>NOTE:</b> If this Reader (more specifically, the underlying <code>FieldsReader</code>) is closed before the lazy {@link Lucene.Net.Documents.Field} is
            loaded an exception may be thrown.  If you want the value of a lazy {@link Lucene.Net.Documents.Field} to be available after closing you must
            explicitly load it or fetch the Document again with a new loader.
            
            
            </summary>
            <param name="n">Get the document at the <code>n</code><sup>th</sup> position
            </param>
            <param name="fieldSelector">The {@link Lucene.Net.Documents.FieldSelector} to use to determine what Fields should be loaded on the Document.  May be null, in which case all Fields will be loaded.
            </param>
            <returns> The stored fields of the {@link Lucene.Net.Documents.Document} at the nth position
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
            <summary> 
            </summary>
            <seealso cref="T:Lucene.Net.Documents.Fieldable">
            </seealso>
            <seealso cref="T:Lucene.Net.Documents.FieldSelector">
            </seealso>
            <seealso cref="T:Lucene.Net.Documents.SetBasedFieldSelector">
            </seealso>
            <seealso cref="T:Lucene.Net.Documents.LoadFirstFieldSelector">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IsDeleted(System.Int32)">
            <summary>Returns true if document <i>n</i> has been deleted </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.HasDeletions">
            <summary>Returns true if any documents have been deleted </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.HasNorms(System.String)">
            <summary>Returns true if there are norms stored for this field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Norms(System.String)">
            <summary>Returns the byte-encoded normalization factor for the named field of
            every document.  This is used by the search code to score documents.
            
            </summary>
            <seealso cref="!:Lucene.Net.Documents.Field.SetBoost(float)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Norms(System.String,System.Byte[],System.Int32)">
            <summary>Reads the byte-encoded normalization factor for the named field of every
            document.  This is used by the search code to score documents.
            
            </summary>
            <seealso cref="!:Lucene.Net.Documents.Field.SetBoost(float)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.SetNorm(System.Int32,System.String,System.Byte)">
            <summary>Expert: Resets the normalization factor for the named field of the named
            document.  The norm represents the product of the field's {@link
            Lucene.Net.Documents.Fieldable#SetBoost(float) boost} and its {@link Similarity#LengthNorm(String,
            int) length normalization}.  Thus, to preserve the length normalization
            values when resetting this, one should base the new value upon the old.
            
            </summary>
            <seealso cref="!:Norms(String)">
            </seealso>
            <seealso cref="M:Lucene.Net.Search.Similarity.DecodeNorm(System.Byte)">
            </seealso>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary>  since this reader was opened
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoSetNorm(System.Int32,System.String,System.Byte)">
            <summary>Implements setNorm in subclass.</summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.SetNorm(System.Int32,System.String,System.Single)">
            <summary>Expert: Resets the normalization factor for the named field of the named
            document.
            
            </summary>
            <seealso cref="!:Norms(String)">
            </seealso>
            <seealso cref="M:Lucene.Net.Search.Similarity.DecodeNorm(System.Byte)">
            
            </seealso>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary>  since this reader was opened
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Terms">
            <summary>Returns an enumeration of all the terms in the index. The
            enumeration is ordered by Term.compareTo(). Each term is greater
            than all that precede it in the enumeration. Note that after
            calling terms(), {@link TermEnum#Next()} must be called
            on the resulting enumeration before calling other methods such as
            {@link TermEnum#Term()}.
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Terms(Lucene.Net.Index.Term)">
            <summary>Returns an enumeration of all terms starting at a given term. If
            the given term does not exist, the enumeration is positioned at the
            first term greater than the supplied term. The enumeration is
            ordered by Term.compareTo(). Each term is greater than all that
            precede it in the enumeration.
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DocFreq(Lucene.Net.Index.Term)">
            <summary>Returns the number of documents containing the term <code>t</code>.</summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.TermDocs(Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Index.IndexReader.TermDocs">
            <summary>Returns an unpositioned {@link TermDocs} enumerator.</summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.TermPositions(Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Index.IndexReader.TermPositions">
            <summary>Returns an unpositioned {@link TermPositions} enumerator.</summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DeleteDocument(System.Int32)">
            <summary>Deletes the document numbered <code>docNum</code>.  Once a document is
            deleted it will not appear in TermDocs or TermPostitions enumerations.
            Attempts to read its field with the {@link #document}
            method will result in an error.  The presence of this document may still be
            reflected in the {@link #docFreq} statistic, though
            this will be corrected eventually as the index is further modified.
            
            </summary>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary> since this reader was opened
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoDelete(System.Int32)">
            <summary>Implements deletion of the document numbered <code>docNum</code>.
            Applications should call {@link #DeleteDocument(int)} or {@link #DeleteDocuments(Term)}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DeleteDocuments(Lucene.Net.Index.Term)">
            <summary>Deletes all documents that have a given <code>term</code> indexed.
            This is useful if one uses a document field to hold a unique ID string for
            the document.  Then to delete such a document, one merely constructs a
            term with the appropriate field and the unique ID string as its text and
            passes it to this method.
            See {@link #DeleteDocument(int)} for information about when this deletion will 
            become effective.
            
            </summary>
            <returns> the number of documents deleted
            </returns>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary>  since this reader was opened
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.UndeleteAll">
            <summary>Undeletes all documents currently marked as deleted in this index.
            
            </summary>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary>  since this reader was opened
            </summary>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoUndeleteAll">
            <summary>Implements actual undeleteAll() in subclass. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.AcquireWriteLock">
            <summary>Does nothing by default. Subclasses that require a write lock for
            index modifications must implement this method. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Flush">
            <summary> </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Commit">
            <summary> Commit changes resulting from delete, undeleteAll, or
            setNorm operations
            
            If an exception is hit, then either no changes or all
            changes will have been committed to the index
            (transactional semantics).
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoCommit">
            <summary>Implements commit. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Close">
            <summary> Closes files associated with this index.
            Also saves any new deletions to disk.
            No other methods should be called after this has been called.
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoClose">
            <summary>Implements close. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetFieldNames(Lucene.Net.Index.IndexReader.FieldOption)">
            <summary> Get a list of unique field names that exist in this index and have the specified
            field option information.
            </summary>
            <param name="fldOption">specifies which field option should be available for the returned fields
            </param>
            <returns> Collection of Strings indicating the names of the fields.
            </returns>
            <seealso cref="T:Lucene.Net.Index.IndexReader.FieldOption">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IsLocked(Lucene.Net.Store.Directory)">
            <summary> Returns <code>true</code> iff the index in the named directory is
            currently locked.
            </summary>
            <param name="directory">the directory to check for a lock
            </param>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IsLocked(System.String)">
            <summary> Returns <code>true</code> iff the index in the named directory is
            currently locked.
            </summary>
            <param name="directory">the directory to check for a lock
            </param>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexReader.Unlock(Lucene.Net.Store.Directory)" -->
        <member name="M:Lucene.Net.Index.IndexReader.GetIndexCommit">
            <summary>
            Expert: Return the IndexCommit that this reader has open.  This method is only
            implemented by those readers that correspond to a Directory with its own
            segments_N file.
            <para>
            WARNING: This API is new and experimental and may suddenly change.
            </para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Main(System.String[])">
            <summary> Prints the filename and size of each file within a given compound file.
            Add the -extract flag to extract files to the current working directory.
            In order to make the extracted version of the index work, you have to copy
            the segments file from the compound index into the directory where the extracted files are stored.
            </summary>
            <param name="args">Usage: Lucene.Net.Index.IndexReader [-extract] &lt;cfsfile&gt;
            </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.ListCommits(Lucene.Net.Store.Directory)">
            <summary>
            Returns all commit points that exist in the Directory.
            Normally, because the default is {@link
            KeepOnlyLastCommitDeletionPolicy}, there would be only
            one commit point.  But if you're using a custom {@link
            IndexDeletionPolicy} then there could be many commits.
            Once you have a given commit, you can open a reader on
            it by calling {@link IndexReader#open(IndexCommit)}
            There must be at least one commit in
            the Directory, else this method throws {@link
            java.io.IOException}.  Note that if a commit is in
            progress while this method is running, that commit
            may or may not be returned array.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentInfos.FindSegmentsFile">
            <summary> Utility class for executing code that needs to do
            something with the current segments file.  This is
            necessary with lock-less commits because from the time
            you locate the current segments file name, until you
            actually open it, read its contents, or check modified
            time, etc., it could have been deleted due to a writer
            commit finishing.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT">
            <summary>The file format version, a negative number. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT_LOCKLESS">
            <summary>This format adds details used for lockless commits.  It differs
            slightly from the previous format in that file names
            are never re-used (write once).  Instead, each file is
            written to the next generation.  For example,
            segments_1, segments_2, etc.  This allows us to not use
            a commit lock.  See <a
            href="http://lucene.apache.org/java/docs/fileformats.html">file
            formats</a> for details.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT_SINGLE_NORM_FILE">
            <summary>This format adds a "hasSingleNormFile" flag into each segment info.
            See <a href="http://issues.apache.org/jira/browse/LUCENE-756">LUCENE-756</a>
            for details.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT_SHARED_DOC_STORE">
            <summary>This format allows multiple segments to share a single
            vectors and stored fields file. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT_CHECKSUM">
            <summary> This format adds a checksum at the end of the file to
            ensure all bytes were successfully written.</summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT_DEL_COUNT">
            <summary> This format adds the deletion count for each segment.
            This way IndexWriter can efficiently report numDocs().</summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT_HAS_PROX">
            <summary> This format adds the boolean hasProx to record if any
            fields in the segment store prox information (ie, have
            omitTf==false)</summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.version">
            <summary> counts how often the index has been changed by adding or deleting docs.
            starting with the current time in milliseconds forces to create unique version numbers.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.infoStream">
            <summary> If non-null, information about loading segments_N files</summary>
            <seealso cref="!:setInfoStream.">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetCurrentSegmentGeneration(System.String[])">
            <summary> Get the generation (N) of the current segments_N file
            from a list of files.
            
            </summary>
            <param name="files">-- array of file names to check
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetCurrentSegmentGeneration(Lucene.Net.Store.Directory)">
            <summary> Get the generation (N) of the current segments_N file
            in the directory.
            
            </summary>
            <param name="directory">-- directory to search for the latest segments_N file
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetCurrentSegmentFileName(System.String[])">
            <summary> Get the filename of the current segments_N file
            from a list of files.
            
            </summary>
            <param name="files">-- array of file names to check
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetCurrentSegmentFileName(Lucene.Net.Store.Directory)">
            <summary> Get the filename of the current segments_N file
            in the directory.
            
            </summary>
            <param name="directory">-- directory to search for the latest segments_N file
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetCurrentSegmentFileName">
            <summary> Get the segments_N filename in use by this segment infos.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GenerationFromSegmentsFileName(System.String)">
            <summary> Parse the generation off the segments file name and
            return it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetNextSegmentFileName">
            <summary> Get the next segments_N filename that will be written.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Read(Lucene.Net.Store.Directory,System.String)">
            <summary> Read a particular segmentFileName.  Note that this may
            throw an IOException if a commit is in process.
            
            </summary>
            <param name="directory">-- directory containing the segments file
            </param>
            <param name="segmentFileName">-- segment file to load
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Read(Lucene.Net.Store.Directory)">
            <summary> This version of read uses the retry logic (for lock-less
            commits) to find the right segments file to load.
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Clone">
            <summary> Returns a copy of this instance, also copying each
            SegmentInfo.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetVersion">
            <summary> version number when this SegmentInfos was generated.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.ReadCurrentVersion(Lucene.Net.Store.Directory)">
            <summary> Current version number from segments file.</summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.SetInfoStream(System.IO.StreamWriter)">
            <summary>If non-null, information about retries when loading
            the segments file will be printed to this.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.SetDefaultGenFileRetryCount(System.Int32)">
            <summary> Advanced: set how many times to try loading the
            segments.gen file contents to determine current segment
            generation.  This file is only referenced when the
            primary method (listing the directory) fails.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetDefaultGenFileRetryCount">
            <seealso cref="!:setDefaultGenFileRetryCount">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.SetDefaultGenFileRetryPauseMsec(System.Int32)">
            <summary> Advanced: set how many milliseconds to pause in between
            attempts to load the segments.gen file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetDefaultGenFileRetryPauseMsec">
            <seealso cref="!:setDefaultGenFileRetryPauseMsec">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.SetDefaultGenLookaheadCount(System.Int32)">
            <summary> Advanced: set how many times to try incrementing the
            gen when loading the segments file.  This only runs if
            the primary (listing directory) and secondary (opening
            segments.gen file) methods fail to find the segments
            file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetDefaultGenLookahedCount">
            <seealso cref="!:setDefaultGenLookaheadCount">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetInfoStream">
            <seealso cref="!:setInfoStream">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Range(System.Int32,System.Int32)">
            <summary> Returns a new SegmentInfos containg the SegmentInfo
            instances in the specified range first (inclusive) to
            last (exclusive), so total number of segments returned
            is last-first.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.PrepareCommit(Lucene.Net.Store.Directory)">
            Call this to start a commit.  This writes the new
            segments file, but writes an invalid checksum at the
            end, so that it is not visible to readers.  Once this
            is called you must call {@link #finishCommit} to complete
            the commit or {@link #rollbackCommit} to abort it. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfos.Commit(Lucene.Net.Store.Directory)" -->
        <member name="T:Lucene.Net.Index.SegmentInfos.FindSegmentsFile">
            <summary> Utility class for executing code that needs to do
            something with the current segments file.  This is
            necessary with lock-less commits because from the time
            you locate the current segments file name, until you
            actually open it, read its contents, or check modified
            time, etc., it could have been deleted due to a writer
            commit finishing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.DoBody(System.String)">
            <summary> Subclass must implement this.  The assumption is an
            IOException will be thrown if something goes wrong
            during the processing that could have been caused by
            a writer committing.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexReader.FieldOption">
            <summary> Constants describing field properties, for example used for
            {@link IndexReader#GetFieldNames(FieldOption)}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.ALL">
            <summary>All fields </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.INDEXED">
            <summary>All indexed fields </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.STORES_PAYLOADS">
            <summary>All fields that store payloads </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.OMIT_TF">
            <summary>All fields that store omit tf </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.UNINDEXED">
            <summary>All fields which are not indexed </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.INDEXED_WITH_TERMVECTOR">
            <summary>All fields which are indexed with termvectors enabled </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.INDEXED_NO_TERMVECTOR">
            <summary>All fields which are indexed but don't have termvectors enabled </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.TERMVECTOR">
            <summary>All fields with termvectors enabled. Please note that only standard termvector fields are returned </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.TERMVECTOR_WITH_POSITION">
            <summary>All fields with termvectors with position values enabled </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.TERMVECTOR_WITH_OFFSET">
            <summary>All fields with termvectors with offset values enabled </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexReader.FieldOption.TERMVECTOR_WITH_POSITION_OFFSET">
            <summary>All fields with termvectors with offset values and position values enabled </summary>
        </member>
        <member name="F:Lucene.Net.Index.DirectoryIndexReader.rollbackHasChanges">
            <summary>Used by commit() to record pre-commit state in case
            rollback is necessary 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.DoReopen(Lucene.Net.Index.SegmentInfos)">
            <summary> Re-opens the index using the passed-in SegmentInfos </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.Directory">
            <summary>Returns the directory this index resides in.</summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.GetVersion">
            <summary> Version number when this IndexReader was opened.</summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.IsCurrent">
            <summary> Check whether this IndexReader is still using the
            current (i.e., most recently committed) version of the
            index.  If a writer has committed any changes to the
            index since this reader was opened, this will return
            <code>false</code>, in which case you must open a new
            IndexReader in order to see the changes.  See the
            description of the <a href="IndexWriter.html#autoCommit"><code>autoCommit</code></a>
            flag which controls when the {@link IndexWriter}
            actually commits changes to the index.
            
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.IsOptimized">
            <summary> Checks is the index is optimized (if it has a single segment and no deletions)</summary>
            <returns> <code>true</code> if the index is optimized; <code>false</code> otherwise
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.DoCommit">
            <summary> Commit changes resulting from delete, undeleteAll, or
            setNorm operations
            
            If an exception is hit, then either no changes or all
            changes will have been committed to the index
            (transactional semantics).
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.AcquireWriteLock">
            <summary> Tries to acquire the WriteLock on this directory.
            this method is only valid if this IndexReader is directory owner.
            
            </summary>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary> since this reader was opened
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.StartCommit">
            <summary> Should internally checkpoint state that will change
            during commit so that we can rollback if necessary.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.RollbackCommit">
            <summary> Rolls back state to just before the commit (this is
            called by commit() if there is some exception while
            committing).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.Finalize">
            <summary>Release the write lock, if needed. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.GetIndexCommit">
             Expert: return the IndexCommit that this reader has
             opened.
            
             <p><b>WARNING</b>: this API is new and experimental and
             may suddenly change.</p>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryIndexReader.ListCommits(Lucene.Net.Store.Directory)">
            @see IndexReader#listCommits 
        </member>
        <member name="T:Lucene.Net.Index.IndexCommit">
            <summary>
            Deprecated.  Please subclass Indexcommit class instead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexCommitPoint.GetSegmentsFileName">
            <summary> Get the segments file (<code>segments_N</code>) associated 
            with this commit point.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexCommitPoint.GetFileNames">
            <summary> Returns all index files referenced by this commit point.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexCommitPoint.Delete" -->
        <member name="M:Lucene.Net.Index.IndexCommit.GetSegmentsFileName">
            Get the segments file (<code>segments_N</code>) associated 
            with this commit point.
        </member>
        <member name="M:Lucene.Net.Index.IndexCommit.GetFileNames">
            Returns all index files referenced by this commit point.
        </member>
        <member name="M:Lucene.Net.Index.IndexCommit.GetDirectory">
            Returns the {@link Directory} for the index.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexCommit.Delete" -->
        <member name="M:Lucene.Net.Index.IndexCommit.IsOptimized">
            Returns true if this commit is an optimized index.
        </member>
        <member name="M:Lucene.Net.Index.IndexCommit.Equals(System.Object)">
            Two IndexCommits are equal if both their Directory and versions are equal.
        </member>
        <member name="M:Lucene.Net.Index.IndexCommit.GetVersion">
            Returns the version for this IndexCommit.  This is the
                        same value that {@link IndexReader#getVersion} would
                        return if it were opened on this commit. 
        </member>
        <member name="M:Lucene.Net.Index.IndexCommit.GetGeneration">
            Returns the generation (the _N in segments_N) for this
                        IndexCommit 
        </member>
        <member name="M:Lucene.Net.Index.IndexCommit.GetTimestamp">
            Convenience method that returns the last modified time
            of the segments_N file corresponding to this index
            commit, equivalent to
            getDirectory().fileModified(getSegmentsFileName()). 
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.IncRef">
            <summary> Increments the RC of this reader, as well as
            of all norms this reader is using
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.IncRefReaderNotNorms">
            <summary> only increments the RC of this reader, not tof 
            he norms. This is important whenever a reopen()
            creates a new SegmentReader that doesn't share
            the norms with this one 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentReader.IMPL">
            <summary>The class which implements SegmentReader. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(Lucene.Net.Index.SegmentInfo)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(Lucene.Net.Index.SegmentInfo,System.Boolean)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(Lucene.Net.Index.SegmentInfo,System.Int32)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(Lucene.Net.Index.SegmentInfo,System.Int32,System.Boolean)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(System.Boolean,Lucene.Net.Index.SegmentInfo,System.Int32,System.Boolean)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(System.Boolean,Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.SegmentInfo,System.Boolean)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.SegmentInfos,System.Boolean,System.Boolean,System.Int32)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Get(System.Boolean,Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.SegmentInfos,System.Boolean,System.Boolean,System.Int32,System.Boolean)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Document(System.Int32,Lucene.Net.Documents.FieldSelector)">
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetFieldNames(Lucene.Net.Index.IndexReader.FieldOption)">
            <seealso cref="!:IndexReader.GetFieldNames(IndexReader.FieldOption fldOption)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Norms(System.String,System.Byte[],System.Int32)">
            <summary>Read norms into a pre-allocated array. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetTermVectorsReader">
            <summary> Create a clone from the initial TermVectorsReader and store it in the ThreadLocal.</summary>
            <returns> TermVectorsReader
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetTermFreqVector(System.Int32,System.String)">
            <summary>Return a term frequency vector for the specified document and field. The
            vector returned contains term numbers and frequencies for all terms in
            the specified field of this document, if the field had storeTermVector
            flag set.  If the flag was not set, the method returns null.
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetTermFreqVectors(System.Int32)">
            <summary>Return an array of term frequency vectors for the specified document.
            The array contains a vector for each vectorized field in the document.
            Each vector vector contains term numbers and frequencies for all terms
            in a given vectorized field.
            If no such fields existed, the method returns null.
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.FieldInfos">
            <summary>Returns the field infos of this segment </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetSegmentName">
            <summary> Return the name of the segment this reader is reading.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.GetSegmentInfo">
            <summary> Return the SegmentInfo of the segment this reader is reading.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.Norm.Close">
            <summary>Closes the underlying IndexInput for this norm.
            It is still valid to access all other norm properties after close is called.
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="T:Lucene.Net.Index.MultiSegmentReader">
            <summary> An IndexReader which reads indexes with multiple segments.</summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiSegmentReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfos,System.Boolean,System.Boolean)">
            <summary>Construct reading the named set of readers. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiSegmentReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfos,System.Boolean,Lucene.Net.Index.SegmentReader[],System.Int32[],System.Collections.Generic.Dictionary{System.String,System.Byte[]},System.Boolean)">
            <summary>This contructor is only used for {@link #Reopen()} </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiSegmentReader.MultiTermDocs.Read(System.Int32[],System.Int32[])">
            <summary>Optimized implementation. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermPositions" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermPositions.NextPosition" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermPositions.GetPayloadLength" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermPositions.GetPayload(System.Byte[],System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermPositions.IsPayloadAvailable" -->
        <member name="T:Lucene.Net.Index.FilterIndexReader">
            <summary>A <code>FilterIndexReader</code> contains another IndexReader, which it
            uses as its basic source of data, possibly transforming the data along the
            way or providing additional functionality. The class
            <code>FilterIndexReader</code> itself simply implements all abstract methods
            of <code>IndexReader</code> with versions that pass all requests to the
            contained index reader. Subclasses of <code>FilterIndexReader</code> may
            further override some of these methods and may also provide additional
            methods and fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterIndexReader.#ctor(Lucene.Net.Index.IndexReader)">
            <summary> <p>Construct a FilterIndexReader based on the specified base reader.
            Directory locking for delete, undeleteAll, and setNorm operations is
            left to the base reader.</p>
            <p>Note that base reader is closed if this FilterIndexReader is closed.</p>
            </summary>
            <param name="in">specified base reader.
            </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterIndexReader.FilterTermDocs">
            <summary>Base class for filtering {@link TermDocs} implementations. </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterIndexReader.FilterTermPositions">
            <summary>Base class for filtering {@link TermPositions} implementations. </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterIndexReader.FilterTermEnum">
            <summary>Base class for filtering {@link TermEnum} implementations. </summary>
        </member>
        <member name="T:Lucene.Net.Documents.MapFieldSelector">
            <summary> A FieldSelector based on a Map of field names to FieldSelectorResults
            
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.FieldSelector">
            <summary> Similar to a {@link java.io.FileFilter}, the FieldSelector allows one to make decisions about
            what Fields get loaded on a {@link Document} by {@link Lucene.Net.Index.IndexReader#Document(int,Lucene.Net.Documents.FieldSelector)}
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FieldSelector.Accept(System.String)">
            <summary> </summary>
            <param name="fieldName">the field to accept or reject
            </param>
            <returns> an instance of {@link FieldSelectorResult}
            if the {@link Field} named <code>fieldName</code> should be loaded.
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.MapFieldSelector.#ctor(System.Collections.IDictionary)">
            <summary>Create a a MapFieldSelector</summary>
            <param name="fieldSelections">maps from field names (String) to FieldSelectorResults
            </param>
        </member>
        <member name="M:Lucene.Net.Documents.MapFieldSelector.#ctor(System.Collections.IList)">
            <summary>Create a a MapFieldSelector</summary>
            <param name="fields">fields to LOAD.  List of Strings.  All other fields are NO_LOAD.
            </param>
        </member>
        <member name="M:Lucene.Net.Documents.MapFieldSelector.#ctor(System.String[])">
            <summary>Create a a MapFieldSelector</summary>
            <param name="fields">fields to LOAD.  All other fields are NO_LOAD.
            </param>
        </member>
        <member name="M:Lucene.Net.Documents.MapFieldSelector.Accept(System.String)">
            <summary>Load field according to its associated value in fieldSelections</summary>
            <param name="field">a field name
            </param>
            <returns> the fieldSelections value that field maps to or NO_LOAD if none.
            </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.TeeTokenFilter">
            <summary> Works in conjunction with the SinkTokenizer to provide the ability to set aside tokens
            that have already been analyzed.  This is useful in situations where multiple fields share
            many common analysis steps and then go their separate ways.
            <p/>
            It is also useful for doing things like entity extraction or proper noun analysis as
            part of the analysis workflow and saving off those tokens for use in another field.
            
            <pre>
            SinkTokenizer sink1 = new SinkTokenizer(null);
            SinkTokenizer sink2 = new SinkTokenizer(null);
            TokenStream source1 = new TeeTokenFilter(new TeeTokenFilter(new WhitespaceTokenizer(reader1), sink1), sink2);
            TokenStream source2 = new TeeTokenFilter(new TeeTokenFilter(new WhitespaceTokenizer(reader2), sink1), sink2);
            TokenStream final1 = new LowerCaseFilter(source1);
            TokenStream final2 = source2;
            TokenStream final3 = new EntityDetect(sink1);
            TokenStream final4 = new URLDetect(sink2);
            d.add(new Field("f1", final1));
            d.add(new Field("f2", final2));
            d.add(new Field("f3", final3));
            d.add(new Field("f4", final4));
            </pre>
            In this example, sink1 and sink2 will both get tokens from both reader1 and reader2 after whitespace tokenizer
            and now we can further wrap any of these in extra analysis, and more "sources" can be inserted if desired.
            Note, the EntityDetect and URLDetect TokenStreams are for the example and do not currently exist in Lucene
            <p/>
            
            See http://issues.apache.org/jira/browse/LUCENE-1058
            </summary>
            <seealso cref="T:Lucene.Net.Analysis.SinkTokenizer">
            
            
            </seealso>
        </member>
        <member name="T:Lucene.Net.Analysis.PorterStemmer">
            <summary> 
            Stemmer, implementing the Porter Stemming Algorithm
            
            The Stemmer class transforms a word into its root form.  The input
            word can be provided a character at time (by calling add()), or at once
            by calling one of the various stem(something) methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Reset">
            <summary> reset() resets the stemmer so it can stem another word.  If you invoke
            the stemmer by calling add(char) and then Stem(), you must call reset()
            before starting another word.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Add(System.Char)">
            <summary> Add a character to the word being stemmed.  When you are finished
            adding characters, you can call Stem(void) to process the word.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.ToString">
            <summary> After a word has been stemmed, it can be retrieved by toString(),
            or a reference to the internal buffer can be retrieved by getResultBuffer
            and getResultLength (which is generally more efficient.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.GetResultLength">
            <summary> Returns the length of the word resulting from the stemming process.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.GetResultBuffer">
            <summary> Returns a reference to a character buffer containing the results of
            the stemming process.  You also need to consult getResultLength()
            to determine the length of the result.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.String)">
            <summary> Stem a word provided as a String.  Returns the result as a String.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.Char[])">
            <summary>Stem a word contained in a char[].  Returns true if the stemming process
            resulted in a word different from the input.  You can retrieve the
            result with getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.Char[],System.Int32,System.Int32)">
            <summary>Stem a word contained in a portion of a char[] array.  Returns
            true if the stemming process resulted in a word different from
            the input.  You can retrieve the result with
            getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem(System.Char[],System.Int32)">
            <summary>Stem a word contained in a leading portion of a char[] array.
            Returns true if the stemming process resulted in a word different
            from the input.  You can retrieve the result with
            getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Stem">
            <summary>Stem the word placed into the Stemmer buffer through calls to add().
            Returns true if the stemming process resulted in a word different
            from the input.  You can retrieve the result with
            getResultLength()/getResultBuffer() or toString().
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.PorterStemmer.Main(System.String[])">
            <summary>Test program for demonstrating the Stemmer.  It reads a file and
            stems each word, writing the result to standard out.
            Usage: Stemmer file-name
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.KeywordAnalyzer">
            <summary> "Tokenizes" the entire stream as a single token. This is useful
            for data like zip codes, ids, and some product names.
            </summary>
        </member>
        <member name="T:IThreadRunnable">
            <summary>
            This interface should be implemented by any class whose instances are intended 
            to be executed by a thread.
            </summary>
        </member>
        <member name="M:IThreadRunnable.Run">
            <summary>
            This method has to be implemented in order that starting of the thread causes the object's 
            run method to be called in that separately executing thread.
            </summary>
        </member>
        <member name="T:SupportClass">
            <summary>
            Contains conversion support elements such as classes, interfaces and static methods.
            </summary>
        </member>
        <member name="M:SupportClass.TextSupport.GetCharsFromString(System.String,System.Int32,System.Int32,System.Char[],System.Int32)">
            <summary>
            Copies an array of chars obtained from a String into a specified array of chars
            </summary>
            <param name="sourceString">The String to get the chars from</param>
            <param name="sourceStart">Position of the String to start getting the chars</param>
            <param name="sourceEnd">Position of the String to end getting the chars</param>
            <param name="destinationArray">Array to return the chars</param>
            <param name="destinationStart">Position of the destination array of chars to start storing the chars</param>
            <returns>An array of chars</returns>
        </member>
        <member name="M:SupportClass.CollectionsSupport.BitSet.NextSetBit(System.Int32)">
            <summary>
            Returns the next set bit at or index, or -1 if no such bit exists.
            </summary>
            <param name="index">the index of the bit at which to start checking</param>
            <returns>the next set bit or -1</returns>
        </member>
        <member name="T:SupportClass.ThreadClass">
            <summary>
            Support class used to handle threads
            </summary>
        </member>
        <member name="F:SupportClass.ThreadClass.threadField">
            <summary>
            The instance of System.Threading.Thread
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor">
            <summary>
            Initializes a new instance of the ThreadClass class
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Name">The name of the thread</param>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor(System.Threading.ThreadStart)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing</param>
        </member>
        <member name="M:SupportClass.ThreadClass.#ctor(System.Threading.ThreadStart,System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="Start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing</param>
            <param name="Name">The name of the thread</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Run">
            <summary>
            This method has no functionality unless the method is overridden
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Start">
            <summary>
            Causes the operating system to change the state of the current thread instance to ThreadState.Running
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Interrupt">
            <summary>
            Interrupts a thread that is in the WaitSleepJoin thread state
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Join">
            <summary>
            Blocks the calling thread until a thread terminates
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Join(System.Int64)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses
            </summary>
            <param name="MiliSeconds">Time of wait in milliseconds</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Join(System.Int64,System.Int32)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses
            </summary>
            <param name="MiliSeconds">Time of wait in milliseconds</param>
            <param name="NanoSeconds">Time of wait in nanoseconds</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Resume">
            <summary>
            Resumes a thread that has been suspended
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Abort">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked, 
            to begin the process of terminating the thread. Calling this method 
            usually terminates the thread
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.Abort(System.Object)">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked, 
            to begin the process of terminating the thread while also providing
            exception information about the thread termination. 
            Calling this method usually terminates the thread.
            </summary>
            <param name="stateInfo">An object that contains application-specific information, such as state, which can be used by the thread being aborted</param>
        </member>
        <member name="M:SupportClass.ThreadClass.Suspend">
            <summary>
            Suspends the thread, if the thread is already suspended it has no effect
            </summary>
        </member>
        <member name="M:SupportClass.ThreadClass.ToString">
            <summary>
            Obtain a String that represents the current object
            </summary>
            <returns>A String that represents the current object</returns>
        </member>
        <member name="M:SupportClass.ThreadClass.Current">
            <summary>
            Gets the currently running thread
            </summary>
            <returns>The currently running thread</returns>
        </member>
        <member name="P:SupportClass.ThreadClass.Instance">
            <summary>
            Gets the current thread instance
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.Name">
            <summary>
            Gets or sets the name of the thread
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.Priority">
            <summary>
            Gets or sets a value indicating the scheduling priority of a thread
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.IsAlive">
            <summary>
            Gets a value indicating the execution status of the current thread
            </summary>
        </member>
        <member name="P:SupportClass.ThreadClass.IsBackground">
            <summary>
            Gets or sets a value indicating whether or not a thread is a background thread.
            </summary>
        </member>
        <member name="T:SupportClass.FileSupport">
            <summary>
            Represents the methods to support some operations over files.
            </summary>
        </member>
        <member name="M:SupportClass.FileSupport.GetFiles(System.IO.FileInfo)">
            <summary>
            Returns an array of abstract pathnames representing the files and directories of the specified path.
            </summary>
            <param name="path">The abstract pathname to list it childs.</param>
            <returns>An array of abstract pathnames childs of the path specified or null if the path is not a directory</returns>
        </member>
        <member name="M:SupportClass.FileSupport.GetLuceneIndexFiles(System.String,Lucene.Net.Index.IndexFileNameFilter)">
            <summary>
            Returns a list of files in a give directory.
            </summary>
            <param name="fullName">The full path name to the directory.</param>
            <param name="indexFileNameFilter"></param>
            <returns>An array containing the files.</returns>
        </member>
        <member name="T:SupportClass.Number">
            <summary>
            A simple class for number conversions.
            </summary>
        </member>
        <member name="F:SupportClass.Number.MIN_RADIX">
            <summary>
            Min radix value.
            </summary>
        </member>
        <member name="F:SupportClass.Number.MAX_RADIX">
            <summary>
            Max radix value.
            </summary>
        </member>
        <member name="M:SupportClass.Number.ToString(System.Int64)">
            <summary>
            Converts a number to System.String.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Number.ToString(System.Single)">
            <summary>
            Converts a number to System.String.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Number.ToString(System.Int64,System.Int32)">
            <summary>
            Converts a number to System.String in the specified radix.
            </summary>
            <param name="i">A number to be converted.</param>
            <param name="radix">A radix.</param>
            <returns>A System.String representation of the number in the specified redix.</returns>
        </member>
        <member name="M:SupportClass.Number.Parse(System.String,System.Int32)">
            <summary>
            Parses a number in the specified radix.
            </summary>
            <param name="s">An input System.String.</param>
            <param name="radix">A radix.</param>
            <returns>The parsed number in the specified radix.</returns>
        </member>
        <member name="M:SupportClass.Number.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:SupportClass.Number.URShift(System.Int64,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:SupportClass.Number.NextSetBit(System.Collections.BitArray,System.Int32)">
            <summary>
            Returns the index of the first bit that is set to true that occurs 
            on or after the specified starting index. If no such bit exists 
            then -1 is returned.
            </summary>
            <param name="bits">The BitArray object.</param>
            <param name="fromIndex">The index to start checking from (inclusive).</param>
            <returns>The index of the next set bit.</returns>
        </member>
        <member name="M:SupportClass.Number.Cardinality(System.Collections.BitArray)">
            <summary>
            Returns the number of bits set to true in this BitSet.
            </summary>
            <param name="bits">The BitArray object.</param>
            <returns>The number of bits set to true in this BitSet.</returns>
        </member>
        <member name="M:SupportClass.Number.ToInt64(System.String)">
            <summary>
            Converts a System.String number to long.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:SupportClass.Character">
            <summary>
            Mimics Java's Character class.
            </summary>
        </member>
        <member name="M:SupportClass.Character.ForDigit(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="digit"></param>
            <param name="radix"></param>
            <returns></returns>
        </member>
        <member name="P:SupportClass.Character.MAX_RADIX">
            <summary>
            </summary>
        </member>
        <member name="P:SupportClass.Character.MIN_RADIX">
            <summary>
            </summary>
        </member>
        <member name="T:SupportClass.Date">
            <summary>
            
            </summary>
        </member>
        <member name="M:SupportClass.Date.GetTime(System.DateTime)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <returns></returns>
        </member>
        <member name="T:SupportClass.Single">
            <summary>
            
            </summary>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="style"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String,System.Globalization.NumberStyles)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <param name="style"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.Parse(System.String)">
            <summary>
            
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.ToString(System.Single)">
            <summary>
            
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.Single.ToString(System.Single,System.String)">
            <summary>
            
            </summary>
            <param name="f"></param>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="T:SupportClass.AppSettings">
            <summary>
            
            </summary>
        </member>
        <member name="M:SupportClass.AppSettings.Set(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
        </member>
        <member name="M:SupportClass.AppSettings.Set(System.String,System.Int64)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
        </member>
        <member name="M:SupportClass.AppSettings.Set(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="Key"></param>
            <param name="Value"></param>
        </member>
        <member name="M:SupportClass.AppSettings.Set(System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="Key"></param>
            <param name="Value"></param>
        </member>
        <member name="M:SupportClass.AppSettings.Get(System.String,System.Int32)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.AppSettings.Get(System.String,System.Int64)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="M:SupportClass.AppSettings.Get(System.String,System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="defValue"></param>
            <returns></returns>
        </member>
        <member name="T:SupportClass.BitSetSupport">
            <summary>
            This class provides supporting methods of java.util.BitSet
            that are not present in System.Collections.BitArray.
            </summary>
        </member>
        <member name="M:SupportClass.BitSetSupport.NextSetBit(System.Collections.BitArray,System.Int32)">
            <summary>
            Returns the next set bit at or after docId, or -1 if no such bit exists.
            </summary>
            <param name="bitArray"></param>
            <param name="docId">the index of bit array at which to start checking</param>
            <returns>the next set bit or -1</returns>
        </member>
        <member name="T:SupportClass.Compare">
            <summary>
            Summary description for TestSupportClass.
            </summary>
        </member>
        <member name="M:SupportClass.Compare.CompareTermArrays(Lucene.Net.Index.Term[],Lucene.Net.Index.Term[])">
            <summary>
            Compares two Term arrays for equality.
            </summary>
            <param name="t1">First Term array to compare</param>
            <param name="t2">Second Term array to compare</param>
            <returns>true if the Terms are equal in both arrays, false otherwise</returns>
        </member>
        <member name="M:SupportClass.Compare.CompareStringArrays(System.String[],System.String[])">
            <summary>
            Compares two string arrays for equality.
            </summary>
            <param name="l1">First string array list to compare</param>
            <param name="l2">Second string array list to compare</param>
            <returns>true if the strings are equal in both arrays, false otherwise</returns>
        </member>
        <member name="T:SupportClass.CompressionSupport">
            <summary>
            Use for .NET 1.1 Framework only.
            </summary>
        </member>
        <member name="T:SupportClass.WeakHashTable">
            <summary>
            A Hashtable which holds weak references to its keys so they
            can be collected during GC. 
            </summary>
        </member>
        <member name="F:SupportClass.WeakHashTable.collectableObject">
            <summary>
            Serves as a simple "GC Monitor" that indicates whether cleanup is needed. 
            If collectableObject.IsAlive is false, GC has occurred and we should perform cleanup
            </summary>
        </member>
        <member name="M:SupportClass.WeakHashTable.KeyEquals(System.Object,System.Object)">
            <summary>
            Customize the hashtable lookup process by overriding KeyEquals. KeyEquals
            will compare both WeakKey to WeakKey and WeakKey to real keys
            </summary>
        </member>
        <member name="M:SupportClass.WeakHashTable.CleanIfNeeded">
            <summary>
            Perform cleanup if GC occurred
            </summary>
        </member>
        <member name="M:SupportClass.WeakHashTable.Clean">
            <summary>
            Iterate over all keys and remove keys that were collected
            </summary>
        </member>
        <member name="M:SupportClass.WeakHashTable.Add(System.Object,System.Object)">
            <summary>
            Wrap each key with a WeakKey and add it to the hashtable
            </summary>
        </member>
        <member name="P:SupportClass.WeakHashTable.Keys">
            <summary>
            Create a temporary copy of the real keys and return that
            </summary>
        </member>
        <member name="T:SupportClass.WeakHashTable.WeakKey">
            <summary>
            A weak referene wrapper for the hashtable keys. Whenever a key\value pair 
            is added to the hashtable, the key is wrapped using a WeakKey. WeakKey saves the
            value of the original object hashcode for fast comparison.
            </summary>
        </member>
        <member name="T:SupportClass.WeakHashTable.WeakDictionaryEnumerator">
            <summary>
            A Dictionary enumerator which wraps the original hashtable enumerator 
            and performs 2 tasks: Extract the real key from a WeakKey and skip keys
            that were already collected.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.SpanQueryFilter">
            <summary> Constrains search results to only match those which also match a provided
            query. Also provides position information about where each document matches
            at the cost of extra space compared with the QueryWrapperFilter.
            There is an added cost to this above what is stored in a {@link QueryWrapperFilter}.  Namely,
            the position information for each matching document is stored.
            <p/>
            This filter does not cache.  See the {@link Lucene.Net.Search.CachingSpanFilter} for a wrapper that
            caches.
            
            
            </summary>
            <version>  $Id:$
            </version>
        </member>
        <member name="T:Lucene.Net.Search.SpanFilter">
            <summary>Abstract base class providing a mechanism to restrict searches to a subset
            of an index and also maintains and returns position information.
            This is useful if you want to compare the positions from a SpanQuery with the positions of items in
            a filter.  For instance, if you had a SpanFilter that marked all the occurrences of the word "foo" in documents,
            and then you entered a new SpanQuery containing bar, you could not only filter by the word foo, but you could
            then compare position information for post processing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SpanFilter.BitSpans(Lucene.Net.Index.IndexReader)">
            <summary>Returns a SpanFilterResult with true for documents which should be permitted in
            search results, and false for those that should not and Spans for where the true docs match.
            </summary>
            <param name="reader">The {@link Lucene.Net.Index.IndexReader} to load position and DocIdSet information from
            </param>
            <returns> A {@link SpanFilterResult}
            </returns>
            <throws>  java.io.IOException if there was an issue accessing the necessary information </throws>
            <summary> 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SpanQueryFilter.#ctor(Lucene.Net.Search.Spans.SpanQuery)">
            <summary>Constructs a filter which only matches documents matching
            <code>query</code>.
            </summary>
            <param name="query">The {@link Lucene.Net.Search.Spans.SpanQuery} to use as the basis for the Filter.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SortComparator" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SortComparatorSource" -->
        <member name="M:Lucene.Net.Search.SortComparatorSource.NewComparator(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Creates a comparator for the field in the given index.</summary>
            <param name="reader">Index to create comparator for.
            </param>
            <param name="fieldname"> Name of the field to create comparator for.
            </param>
            <returns> Comparator of ScoreDoc objects.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SortComparator.GetComparable(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ScoreDocComparator.Compare(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.ScoreDoc)" -->
        <member name="M:Lucene.Net.Search.ScoreDocComparator.SortValue(Lucene.Net.Search.ScoreDoc)">
            <summary> Returns the value used to sort the given document.  The
            object returned must implement the java.io.Serializable
            interface.  This is used by multisearchers to determine how
            to collate results from their searchers.
            </summary>
            <seealso cref="T:Lucene.Net.Search.FieldDoc">
            </seealso>
            <param name="i">Document
            </param>
            <returns> Serializable object
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDocComparator.SortType">
            <summary> Returns the type of sort.  Should return <code>SortField.SCORE</code>,
            <code>SortField.DOC</code>, <code>SortField.STRING</code>,
            <code>SortField.INTEGER</code>, <code>SortField.FLOAT</code> or
            <code>SortField.CUSTOM</code>.  It is not valid to return
            <code>SortField.AUTO</code>.
            This is used by multisearchers to determine how to collate results
            from their searchers.
            </summary>
            <returns> One of the constants in SortField.
            </returns>
            <seealso cref="T:Lucene.Net.Search.SortField">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Search.RemoteCachingWrapperFilter">
            <summary> Provides caching of {@link Filter}s themselves on the remote end of an RMI connection.
            The cache is keyed on Filter's hashCode(), so if it sees the same filter twice
            it will reuse the original version.
            <p/>
            NOTE: This does NOT cache the Filter bits, but rather the Filter itself.
            Thus, this works hand-in-hand with {@link CachingWrapperFilter} to keep both
            file Filter cache and the Filter bits on the remote end, close to the searcher.
            <p/>
            Usage:
            <p/>
            To cache a result you must do something like 
            RemoteCachingWrapperFilter f = new RemoteCachingWrapperFilter(new CachingWrapperFilter(myFilter));
            <p/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RemoteCachingWrapperFilter.Bits(Lucene.Net.Index.IndexReader)">
            <summary> Uses the {@link FilterManager} to keep the cache for a filter on the 
            searcher side of a remote connection.
            </summary>
            <param name="reader">the index reader for the Filter
            </param>
            <returns> the bitset
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.RemoteCachingWrapperFilter.GetDocIdSet(Lucene.Net.Index.IndexReader)">
            <summary> Uses the {@link FilterManager} to keep the cache for a filter on the 
            searcher side of a remote connection.
            </summary>
            <param name="reader">the index reader for the Filter
            </param>
            <returns> the DocIdSet
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.RangeFilter">
            <summary> A Filter that restricts search results to a range of values in a given
            field.
            
            <p>
            This code borrows heavily from {@link RangeQuery}, but is implemented as a Filter
            
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.#ctor(System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <param name="fieldName">The field this range applies to
            </param>
            <param name="lowerTerm">The lower bound on this range
            </param>
            <param name="upperTerm">The upper bound on this range
            </param>
            <param name="includeLower">Does this range include the lower bound?
            </param>
            <param name="includeUpper">Does this range include the upper bound?
            </param>
            <throws>  IllegalArgumentException if both terms are null or if </throws>
            <summary>  lowerTerm is null and includeLower is true (similar for upperTerm
            and includeUpper)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.#ctor(System.String,System.String,System.String,System.Boolean,System.Boolean,System.Globalization.CompareInfo)">
            <summary>
            WARNING: Using this constructor and supplying a non-null
            value in the collator paramter will cause every single
            index Term in the Field referenced by lowerTerm and/or upperTerm
            to be examined.  Depending on the number of index Terms in this 
            Field, the operation could be very slow.
            </summary>
            <param name="fieldName"></param>
            <param name="lowerTerm">lower bound</param>
            <param name="upperTerm">upper bound</param>
            <param name="includeLower">is lower bound inclusive</param>
            <param name="includeUpper">is upper bound inclusive</param>
            <param name="collator">the collator that determines range inclusion; when set to null Unicode code point ordering is used</param>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.Less(System.String,System.String)">
            <summary> Constructs a filter for field <code>fieldName</code> matching
            less than or equal to <code>upperTerm</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.More(System.String,System.String)">
            <summary> Constructs a filter for field <code>fieldName</code> matching
            greater than or equal to <code>lowerTerm</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.Bits(Lucene.Net.Index.IndexReader)">
            <summary> Returns a BitSet with true for documents which should be
            permitted in search results, and false for those that should
            not.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.GetDocIdSet(Lucene.Net.Index.IndexReader)">
            <summary> Returns a DocIdSet with documents that should be
            permitted in search results.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.Equals(System.Object)">
            <summary>Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.RangeFilter.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.NonMatchingScorer">
            <summary>A scorer that matches no document at all. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Hits" -->
        <member name="M:Lucene.Net.Search.Hits.GetMoreDocs(System.Int32)">
            <summary> Tries to add new documents to hitDocs.
            Ensures that the hit numbered <code>min</code> has been retrieved.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Hits.Length">
            <summary>Returns the total number of hits available in this set. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Hits.Doc(System.Int32)" -->
        <member name="M:Lucene.Net.Search.Hits.Score(System.Int32)">
            <summary>Returns the score for the n<sup>th</sup> document in this set. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Hits.Id(System.Int32)">
            <summary>Returns the id for the n<sup>th</sup> document in this set.
            Note that ids may change when the index changes, so you cannot
            rely on the id to be stable.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Hits.Iterator">
            <summary> Returns a {@link HitIterator} to navigate the Hits.  Each item returned
            from {@link Iterator#next()} is a {@link Hit}.
            <p>
            <b>Caution:</b> Iterate only over the hits needed.  Iterating over all
            hits is generally not desirable and may be the source of
            performance issues. If you need to iterate over many or all hits, consider
            using a search method that takes a {@link HitCollector}.
            </p>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionSumScorer">
            <summary>A Scorer for OR like queries, counterpart of <code>ConjunctionScorer</code>.
            This Scorer implements {@link Scorer#SkipTo(int)} and uses skipTo() on the given Scorers. 
            </summary>
            <todo>  Implement score(HitCollector, int). </todo>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.nrScorers">
            <summary>The number of subscorers. </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.subScorers">
            <summary>The subscorers. </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.minimumNrMatchers">
            <summary>The minimum number of scorers that should match. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.DisjunctionSumScorer.scorerDocQueue" -->
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.currentDoc">
            <summary>The document number of the current match. </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.nrMatchers">
            <summary>The number of subscorers that provide the current match. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionSumScorer.#ctor(System.Collections.IList,System.Int32)" -->
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.#ctor(System.Collections.IList)">
            <summary>Construct a <code>DisjunctionScorer</code>, using one as the minimum number
            of matching subscorers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.InitScorerDocQueue">
            <summary>Called the first time next() or skipTo() is called to
            initialize <code>scorerDocQueue</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionSumScorer.Score(Lucene.Net.Search.HitCollector)" -->
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.Score(Lucene.Net.Search.HitCollector,System.Int32)">
            <summary>Expert: Collects matching documents in a range.  Hook for optimization.
            Note that {@link #Next()} must be called once before this method is called
            for the first time.
            </summary>
            <param name="hc">The collector to which all matching documents are passed through
            {@link HitCollector#Collect(int, float)}.
            </param>
            <param name="max">Do not score documents past this.
            </param>
            <returns> true if more matching documents may remain.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionSumScorer.AdvanceAfterCurrent" -->
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.Score">
            <summary>Returns the score of the current document matching the query.
            Initially invalid, until {@link #Next()} is called the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.NrMatchers">
            <summary>Returns the number of subscorers matching the current document.
            Initially invalid, until {@link #Next()} is called the first time.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionSumScorer.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.Explain(System.Int32)">
            <returns> An explanation for the score of a given document. 
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionMaxScorer">
            <summary> The Scorer for DisjunctionMaxQuery's.  The union of all documents generated by the the subquery scorers
            is generated in document number order.  The score for each document is the maximum of the scores computed
            by the subquery scorers that generate that document, plus tieBreakerMultiplier times the sum of the scores
            for the other subqueries that generate the document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.#ctor(System.Single,Lucene.Net.Search.Similarity)">
            <summary>Creates a new instance of DisjunctionMaxScorer</summary>
            <param name="tieBreakerMultiplier">Multiplier applied to non-maximum-scoring subqueries for a document as they are summed into the result.
            </param>
            <param name="similarity">-- not used since our definition involves neither coord nor terms directly 
            </param>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.Add(Lucene.Net.Search.Scorer)">
            <summary>Add the scorer for a subquery</summary>
            <param name="scorer">the scorer of a subquery of our associated DisjunctionMaxQuery
            </param>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.Next">
            <summary>Generate the next document matching our associated DisjunctionMaxQuery.</summary>
            <returns> true iff there is a next document
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.Doc">
            <summary>Determine the current document number.  Initially invalid, until {@link #Next()} is called the first time.</summary>
            <returns> the document number of the currently generated document
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.Score">
            <summary>Determine the current document score.  Initially invalid, until {@link #Next()} is called the first time.</summary>
            <returns> the score of the current generated document
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.SkipTo(System.Int32)">
            <summary>Advance to the first document beyond the current whose number is greater than or equal to target.</summary>
            <param name="target">the minimum number of the next desired document
            </param>
            <returns> true iff there is a document to be generated whose number is at least target
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.Explain(System.Int32)">
            <summary>Explain a score that we computed.  UNSUPPORTED -- see explanation capability in DisjunctionMaxQuery.</summary>
            <param name="doc">the number of a document we scored
            </param>
            <returns> the Explanation for our score
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.CachingWrapperFilter">
            <summary> Wraps another filter's result and caches it.  The purpose is to allow
            filters to simply filter, and then wrap with this class to add caching.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.CachingWrapperFilter.cache">
            <summary> A transient Filter cache.  To cache Filters even when using {@link RemoteSearchable} use
            {@link RemoteCachingWrapperFilter} instead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingWrapperFilter.#ctor(Lucene.Net.Search.Filter)">
            <param name="filter">Filter to cache results of
            </param>
        </member>
        <member name="T:Lucene.Net.Index.StaleReaderException">
            <summary> This exception is thrown when an {@link IndexReader}
            tries to make changes to the index (via {@link
            IndexReader#deleteDocument}, {@link
            IndexReader#undeleteAll} or {@link IndexReader#setNorm})
            but changes have already been committed to the index
            since this reader was instantiated.  When this happens
            you must open a new reader on the current index to make
            the changes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileNameFilter">
            <summary> Filename filter that accept filenames and extensions only created by Lucene.</summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNameFilter.IsCFSFile(System.String)">
            <summary> Returns true if this is a file that would be contained
            in a CFS file.  This function should only be called on
            files that pass the above "accept" (ie, are already
            known to be a Lucene index file).
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Fieldable">
            <summary>
            Synonymous with {@link Field}.
            <p><bold>WARNING</bold>: This interface may change within minor versions, despite Lucene's backward compatibility requirements.
            This means new methods may be added from version to version.  This change only affects the Fieldable API; other backwards
            compatibility promises remain intact. For example, Lucene can still
            read and write indices created within the same major version.
            </p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Fieldable.SetBoost(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Fieldable.GetBoost" -->
        <member name="M:Lucene.Net.Documents.Fieldable.Name">
            <summary>Returns the name of the field as an interned string.
            For example "date", "title", "body", ...
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.StringValue">
            <summary>The value of the field as a String, or null.  If null, the Reader value,
            binary value, or TokenStream value is used.  Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.ReaderValue">
            <summary>The value of the field as a Reader, or null.  If null, the String value,
            binary value, or TokenStream value is used.  Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.BinaryValue">
            <summary>The value of the field in Binary, or null.  If null, the Reader value,
            String value, or TokenStream value is used. Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.TokenStreamValue">
            <summary>The value of the field as a TokenStream, or null.  If null, the Reader value,
            String value, or binary value is used. Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsStored">
            <summary>True iff the value of the field is to be stored in the index for return
            with search hits.  It is an error for this to be true if a field is
            Reader-valued. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsIndexed">
            <summary>True iff the value of the field is to be indexed, so that it may be
            searched on. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsTokenized">
            <summary>True iff the value of the field should be tokenized as text prior to
            indexing.  Un-tokenized fields are indexed as a single word and may not be
            Reader-valued. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsCompressed">
            <summary>True if the value of the field is stored and compressed within the index </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsTermVectorStored">
            <summary>True iff the term or terms used to index this field are stored as a term
            vector, available from {@link Lucene.Net.Index.IndexReader#GetTermFreqVector(int,String)}.
            These methods do not provide access to the original content of the field,
            only to terms used to index it. If the original content must be
            preserved, use the <code>stored</code> attribute instead.
            
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.GetTermFreqVector(System.Int32,System.String)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsStoreOffsetWithTermVector">
            <summary> True iff terms are stored as term vector together with their offsets 
            (start and end positon in source text).
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsStorePositionWithTermVector">
            <summary> True iff terms are stored as term vector together with their token positions.</summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsBinary">
            <summary>True iff the value of the filed is stored as binary </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.GetOmitNorms">
            <summary>True if norms are omitted for this indexed field </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.SetOmitNorms(System.Boolean)">
            <summary>Expert:
            
            If set, omit normalization factors associated with this indexed field.
            This effectively disables indexing boosts and length normalization for this field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.SetOmitTf(System.Boolean)">
            <summary>
            Expert:
            If set, omit term freq, positions, and payloads from postings for this field for this field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.GetOmitTf">
            <summary>
            True if tf is omitted for this indexed field.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.IsLazy">
            <summary> Indicates whether a Field is Lazy or not.  The semantics of Lazy loading are such that if a Field is lazily loaded, retrieving
            it's values via {@link #StringValue()} or {@link #BinaryValue()} is only valid as long as the {@link Lucene.Net.Index.IndexReader} that
            retrieved the {@link Document} is still open.
            
            </summary>
            <returns> true if this field can be loaded lazily
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.GetBinaryOffset">
            <summary>
            Returns the offset into the byte[] segment that is used as value.  If Fields is not binary returned value is undefined.
            </summary>
            <returns>index of the first byte in segment that represents this Field value</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.GetBinaryLength">
            <summary>
            Returns the of byte][ segment that is used as value.  If Fields is not binarythe returned value is undefined.
            </summary>
            <returns>length of byte[] segment that represents this Field value</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.GetBinaryValue">
            <summary>
            Return the raw byte[] for the vinary field.  Note that you must also call GetBinaryLength() and GetBinaryOffset()
            to know which range of bytes in the returned array belong to this Field.
            </summary>
            <returns>refererence to the Field value as byte</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Fieldable.GetBinaryValue(System.Byte[])">
            <summary>
            Return the raw byte[] for the vinary field.  Note that you must also call GetBinaryLength() and GetBinaryOffset()
            to know which range of bytes in the returned array belong to this Field.
            About reuse: if you pass in the result byte[] and it is used, it is likely the underlying implementation
            will hold onto this byte[] and return it in future calls to BinaryValue() of GetBinaryValue().
            So if you subsequently re-use the same byte[] elsewhere it will alter this Fieldable's value.
            </summary>
            <param name="result">user defined buffer that will be used if non-null and large enough to contain the Field value</param>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.Document" -->
        <member name="M:Lucene.Net.Documents.Document.#ctor">
            <summary>Constructs a new document with no fields. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetFieldsCount">
            <summary>Returns the number of fields in this document</summary>
            Added as a helper for Lucene.Net
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Document.SetBoost(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Document.GetBoost" -->
        <member name="M:Lucene.Net.Documents.Document.Add(Lucene.Net.Documents.Fieldable)">
            <summary> <p>Adds a field to a document.  Several fields may be added with
            the same name.  In this case, if the fields are indexed, their text is
            treated as though appended for the purposes of search.</p>
            <p> Note that add like the removeField(s) methods only makes sense 
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.RemoveField(System.String)">
            <summary> <p>Removes field with the specified name from the document.
            If multiple fields exist with this name, this method removes the first field that has been added.
            If there is no field with the specified name, the document remains unchanged.</p>
            <p> Note that the removeField(s) methods like the add method only make sense 
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.RemoveFields(System.String)">
            <summary> <p>Removes all fields with the given name from the document.
            If there is no field with the specified name, the document remains unchanged.</p>
            <p> Note that the removeField(s) methods like the add method only make sense 
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetField(System.String)">
            <summary>Returns a field with the given name if any exist in this document, or
            null.  If multiple fields exists with this name, this method returns the
            first value added.
            Do not use this method with lazy loaded fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetFieldable(System.String)">
            <summary>Returns a field with the given name if any exist in this document, or
            null.  If multiple fields exists with this name, this method returns the
            first value added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.Get(System.String)">
            <summary>Returns the string value of the field with the given name if any exist in
            this document, or null.  If multiple fields exist with this name, this
            method returns the first value added. If only binary fields with this name
            exist, returns null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.Fields">
            <summary>Returns an Enumeration of all the fields in a document.</summary>
            <deprecated> use {@link #GetFields()} instead
            </deprecated>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.Document.GetFields" -->
        <member name="M:Lucene.Net.Documents.Document.GetFields(System.String)">
            <summary> Returns an array of {@link Field}s with the given name.
            Do not use with lazy loaded fields.
            This method returns an empty array when there are no
            matching fields.  It never returns null.
            </summary>
            <param name="name">the name of the field
            </param>
            <returns> a <code>Field[]</code> array</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetFieldables(System.String)">
            <summary> Returns an array of {@link Fieldable}s with the given name.
            This method returns an empty array when there are no
            matching fields.  It never returns null.
            </summary>
            <param name="name">the name of the field
            </param>
            <returns> a <code>Fieldable[]</code> array</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetValues(System.String)">
            <summary> Returns an array of values of the field specified as the method parameter.
            This method returns an empty array when there are no
            matching fields.  It never returns null.
            </summary>
            <param name="name">the name of the field
            </param>
            <returns> a <code>String[]</code> of field values</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetBinaryValues(System.String)">
            <summary>
            Returns an array of byte arrays for the fields that have the name
            specified as the method parameter.
            This method returns an empty array when there are no
            matching fields.  It never returns null.
            </summary>
            <param name="name">the name of the field
            </param>
            <returns> a  <code>byte[][]</code> of binary field values</returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetBinaryValue(System.String)">
            <summary> Returns an array of bytes for the first (or only) field that has the name
            specified as the method parameter. This method will return <code>null</code>
            if no binary fields with the specified name are available.
            There may be non-binary fields with the same name.
            
            </summary>
            <param name="name">the name of the field.
            </param>
            <returns> a <code>byte[]</code> containing the binary field value or <code>null</code>
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.ToString">
            <summary>Prints the fields of a document for human consumption. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.LowerCaseFilter">
            <summary> Normalizes token text to lower case.
            
            </summary>
            <version>  $Id: LowerCaseFilter.java 564715 2007-08-10 18:34:33Z mikemccand $
            </version>
        </member>
        <member name="T:Lucene.Net.Util.OpenBitSet">
            <summary>
            An "open" BitSet implementation that allows direct access to the array of words
            storing the bits.
            <p/>
            Unlike java.util.bitset, the fact that bits are packed into an array of longs
            is part of the interface.  This allows efficient implementation of other algorithms
            by someone other than the author.  It also allows one to efficiently implement
            alternate serialization or interchange formats.
            <p/>
            <code>OpenBitSet</code> is faster than <code>java.util.BitSet</code> in most operations
            and *much* faster at calculating cardinality of sets and results of set operations.
            It can also handle sets of larger cardinality (up to 64 * 2**32-1)
            <p/>
            The goals of <code>OpenBitSet</code> are the fastest implementation possible, and
            maximum code reuse.  Extra safety and encapsulation
            may always be built on top, but if that's built in, the cost can never be removed (and
            hence people re-implement their own version in order to get better performance).
            If you want a "safe", totally encapsulated (and slower and limited) BitSet
            class, use <code>java.util.BitSet</code>.
            <p/>
            <h3>Performance Results</h3>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.#ctor(System.Int64)">
            Constructs an OpenBitSet large enough to hold numBits.
            
             @param numBits
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.OpenBitSet.#ctor(System.Int64[],System.Int32)" -->
        <member name="M:Lucene.Net.Util.OpenBitSet.Capacity">
            Returns the current capacity in bits (1 greater than the index of the last bit) 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Size">
            Returns the current capacity of this set.  Included for
            compatibility.  This is *not* equal to {@link #cardinality}
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.IsEmpty">
            Returns true if there are no set bits 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetBits">
            Expert: returns the long[] storing the bits 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.SetBits(System.Int64[])">
            Expert: sets a new long[] to use as the bit storage 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetNumWords">
            Expert: gets the number of longs in the array that are in use 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.SetNumWords(System.Int32)">
            Expert: sets the number of longs in the array that are in use 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Get(System.Int32)">
            Returns true or false for the specified bit index. 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastGet(System.Int32)">
            Returns true or false for the specified bit index.
            The index should be less than the OpenBitSet size
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Get(System.Int64)">
            Returns true or false for the specified bit index
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastGet(System.Int64)">
            Returns true or false for the specified bit index.
            The index should be less than the OpenBitSet size.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetBit(System.Int32)">
            returns 1 if the bit is set, 0 if not.
            The index should be less than the OpenBitSet size
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Set(System.Int64)">
            sets a bit, expanding the set size if necessary 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastSet(System.Int32)">
            Sets the bit at the specified index.
            The index should be less than the OpenBitSet size.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastSet(System.Int64)">
            Sets the bit at the specified index.
            The index should be less than the OpenBitSet size.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Set(System.Int64,System.Int64)">
            Sets a range of bits, expanding the set size if necessary
            
             @param startIndex lower index
             @param endIndex one-past the last bit to set
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastClear(System.Int32)">
            clears a bit.
            The index should be less than the OpenBitSet size.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastClear(System.Int64)">
            clears a bit.
            The index should be less than the OpenBitSet size.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Clear(System.Int64)">
            clears a bit, allowing access beyond the current set size without changing the size.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Clear(System.Int64,System.Int64)">
            Clears a range of bits.  Clearing past the end does not change the size of the set.
            
             @param startIndex lower index
             @param endIndex one-past the last bit to clear
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetAndSet(System.Int32)">
            Sets a bit and returns the previous value.
            The index should be less than the OpenBitSet size.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetAndSet(System.Int64)">
            Sets a bit and returns the previous value.
            The index should be less than the OpenBitSet size.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastFlip(System.Int32)">
            flips a bit.
            The index should be less than the OpenBitSet size.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastFlip(System.Int64)">
            flips a bit.
            The index should be less than the OpenBitSet size.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Flip(System.Int64)">
            flips a bit, expanding the set size if necessary 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FlipAndGet(System.Int32)">
            flips a bit and returns the resulting bit value.
            The index should be less than the OpenBitSet size.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FlipAndGet(System.Int64)">
            flips a bit and returns the resulting bit value.
            The index should be less than the OpenBitSet size.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Flip(System.Int64,System.Int64)">
            Flips a range of bits, expanding the set size if necessary
            
             @param startIndex lower index
             @param endIndex one-past the last bit to flip
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Cardinality">
            @return the number of set bits 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.IntersectionCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            Returns the popcount or cardinality of the intersection of the two sets.
            Neither set is modified.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.UnionCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            Returns the popcount or cardinality of the union of the two sets.
            Neither set is modified.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.AndNotCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            Returns the popcount or cardinality of "a and not b"
            or "intersection(a, not(b))".
            Neither set is modified.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.XorCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            Returns the popcount or cardinality of the exclusive-or of the two sets.
            Neither set is modified.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.NextSetBit(System.Int32)">
            Returns the index of the first set bit starting at the index specified.
            -1 is returned if there are no more set bits.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.NextSetBit(System.Int64)">
            Returns the index of the first set bit starting at the index specified.
            -1 is returned if there are no more set bits.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Intersect(Lucene.Net.Util.OpenBitSet)">
            this = this AND other 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Union(Lucene.Net.Util.OpenBitSet)">
            this = this OR other 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Remove(Lucene.Net.Util.OpenBitSet)">
            Remove all elements set in other. this = this AND_NOT other 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Xor(Lucene.Net.Util.OpenBitSet)">
            this = this XOR other 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Intersects(Lucene.Net.Util.OpenBitSet)">
            returns true if the sets have any elements in common 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.EnsureCapacityWords(System.Int32)">
            Expand the long[] with the size given as a number of words (64 bit longs).
            getNumWords() is unchanged by this call.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.EnsureCapacity(System.Int64)">
            Ensure that the long[] is big enough to hold numBits, expanding it if necessary.
            getNumWords() is unchanged by this call.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.trimTrailingZeros">
            Lowers numWords, the number of words in use,
            by checking for trailing zero words.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.bits2words(System.Int64)">
            returns the number of 64 bit words it would take to hold numBits 
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Equals(System.Object)">
            returns true if both sets have the same bits set 
        </member>
        <member name="T:Lucene.Net.Store.NoLockFactory">
            <summary> Use this {@link LockFactory} to disable locking entirely.
            This LockFactory is used when you call {@link FSDirectory#setDisableLocks}.
            Only one instance of this lock is created.  You should call {@link
            #GetNoLockFactory()} to get the instance.
            
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockFactory">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Search.WildcardQuery">
            <summary>Implements the wildcard search query. Supported wildcards are <code>*</code>, which
            matches any character sequence (including the empty one), and <code>?</code>,
            which matches any single character. Note this query can be slow, as it
            needs to iterate over many terms. In order to prevent extremely slow WildcardQueries,
            a Wildcard term should not start with one of the wildcards <code>*</code> or
            <code>?</code>.
            
            </summary>
            <seealso cref="T:Lucene.Net.Search.WildcardTermEnum">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Search.Spans.TermSpans">
            <summary> Expert:
            Public for extension only
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanOrQuery">
            <summary>Matches the union of its clauses.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery[])">
            <summary>Construct a SpanOrQuery merging the provided clauses. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.GetClauses">
            <summary>Return the clauses whose spans are matched. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.GetTerms">
            <summary>Returns a collection of all terms matched by this query.</summary>
            <deprecated> use extractTerms instead
            </deprecated>
            <seealso cref="!:#ExtractTerms(Set)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.BooleanScorer2" -->
        <member name="F:Lucene.Net.Search.BooleanScorer2.countingSumScorer">
            <summary>The scorer to which all scoring will be delegated,
            except for computing and using the coordination factor.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanScorer2.minNrShouldMatch">
            <summary>The number of optionalScorers that need to match (if there are any) </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanScorer2.allowDocsOutOfOrder">
            <summary>Whether it is allowed to return documents out of order.
            This can accelerate the scoring of disjunction queries.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.#ctor(Lucene.Net.Search.Similarity,System.Int32,System.Boolean)">
            <summary>Create a BooleanScorer2.</summary>
            <param name="similarity">The similarity to be used.
            </param>
            <param name="minNrShouldMatch">The minimum number of optional added scorers
            that should match during the search.
            In case no required scorers are added,
            at least one of the optional scorers will have to
            match during the search.
            </param>
            <param name="allowDocsOutOfOrder">Whether it is allowed to return documents out of order.
            This can accelerate the scoring of disjunction queries.                         
            </param>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.#ctor(Lucene.Net.Search.Similarity,System.Int32)">
            <summary>Create a BooleanScorer2.
            In no required scorers are added,
            at least one of the optional scorers will have to match during the search.
            </summary>
            <param name="similarity">The similarity to be used.
            </param>
            <param name="minNrShouldMatch">The minimum number of optional added scorers
            that should match during the search.
            In case no required scorers are added,
            at least one of the optional scorers will have to
            match during the search.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.#ctor(Lucene.Net.Search.Similarity)">
            <summary>Create a BooleanScorer2.
            In no required scorers are added,
            at least one of the optional scorers will have to match during the search.
            </summary>
            <param name="similarity">The similarity to be used.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanScorer2.InitCountingSumScorer" -->
        <member name="M:Lucene.Net.Search.BooleanScorer2.MakeCountingSumScorer">
            <summary>Returns the scorer to be used for match counting and score summing.
            Uses requiredScorers, optionalScorers and prohibitedScorers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.AddProhibitedScorers(Lucene.Net.Search.Scorer)">
            <summary>Returns the scorer to be used for match counting and score summing.
            Uses the given required scorer and the prohibitedScorers.
            </summary>
            <param name="requiredCountingSumScorer">A required scorer already built.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanScorer2.Score(Lucene.Net.Search.HitCollector)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanScorer2.Score(Lucene.Net.Search.HitCollector,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanScorer2.SkipTo(System.Int32)" -->
        <member name="M:Lucene.Net.Search.BooleanScorer2.Explain(System.Int32)">
            <summary>Throws an UnsupportedOperationException.
            TODO: Implement an explanation of the coordination factor.
            </summary>
            <param name="doc">The document number for the explanation.
            </param>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="T:Lucene.Net.Search.ConjunctionScorer">
            <summary>Scorer for conjunctions, sets of queries, all of which are required. </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanScorer2.SingleMatchScorer">
            <summary>Count a scorer as a single match. </summary>
        </member>
        <member name="T:Lucene.Net.Index.SnapshotDeletionPolicy">
            <summary>A {@link IndexDeletionPolicy} that wraps around any other
            {@link IndexDeletionPolicy} and adds the ability to hold and
            later release a single "snapshot" of an index.  While
            the snapshot is held, the {@link IndexWriter} will not
            remove any files associated with it even if the index is
            otherwise being actively, arbitrarily changed.  Because
            we wrap another arbitrary {@link IndexDeletionPolicy}, this
            gives you the freedom to continue using whatever {@link
            IndexDeletionPolicy} you would normally want to use with your
            index.  Note that you can re-use a single instance of
            SnapshotDeletionPolicy across multiple writers as long
            as they are against the same index Directory.  Any 
            snapshot held when a writer is closed will "survive"
            when the next writer is opened.
            <para>
            WARNING: This API is new and experimental and may suddnely changendex. 
            </para>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.IndexDeletionPolicy" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexDeletionPolicy.OnInit(System.Collections.Generic.List{Lucene.Net.Index.IndexCommitPoint})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexDeletionPolicy.OnCommit(System.Collections.Generic.List{Lucene.Net.Index.IndexCommitPoint})" -->
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.Snapshot">
            <summary>Take a snapshot of the most recent commit to the
            index.  You must call release() to free this snapshot.
            Note that while the snapshot is held, the files it
            references will not be deleted, which will consume
            additional disk space in your index. If you take a
            snapshot at a particularly bad time (say just before
            you call optimize()) then in the worst case this could
            consume an extra 1X of your total index size, until
            you release the snapshot. 
            </summary>
            // TODO: 3.9: change this to return IndexCommit instead
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.Release">
            <summary>Release the currently held snapshot. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermDocs.Read(System.Int32[],System.Int32[])">
            <summary>Optimized implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermDocs.SkipProx(System.Int64)">
            <summary>Overridden by SegmentTermPositions to skip in prox stream. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermDocs.SkipTo(System.Int32)">
            <summary>Optimized implementation. </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterThreadState">
            <summary>
            Used by DocumentsWriter to maintain per-thread state.
            We keep a separate Posting hash and other state for each
            thread and then merge postings hashes from all threads
            when writing the segment.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.AbstractField">
            <summary> 
            
            
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.AbstractField.SetBoost(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Documents.AbstractField.GetBoost" -->
        <member name="M:Lucene.Net.Documents.AbstractField.Name">
            <summary>Returns the name of the field as an interned string.
            For example "date", "title", "body", ...
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsStored">
            <summary>True iff the value of the field is to be stored in the index for return
            with search hits.  It is an error for this to be true if a field is
            Reader-valued. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsIndexed">
            <summary>True iff the value of the field is to be indexed, so that it may be
            searched on. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsTokenized">
            <summary>True iff the value of the field should be tokenized as text prior to
            indexing.  Un-tokenized fields are indexed as a single word and may not be
            Reader-valued. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsCompressed">
            <summary>True if the value of the field is stored and compressed within the index </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsTermVectorStored">
            <summary>True iff the term or terms used to index this field are stored as a term
            vector, available from {@link Lucene.Net.Index.IndexReader#GetTermFreqVector(int,String)}.
            These methods do not provide access to the original content of the field,
            only to terms used to index it. If the original content must be
            preserved, use the <code>stored</code> attribute instead.
            
            </summary>
            <seealso cref="!:String)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsStoreOffsetWithTermVector">
            <summary> True iff terms are stored as term vector together with their offsets 
            (start and end positon in source text).
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsStorePositionWithTermVector">
            <summary> True iff terms are stored as term vector together with their token positions.</summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.IsBinary">
            <summary>True iff the value of the filed is stored as binary </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.GetBinaryValue">
            <summary>
            Return the raw byte[] for the binary field.  Note that
            you must also call {@link #GetBinaryLength} and
            {@link #GetBinaryOffset} to know which range of bytes in 
            this returned array belong to the field.
            </summary>
            <returns>reference to the field value as byte[]</returns>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.GetBinaryLength">
            <summary>
            Returns the length of byte[] segment that is used as value.
            If Field is not binary returned value is undefined.
            </summary>
            <returns>length of byte[] segment that represents this Field value</returns>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.GetBinaryOffset">
            <summary>
            Returns offset into byte[] segment that is used as value.
            If Field is not binary returned value is undefined.
            </summary>
            <returns>index of the byte[] segment that represents this Field value</returns>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.GetOmitNorms">
            <summary>True if norms are omitted for this indexed field </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.GetOmitTf">
            <summary>
            Returns true if tf is omitted for this indexed field.
            </summary>
            <returns>true if tf is omitted for this indexed field</returns>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.SetOmitNorms(System.Boolean)">
            <summary>Expert:
            
            If set, omit normalization factors associated with this indexed field.
            This effectively disables indexing boosts and length normalization for this field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.SetOmitTf(System.Boolean)">
            <summary>
            Expert: If set, omit tf from postings of this indexed field.
            </summary>
            <param name="omitTf"></param>
        </member>
        <member name="M:Lucene.Net.Documents.AbstractField.ToString">
            <summary>Prints a Field for human consumption. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.WordlistLoader">
            <summary> Loader for text files that represent a list of stopwords.
            
            
            </summary>
            <version>  $Id: WordlistLoader.java 564236 2007-08-09 15:21:19Z gsingers $
            </version>
        </member>
        <member name="M:Lucene.Net.Analysis.WordlistLoader.GetWordSet(System.IO.FileInfo)">
            <summary> Loads a text file and adds every line as an entry to a HashSet (omitting
            leading and trailing whitespace). Every line of the file should contain only
            one word. The words need to be in lowercase if you make use of an
            Analyzer which uses LowerCaseFilter (like StandardAnalyzer).
            
            </summary>
            <param name="wordfile">File containing the wordlist
            </param>
            <returns> A HashSet with the file's words
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.WordlistLoader.GetWordSet(System.IO.TextReader)">
            <summary> Reads lines from a Reader and adds every line as an entry to a HashSet (omitting
            leading and trailing whitespace). Every line of the Reader should contain only
            one word. The words need to be in lowercase if you make use of an
            Analyzer which uses LowerCaseFilter (like StandardAnalyzer).
            
            </summary>
            <param name="reader">Reader containing the wordlist
            </param>
            <returns> A HashSet with the reader's words
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.WordlistLoader.GetStemDict(System.IO.FileInfo)">
            <summary> Reads a stem dictionary. Each line contains:
            <pre>word<b>\t</b>stem</pre>
            (i.e. two tab seperated words)
            
            </summary>
            <returns> stem dictionary that overrules the stemming algorithm
            </returns>
            <throws>  IOException  </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.PorterStemFilter" -->
        <member name="T:Lucene.Net.Util.CloseableThreadLocal">
            Java's builtin ThreadLocal has a serious flaw:
              it can take an arbitrarily long amount of time to
              dereference the things you had stored in it, even once the
              ThreadLocal instance itself is no longer referenced.
              This is because there is single, master map stored for
              each thread, which all ThreadLocals share, and that
              master map only periodically purges "stale" entries.
            
              While not technically a memory leak, because eventually
              the memory will be reclaimed, it can take a long time
              and you can easily hit OutOfMemoryError because from the
              GC's standpoint the stale entries are not reclaimaible.
             
              This class works around that, by only enrolling
              WeakReference values into the ThreadLocal, and
              separately holding a hard reference to each stored
              value.  When you call {@link #close}, these hard
              references are cleared and then GC is freely able to
              reclaim space by objects stored in it.
        </member>
        <member name="T:Lucene.Net.Util.BitVector">
            <summary>Optimized implementation of a vector of bits.  This is more-or-less like
            java.util.BitSet, but also includes the following:
            <ul>
            <li>a count() method, which efficiently computes the number of one bits;</li>
            <li>optimized read from and write to disk;</li>
            <li>inlinable get() method;</li>
            <li>store and load, as bit set or d-gaps, depending on sparseness;</li> 
            </ul>
            </summary>
            <version>  $Id: BitVector.java 564236 2007-08-09 15:21:19Z gsingers $
            </version>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.#ctor(System.Int32)">
            <summary>Constructs a vector capable of holding <code>n</code> bits. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Set(System.Int32)">
            <summary>Sets the value of <code>bit</code> to one. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Clear(System.Int32)">
            <summary>Sets the value of <code>bit</code> to zero. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.GetAndSet(System.Int32)">
            <summary>
            Sets the value of bit to true and returns true if bit was already set.
            </summary>
            <param name="bit"></param>
            <returns>true if bit was already set</returns>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Get(System.Int32)">
            <summary>Returns <code>true</code> if <code>bit</code> is one and
            <code>false</code> if it is zero. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Size">
            <summary>Returns the number of bits in this vector.  This is also one greater than
            the number of the largest valid bit number. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Count">
            <summary>Returns the total number of one bits in this vector.  This is efficiently
            computed and cached, so that, if the vector is not changed, no
            recomputation is done for repeated calls. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.Write(Lucene.Net.Store.Directory,System.String)">
            <summary>Writes this vector to the file <code>name</code> in Directory
            <code>d</code>, in a format that can be read by the constructor {@link
            #BitVector(Directory, String)}.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.WriteBits(Lucene.Net.Store.IndexOutput)">
            <summary>Write as a bit set </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.WriteDgaps(Lucene.Net.Store.IndexOutput)">
            <summary>Write as a d-gaps list </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.IsSparse">
            <summary>Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary>Constructs a bit vector from the file <code>name</code> in Directory
            <code>d</code>, as written by the {@link #write} method.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.ReadBits(Lucene.Net.Store.IndexInput)">
            <summary>Read as a bit set </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitVector.ReadDgaps(Lucene.Net.Store.IndexInput)">
            <summary>read as a d-gaps list </summary>
        </member>
        <member name="T:Lucene.Net.Store.LockObtainFailedException">
            <summary> This exception is thrown when the <code>write.lock</code>
            could not be acquired.  This
            happens when a writer tries to open an index
            that another writer already has open.
            </summary>
            <seealso cref="!:Lock.obtain(long).">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Store.ChecksumIndexOutput">
            Writes bytes through to a primary IndexOutput, computing
            checksum.  Note that you cannot use seek().
        </member>
        <member name="M:Lucene.Net.Store.ChecksumIndexOutput.PrepareCommit">
            Starts but does not complete the commit of this file (=
            writing of the final checksum at the end).  After this
            is called must call {@link #finishCommit} and the
            {@link #close} to complete the commit.
        </member>
        <member name="M:Lucene.Net.Store.ChecksumIndexOutput.FinishCommit">
            See {@link #prepareCommit} 
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.WildcardTermEnum" -->
        <member name="F:Lucene.Net.Search.WildcardTermEnum.WILDCARD_STRING">
            <summary>*****************************************
            String equality with support for wildcards
            ******************************************
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.WildcardTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Search.WildcardTermEnum.WildcardEquals(System.String,System.Int32,System.String,System.Int32)">
            <summary> Determines if a word matches a wildcard pattern.
            <small>Work released by Granta Design Ltd after originally being done on
            company time.</small>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.SortField">
            <summary> Stores information about how to sort documents by terms in an individual
            field.  Fields must be indexed in order to sort by them.
            </summary>
            <since>   lucene 1.4
            </since>
            <version>  $Id: SortField.java 598296 2007-11-26 14:52:01Z mikemccand $
            </version>
            <seealso cref="T:Lucene.Net.Search.Sort">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.SortField.SCORE">
            <summary>Sort by document score (relevancy).  Sort values are Float and higher
            values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.DOC">
            <summary>Sort by document number (index order).  Sort values are Integer and lower
            values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.AUTO">
            <summary>Guess type of sort based on field contents.  A regular expression is used
            to look at the first term indexed for the field and determine if it
            represents an integer number, a floating point number, or just arbitrary
            string characters. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.STRING">
            <summary>Sort using term values as Strings.  Sort values are String and lower
            values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.INT">
            <summary>Sort using term values as encoded Integers.  Sort values are Integer and
            lower values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FLOAT">
            <summary>Sort using term values as encoded Floats.  Sort values are Float and
            lower values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.LONG">
            <summary>Sort using term values as encoded Longs.  Sort values are Long and
            lower values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.DOUBLE">
            <summary>Sort using term values as encoded Doubles.  Sort values are Double and
            lower values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.SHORT">
            <summary>
            Sort using term values as encoded shorts.
            Sort values are shorts and lower values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.CUSTOM">
            <summary>Sort using a custom Comparator.  Sort values are any Comparable and
            sorting is done according to natural order. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.BYTE">
            <summary>
            Sort using term values as encoded bytes.
            Sort values are bytes and lower values are at the front. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FIELD_SCORE">
            <summary>Represents sorting by document score (relevancy). </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FIELD_DOC">
            <summary>Represents sorting by document number (index order). </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String)">
            <summary>Creates a sort by terms in the given field where the type of term value
            is determined dynamically ({@link #AUTO AUTO}).
            </summary>
            <param name="field">Name of field to sort by, cannot be <code>null</code>.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, by terms in the given field where
            the type of term value is determined dynamically ({@link #AUTO AUTO}).
            </summary>
            <param name="field">Name of field to sort by, cannot be <code>null</code>.
            </param>
            <param name="reverse">True if natural order should be reversed.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Int32)">
            <summary>Creates a sort by terms in the given field with the type of term
            values explicitly given.
            </summary>
            <param name="field"> Name of field to sort by.  Can be <code>null</code> if
            <code>type</code> is SCORE or DOC.
            </param>
            <param name="type">  Type of values in the terms.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Int32,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, by terms in the given field with the
            type of term values explicitly given.
            </summary>
            <param name="field"> Name of field to sort by.  Can be <code>null</code> if
            <code>type</code> is SCORE or DOC.
            </param>
            <param name="type">  Type of values in the terms.
            </param>
            <param name="reverse">True if natural order should be reversed.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Globalization.CultureInfo)">
            <summary>Creates a sort by terms in the given field sorted
            according to the given locale.
            </summary>
            <param name="field"> Name of field to sort by, cannot be <code>null</code>.
            </param>
            <param name="locale">Locale of values in the field.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,System.Globalization.CultureInfo,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, by terms in the given field sorted
            according to the given locale.
            </summary>
            <param name="field"> Name of field to sort by, cannot be <code>null</code>.
            </param>
            <param name="locale">Locale of values in the field.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.SortComparatorSource)">
            <summary>Creates a sort with a custom comparison function.</summary>
            <param name="field">Name of field to sort by; cannot be <code>null</code>.
            </param>
            <param name="comparator">Returns a comparator for sorting hits.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.SortComparatorSource,System.Boolean)">
            <summary>Creates a sort, possibly in reverse, with a custom comparison function.</summary>
            <param name="field">Name of field to sort by; cannot be <code>null</code>.
            </param>
            <param name="comparator">Returns a comparator for sorting hits.
            </param>
            <param name="reverse">True if natural order should be reversed.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetField">
            <summary>Returns the name of the field.  Could return <code>null</code>
            if the sort is by SCORE or DOC.
            </summary>
            <returns> Name of field, possibly <code>null</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetType">
            <summary>Returns the type of contents in the field.</summary>
            <returns> One of the constants SCORE, DOC, AUTO, STRING, INT or FLOAT.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetLocale">
            <summary>Returns the Locale by which term values are interpreted.
            May return <code>null</code> if no Locale was specified.
            </summary>
            <returns> Locale, or <code>null</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetReverse">
            <summary>Returns whether the sort should be reversed.</summary>
            <returns>  True if natural order should be reversed.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.PhraseQuery" -->
        <member name="M:Lucene.Net.Search.PhraseQuery.#ctor">
            <summary>Constructs an empty phrase query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.PhraseQuery.SetSlop(System.Int32)" -->
        <member name="M:Lucene.Net.Search.PhraseQuery.GetSlop">
            <summary>Returns the slop.  See setSlop(). </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term)">
            <summary> Adds a term to the end of the query phrase.
            The relative position of the term is the one immediately after the last term added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term,System.Int32)">
            <summary> Adds a term to the end of the query phrase.
            The relative position of the term within the phrase is specified explicitly.
            This allows e.g. phrases with more than one term at the same position
            or phrases with gaps (e.g. in connection with stopwords).
            
            </summary>
            <param name="">term
            </param>
            <param name="">position
            </param>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetTerms">
            <summary>Returns the set of terms in this phrase. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetPositions">
            <summary> Returns the relative positions of terms in this phrase.</summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.ExtractTerms(System.Collections.Hashtable)">
            <seealso cref="!:Lucene.Net.Search.Query#ExtractTerms(java.util.Set)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.FuzzyQuery">
            <summary>Implements the fuzzy search query. The similiarity measurement
            is based on the Levenshtein (edit distance) algorithm.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Single,System.Int32)">
            <summary> Create a new FuzzyQuery that will match terms with a similarity 
            of at least <code>minimumSimilarity</code> to <code>term</code>.
            If a <code>prefixLength</code> &gt; 0 is specified, a common prefix
            of that length is also required.
            
            </summary>
            <param name="term">the term to search for
            </param>
            <param name="minimumSimilarity">a value between 0 and 1 to set the required similarity
            between the query term and the matching terms. For example, for a
            <code>minimumSimilarity</code> of <code>0.5</code> a term of the same length
            as the query term is considered similar to the query term if the edit distance
            between both terms is less than <code>length(term)*0.5</code>
            </param>
            <param name="prefixLength">length of common (non-fuzzy) prefix
            </param>
            <throws>  IllegalArgumentException if minimumSimilarity is &gt;= 1 or &lt; 0 </throws>
            <summary> or if prefixLength &lt; 0
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Single)">
            <summary> Calls {@link #FuzzyQuery(Term, float) FuzzyQuery(term, minimumSimilarity, 0)}.</summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term)">
            <summary> Calls {@link #FuzzyQuery(Term, float) FuzzyQuery(term, 0.5f, 0)}.</summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.GetMinSimilarity">
            <summary> Returns the minimum similarity that is required for this query to match.</summary>
            <returns> float value between 0.0 and 1.0
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.GetPrefixLength">
            <summary> Returns the non-fuzzy prefix length. This is the number of characters at the start
            of a term that must be identical (not fuzzy) to the query term if the query
            is to match that term. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.ReverseOrdFieldSource" -->
        <member name="M:Lucene.Net.Search.Function.ReverseOrdFieldSource.#ctor(System.String)">
            <summary> Contructor for a certain field.</summary>
            <param name="field">field whose values reverse order is used.  
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.IntFieldSource" -->
        <member name="M:Lucene.Net.Search.Function.IntFieldSource.#ctor(System.String)">
            <summary> Create a cached int field source with default string-to-int parser. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.IntFieldSource.#ctor(System.String,Lucene.Net.Search.IntParser)">
            <summary> Create a cached int field source with a specific string-to-int parser. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.FieldScoreQuery" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.ValueSourceQuery" -->
        <member name="M:Lucene.Net.Search.Function.ValueSourceQuery.#ctor(Lucene.Net.Search.Function.ValueSource)">
            <summary> Create a value source query</summary>
            <param name="valSrc">provides the values defines the function to be used for scoring
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Function.ValueSourceQuery.Equals(System.Object)">
            <summary>Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.ValueSourceQuery.GetHashCode">
            <summary>Returns a hash code value for this object. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Function.ValueSourceQuery.ValueSourceScorer">
            <summary> A scorer that (simply) matches all documents, and scores each document with 
            the value of the value soure in effect. As an example, if the value source 
            is a (cached) field source, then value of that field in that document will 
            be used. (assuming field is indexed for this doc, with a single token.)   
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.FieldScoreQuery.#ctor(System.String,Lucene.Net.Search.Function.FieldScoreQuery.Type)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.FieldScoreQuery.Type" -->
        <member name="F:Lucene.Net.Search.Function.FieldScoreQuery.Type.BYTE">
            <summary>field values are interpreted as numeric byte values. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Function.FieldScoreQuery.Type.SHORT">
            <summary>field values are interpreted as numeric short values. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Function.FieldScoreQuery.Type.INT">
            <summary>field values are interpreted as numeric int values. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Function.FieldScoreQuery.Type.FLOAT">
            <summary>field values are interpreted as numeric float values. </summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.ParseException">
            <summary> This exception is thrown when parse errors are encountered.
            You can explicitly create objects of this exception type by
            calling the method generateParseException in the generated
            parser.
            
            You can modify this class to customize your error reporting
            mechanisms so long as you retain the public fields.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.QueryParsers.ParseException.#ctor(Lucene.Net.QueryParsers.Token,System.Int32[][],System.String[])" -->
        <member name="M:Lucene.Net.QueryParsers.ParseException.#ctor">
            <summary> The following constructors are for use by you for whatever
            purpose you can think of.  Constructing the exception in this
            manner makes the exception behave in the normal way - i.e., as
            documented in the class "Throwable".  The fields "errorToken",
            "expectedTokenSequences", and "tokenImage" do not contain
            relevant information.  The JavaCC generated code does not use
            these constructors.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.ParseException.#ctor(System.String)">
            <summary>
            Constructor with message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.specialConstructor">
            <summary> This variable determines which constructor was used to create
            this object and thereby affects the semantics of the
            "getMessage" method (see below).
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.currentToken">
            <summary> This is the last token that has been consumed successfully.  If
            this object has been created due to a parse error, the token
            followng this token will (therefore) be the first error token.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.expectedTokenSequences">
            <summary> Each entry in this array is an array of integers.  Each array
            of integers represents a sequence of tokens (by their ordinal
            values) that is expected at this point of the parse.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.tokenImage">
            <summary> This is a reference to the "tokenImage" array of the generated
            parser within which the parse error occurred.  This array is
            defined in the generated ...Constants interface.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.ParseException.eol">
            <summary> The end of line string for this machine.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.ParseException.Add_escapes(System.String)">
            <summary> Used to convert raw characters to their escaped version
            when these raw version cannot be used as part of an ASCII
            string literal.
            </summary>
        </member>
        <member name="P:Lucene.Net.QueryParsers.ParseException.Message">
            <summary> This method has the standard behavior when this object has been
            created using the standard constructors.  Otherwise, it uses
            "currentToken" and "expectedTokenSequences" to generate a parse
            error message and returns it.  If this object has been created
            due to a parse error, and you do not catch it (it gets thrown
            from the parser), then this method is called during the printing
            of the final stack trace, and hence the correct error message
            gets displayed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermVectorEntryFreqSortedComparator">
            <summary> Compares {@link Lucene.Net.Index.TermVectorEntry}s first by frequency and then by
            the term (case-sensitive)
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermBuffer.SetPreUTF8Strings">
            <summary>
            Call this if the IndexInput passed to Read() stores terms
            in the modified UTF-8 (pre-LUCENE-510) format.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.NormsWriter">
            Writes norms.  Each thread X field accumulates the norms
            for the doc/fields it saw, then the flush method below
            merges all of these together into a single _X.nrm file.
        </member>
        <member name="M:Lucene.Net.Index.NormsWriter.flush(System.Collections.Generic.IDictionary{System.Object,System.Collections.Generic.ICollection{System.Object}},Lucene.Net.Index.DocumentsWriter.FlushState)">
            Produce _X.nrm if any document had a field with norms
            not disabled 
        </member>
        <member name="T:Lucene.Net.Index.FieldSortedTermVectorMapper">
            <summary> For each Field, store a sorted collection of {@link TermVectorEntry}s
            <p/>
            This is not thread-safe.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldSortedTermVectorMapper.#ctor(System.Collections.Generic.IComparer{System.Object})">
            <summary> </summary>
            <param name="comparator">A Comparator for sorting {@link TermVectorEntry}s
            </param>
        </member>
        <member name="M:Lucene.Net.Index.FieldSortedTermVectorMapper.GetFieldToTerms">
            <summary> Get the mapping between fields and terms, sorted by the comparator
            
            </summary>
            <returns> A map between field names and {@link java.util.SortedSet}s per field.  SortedSet entries are {@link TermVectorEntry}
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.DefaultSkipListWriter">
            <summary> Implements the skip list writer for the default posting list format
            that stores positions and payloads.
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DefaultSkipListWriter.SetSkipData(System.Int32,System.Boolean,System.Int32)">
            <summary> Sets the values for the current skip data. </summary>
        </member>
        <member name="T:Lucene.Net.Index.DefaultSkipListReader">
            <summary> Implements the skip list reader for the default posting list format
            that stores positions and payloads.
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DefaultSkipListReader.GetFreqPointer">
            <summary>Returns the freq pointer of the doc to which the last call of 
            {@link MultiLevelSkipListReader#SkipTo(int)} has skipped.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DefaultSkipListReader.GetProxPointer">
            <summary>Returns the prox pointer of the doc to which the last call of 
            {@link MultiLevelSkipListReader#SkipTo(int)} has skipped.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DefaultSkipListReader.GetPayloadLength">
            <summary>Returns the payload length of the payload stored just before 
            the doc to which the last call of {@link MultiLevelSkipListReader#SkipTo(int)} 
            has skipped.  
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Constants">
            <summary> Some useful constants.
            
            
            </summary>
            <version>  $Id: Constants.java 564236 2007-08-09 15:21:19Z gsingers $
            
            </version>
        </member>
        <member name="F:Lucene.Net.Util.Constants.DOTNET_VERSION">
            <summary>Lucene.Net Runtime version</summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.DOTNET_VERSION_1_0">
            <summary>True iff Lucene.Net Runtime version is 1.0</summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.DOTNET_VERSION_1_1">
            <summary>True iff Lucene.Net Runtime version is 1.1</summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.DOTNET_VERSION_2_0">
            <summary>True iff Lucene.Net Runtime version is 2.0</summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.DOTNET_VERSION_3_0">
            <summary>True iff Lucene.Net Runtime version is 3.0</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.Constants.OS_NAME" -->
        <member name="F:Lucene.Net.Util.Constants.LINUX">
            <summary>True iff running on Linux. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.WINDOWS">
            <summary>True iff running on Windows. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.SUN_OS">
            <summary>True iff running on SunOS. </summary>
        </member>
        <member name="T:Lucene.Net.Store.SingleInstanceLockFactory">
            <summary> Implements {@link LockFactory} for a single in-process instance,
            meaning all locking will take place through this one instance.
            Only use this {@link LockFactory} when you are certain all
            IndexReaders and IndexWriters for a given index are running
            against a single shared in-process Directory instance.  This is
            currently the default locking for RAMDirectory.
            
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockFactory">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ReqOptSumScorer" -->
        <member name="F:Lucene.Net.Search.ReqOptSumScorer.reqScorer">
            <summary>The scorers passed from the constructor.
            These are set to null as soon as their next() or skipTo() returns false.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.#ctor(Lucene.Net.Search.Scorer,Lucene.Net.Search.Scorer)">
            <summary>Construct a <code>ReqOptScorer</code>.</summary>
            <param name="reqScorer">The required scorer. This must match.
            </param>
            <param name="optScorer">The optional scorer. This is used for scoring only.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.Score">
            <summary>Returns the score of the current document matching the query.
            Initially invalid, until {@link #next()} is called the first time.
            </summary>
            <returns> The score of the required scorer, eventually increased by the score
            of the optional scorer when it also matches the current document.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.Explain(System.Int32)">
            <summary>Explain the score of a document.</summary>
            <todo>  Also show the total score. </todo>
            <summary> See BooleanScorer.explain() on how to do this.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Payloads.BoostingTermQuery" -->
        <member name="T:Lucene.Net.Search.Spans.SpanTermQuery">
            <summary>Matches spans containing a term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Construct a SpanTermQuery matching the named term's spans. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.GetTerm">
            <summary>Return the term whose spans are matched. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.GetTerms">
            <summary>Returns a collection of all terms matched by this query.</summary>
            <deprecated> use extractTerms instead
            </deprecated>
            <seealso cref="!:#ExtractTerms(Set)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanWeight">
            <summary> Expert-only.  Public for use by other weight implementations</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermsHashPerField.sortPostings" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermsHashPerField.comparePostings(Lucene.Net.Index.RawPostingList,Lucene.Net.Index.RawPostingList)" -->
        <member name="M:Lucene.Net.Index.TermsHashPerField.postingEquals(System.Char[],System.Int32)">
            Test whether the text for current RawPostingList p equals
            current tokenText. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermsHashPerField.rehashPostings(System.Int32)" -->
        <member name="M:Lucene.Net.Index.SegmentTermPositions.SkipProx(System.Int64,System.Int32)">
            <summary>Called by super.skipTo(). </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiReader">
            <summary>An IndexReader which reads multiple indexes, appending their content.
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.#ctor(Lucene.Net.Index.IndexReader[])">
            <summary> <p>Construct a MultiReader aggregating the named set of (sub)readers.
            Directory locking for delete, undeleteAll, and setNorm operations is
            left to the subreaders. </p>
            <p>Note that all subreaders are closed if this Multireader is closed.</p>
            </summary>
            <param name="subReaders">set of (sub)readers
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.#ctor(Lucene.Net.Index.IndexReader[],System.Boolean)">
            <summary> <p>Construct a MultiReader aggregating the named set of (sub)readers.
            Directory locking for delete, undeleteAll, and setNorm operations is
            left to the subreaders. </p>
            </summary>
            <param name="closeSubReaders">indicates whether the subreaders should be closed
            when this MultiReader is closed
            </param>
            <param name="subReaders">set of (sub)readers
            </param>
            <throws>  IOException </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiReader.Reopen" -->
        <member name="M:Lucene.Net.Index.MultiReader.IsCurrent">
            <summary> Checks recursively if all subreaders are up to date. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiReader.GetVersion">
            <summary>Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy">
            <summary> <p>Expert: a MergePolicy determines the sequence of
            primitive merge operations to be used for overall merge
            and optimize operations.</p>
            
            <p>Whenever the segments in an index have been altered by
            {@link IndexWriter}, either the addition of a newly
            flushed segment, addition of many segments from
            addIndexes* calls, or a previous merge that may now need
            to cascade, {@link IndexWriter} invokes {@link
            #findMerges} to give the MergePolicy a chance to pick
            merges that are now required.  This method returns a
            {@link MergeSpecification} instance describing the set of
            merges that should be done, or null if no merges are
            necessary.  When IndexWriter.optimize is called, it calls
            {@link #findMergesForOptimize} and the MergePolicy should
            then return the necessary merges.</p>
            
            <p>Note that the policy can return more than one merge at
            a time.  In this case, if the writer is using {@link
            SerialMergeScheduler}, the merges will be run
            sequentially but if it is using {@link
            ConcurrentMergeScheduler} they will be run concurrently.</p>
            
            <p>The default MergePolicy is {@link
            LogByteSizeMergePolicy}.</p>
            <p><b>NOTE:</b> This API is new and still experimental
            (subject to change suddenly in the next release)</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.FindMerges(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.IndexWriter)">
            <summary> Determine what set of merge operations are now
            necessary on the index.  The IndexWriter calls this
            whenever there is a change to the segments.  This call
            is always synchronized on the IndexWriter instance so
            only one thread at a time will call this method.
            
            </summary>
            <param name="segmentInfos">the total set of segments in the index
            </param>
            <param name="writer">IndexWriter instance
            </param>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.FindMergesForOptimize(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.IndexWriter,System.Int32,System.Collections.Generic.Dictionary{Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.SegmentInfo})">
            <summary> Determine what set of merge operations are necessary in
            order to optimize the index.  The IndexWriter calls
            this when its optimize() method is called.  This call
            is always synchronized on the IndexWriter instance so
            only one thread at a time will call this method.
            
            </summary>
            <param name="segmentInfos">the total set of segments in the index
            </param>
            <param name="writer">IndexWriter instance
            </param>
            <param name="maxSegmentCount">requested maximum number of
            segments in the index (currently this is always 1)
            </param>
            <param name="segmentsToOptimize">contains the specific
            SegmentInfo instances that must be merged away.  This
            may be a subset of all SegmentInfos.
            </param>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.FindMergesToExpungeDeletes(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.IndexWriter)">
            <summary>
            Determine what set of merge operations is necessary in
            order to expunge all deletes from the index.
            </summary>
            <param name="segmentInfos"></param>
            <param name="writer"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.Close">
            <summary> Release all resources for the policy.</summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.UseCompoundFile(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.SegmentInfo)">
            <summary> Returns true if a newly flushed (not from merge)
            segment should use the compound file format.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.UseCompoundDocStore(Lucene.Net.Index.SegmentInfos)">
            <summary> Returns true if the doc store files should use the
            compound file format.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.OneMerge">
            <summary>OneMerge provides the information necessary to perform
            an individual primitive merge operation, resulting in
            a single new segment.  The merge spec includes the
            subset of segments to be merged as well as whether the
            new segment should use the compound file format. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.SetException(System.Exception)">
            <summary>Record that an exception occurred while executing
            this merge 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.GetException">
            <summary>Retrieve previous exception set by {@link
            #setException}. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.Abort">
            <summary>Mark this merge as aborted.  If this is called
            before the merge is committed then the merge will
            not be committed. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.IsAborted">
            <summary>Returns true if this merge was aborted. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.MergeSpecification">
            <summary> A MergeSpecification instance provides the information
            necessary to perform multiple merges.  It simply
            contains a list of {@link OneMerge} instances.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.MergeSpecification.merges">
            <summary> The subset of segments to be included in the primitive merge.</summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.MergeException">
            <summary>Exception thrown if there are any problems while
            executing a merge. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeException.GetDirectory">
            <summary>
            Returns the Directory of the index that hit the exception.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy">
            <summary> This {@link IndexDeletionPolicy} implementation that
            keeps only the most recent commit and immediately removes
            all prior commits after a new commit is done.  This is
            the default deletion policy.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.OnInit(System.Collections.Generic.List{Lucene.Net.Index.IndexCommitPoint})">
            <summary> Deletes all commits except the most recent one.</summary>
        </member>
        <member name="M:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.OnCommit(System.Collections.Generic.List{Lucene.Net.Index.IndexCommitPoint})">
            <summary> Deletes all commits except the most recent one.</summary>
        </member>
        <member name="T:Lucene.Net.Index.DocInverter">
            <summary>
            This is a DocFieldConsumer that inverts each field,
            separately, from a Document, and accepts a
            InvertedTermsConsumer to process those terms.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocConsumerPerThread.processDocument">
            <summary>
            Process the document. If there is
            something for this document to be done in docID order,
            you should encapsulate that as a
            DocumentsWriter.DocWriter and return it.
            DocumentsWriter then calls finish() on this object
            when it's its turn.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldProcessorPerThread.trimFields(Lucene.Net.Index.DocumentsWriter.FlushState)">
            <summary>
            If there are fields we've seen but did not see again in the last run, then free them up.
            </summary>
            <param name="state"></param>
        </member>
        <member name="T:Lucene.Net.Index.CorruptIndexException">
            <summary> This exception is thrown when Lucene detects
            an inconsistency in the index.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldDocs">
            <summary> Expert: Returned by low-level sorted search implementations.
            </summary>
            <since>   lucene 1.4
            </since>
            <version>  $Id: TopFieldDocs.java 472959 2006-11-09 16:21:50Z yonik $
            </version>
            <seealso cref="!:Searcher#Search(Query,Filter,int,Sort)">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.TopFieldDocs.fields">
            <summary>The fields which were used to sort results by. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopFieldDocs.#ctor(System.Int32,Lucene.Net.Search.ScoreDoc[],Lucene.Net.Search.SortField[],System.Single)">
            <summary>Creates one of these objects.</summary>
            <param name="totalHits"> Total number of hits for the query.
            </param>
            <param name="scoreDocs"> The top hits for the query.
            </param>
            <param name="fields">    The sort criteria used to find the top hits.
            </param>
            <param name="maxScore">  The maximum score encountered.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.IndexSearcher" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(System.String)">
            <summary>Creates a searcher searching the index in the named directory.</summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Store.Directory)">
            <summary>Creates a searcher searching the index in the provided directory.</summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReader)">
            <summary>Creates a searcher searching the provided index. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.GetIndexReader">
            <summary>Return the {@link IndexReader} this searches. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Close">
            <summary> Note that the underlying IndexReader is not closed, if
            IndexSearcher was constructed with IndexSearcher(IndexReader r).
            If the IndexReader was supplied implicitly by specifying a directory, then
            the IndexReader gets closed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.HitIterator">
            <summary>
            An iterator over {@link Hits} that provides lazy fetching of each document.
            {@link Hits#Iterator()} returns an instance of this class.  Calls to {@link #Next()}
            return a {@link Hit} instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.HitIterator.#ctor(Lucene.Net.Search.Hits)">
            <summary> Constructed from {@link Hits#Iterator()}.</summary>
        </member>
        <member name="M:Lucene.Net.Search.HitIterator.MoveNext">
            <returns> true if current hit is less than the total number of {@link Hits}.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.HitIterator.Remove">
            <summary> Unsupported operation.
            
            </summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="M:Lucene.Net.Search.HitIterator.Length">
            <summary> Returns the total number of hits.</summary>
        </member>
        <member name="P:Lucene.Net.Search.HitIterator.Current">
            <summary> Returns a {@link Hit} instance representing the next hit in {@link Hits}.
            
            </summary>
            <returns> Next {@link Hit}.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.OrdFieldSource" -->
        <member name="M:Lucene.Net.Search.Function.OrdFieldSource.#ctor(System.String)">
            <summary> Contructor for a certain field.</summary>
            <param name="field">field whose values order is used.  
            </param>
        </member>
        <member name="T:Lucene.Net.Search.FieldSortedHitQueue">
            <summary> Expert: A hit queue for sorting by hits by terms in more than one field.
            Uses <code>FieldCache.DEFAULT</code> for maintaining internal term lookup tables.
            </summary>
            <since>   lucene 1.4
            </since>
            <version>  $Id: FieldSortedHitQueue.java 605225 2007-12-18 15:13:05Z gsingers $
            </version>
            <seealso cref="M:Lucene.Net.Search.Searcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)">
            </seealso>
            <seealso cref="T:Lucene.Net.Search.FieldCache">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Search.SortField[],System.Int32)">
            <summary> Creates a hit queue sorted by the given list of fields.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fields">Fieldable names, in priority order (highest priority first).  Cannot be <code>null</code> or empty.
            </param>
            <param name="size"> The number of hits to retain.  Must be greater than zero.
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.comparators">
            <summary>Stores a comparator corresponding to each field being sorted by </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.fields">
            <summary>Stores the sort criteria being used. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.maxscore">
            <summary>Stores the maximum score value encountered, needed for normalizing. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.GetMaxScore">
            <summary>returns the maximum score encountered by elements inserted via insert()</summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.LessThan(System.Object,System.Object)">
            <summary> Returns whether <code>a</code> is less relevant than <code>b</code>.</summary>
            <param name="a">ScoreDoc
            </param>
            <param name="b">ScoreDoc
            </param>
            <returns> <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.FillFields(Lucene.Net.Search.FieldDoc)">
            <summary> Given a FieldDoc object, stores the values used
            to sort the given document.  These values are not the raw
            values out of the index, but the internal representation
            of them.  This is so the given search hit can be collated
            by a MultiSearcher with other search hits.
            </summary>
            <param name="doc"> The FieldDoc to store sort values into.
            </param>
            <returns>  The same FieldDoc passed in.
            </returns>
            <seealso cref="M:Lucene.Net.Search.Searchable.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.GetFields">
            <summary>Returns the SortFields being used by this hit queue. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldSortedHitQueue.Comparators">
            <summary>Internal cache of comparators. Similar to FieldCache, only
            caches comparators instead of term values. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorInt(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a field containing integers.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Fieldable containg integer values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorLong(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a field containing integers.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Fieldable containg integer values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorFloat(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a field containing floats.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Fieldable containg float values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorDouble(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a field containing doubles.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Fieldable containg float values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorShort(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a field containing shorts.</summary>
            <param name="reader"> Index to use.</param>
            <param name="fieldname"> Fieldable containg short values.</param>
            <returns>  Comparator for sorting hits.</returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorByte(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a field containing bytes.</summary>
            <param name="reader"> Index to use.</param>
            <param name="fieldname"> Fieldable containg byte values.</param>
            <returns>  Comparator for sorting hits.</returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorString(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to a field containing strings.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Fieldable containg string values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorStringLocale(Lucene.Net.Index.IndexReader,System.String,System.Globalization.CultureInfo)">
            <summary> Returns a comparator for sorting hits according to a field containing strings.</summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Fieldable containg string values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="M:Lucene.Net.Search.FieldSortedHitQueue.ComparatorAuto(Lucene.Net.Index.IndexReader,System.String)">
            <summary> Returns a comparator for sorting hits according to values in the given field.
            The terms in the field are looked at to determine whether they contain integers,
            floats or strings.  Once the type is determined, one of the other static methods
            in this class is called to get the comparator.
            </summary>
            <param name="reader"> Index to use.
            </param>
            <param name="fieldname"> Fieldable containg values.
            </param>
            <returns>  Comparator for sorting hits.
            </returns>
            <throws>  IOException If an error occurs reading the index. </throws>
        </member>
        <member name="T:Lucene.Net.Search.DefaultSimilarity">
            <summary>Expert: Default scoring implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.LengthNorm(System.String,System.Int32)">
            <summary>Implemented as <code>1/sqrt(numTerms)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.QueryNorm(System.Single)">
            <summary>Implemented as <code>1/sqrt(sumOfSquaredWeights)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.Tf(System.Single)">
            <summary>Implemented as <code>sqrt(freq)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.SloppyFreq(System.Int32)">
            <summary>Implemented as <code>1 / (distance + 1)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.Idf(System.Int32,System.Int32)">
            <summary>Implemented as <code>log(numDocs/(docFreq+1)) + 1</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DefaultSimilarity.Coord(System.Int32,System.Int32)">
            <summary>Implemented as <code>overlap / maxOverlap</code>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ConstantScoreRangeQuery" -->
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.GetField">
            <summary>Returns the field name for this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.GetLowerVal">
            <summary>Returns the value of the lower endpoint of this range query, null if open ended </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.GetUpperVal">
            <summary>Returns the value of the upper endpoint of this range query, null if open ended </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.IncludesLower">
            <summary>Returns <code>true</code> if the lower endpoint is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.IncludesUpper">
            <summary>Returns <code>true</code> if the upper endpoint is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.Equals(System.Object)">
            <summary>Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreRangeQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanClause">
            <summary>A clause in a BooleanQuery. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.query">
            <summary>The query whose matching documents are combined by the boolean query.</summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.BooleanClause.Occur)">
            <summary>Constructs a BooleanClause.</summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanClause.Occur">
            <summary>Specifies how clauses are to occur in matching documents. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.Occur.MUST">
            <summary>Use this operator for clauses that <i>must</i> appear in the matching documents. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.Occur.SHOULD">
            <summary>Use this operator for clauses that <i>should</i> appear in the 
            matching documents. For a BooleanQuery with no <code>MUST</code> 
            clauses one or more <code>SHOULD</code> clauses must match a document 
            for the BooleanQuery to match.
            </summary>
            <seealso cref="!:BooleanQuery.setMinimumNumberShouldMatch">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.Occur.MUST_NOT">
            <summary>Use this operator for clauses that <i>must not</i> appear in the matching documents.
            Note that it is not possible to search for queries that only consist
            of a <code>MUST_NOT</code> clause. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.PositionBasedTermVectorMapper">
            <summary> For each Field, store position by position information.  It ignores frequency information
            <p/>
            This is not thread-safe.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.PositionBasedTermVectorMapper.currentPositions">
            <summary> A Map of Integer and TVPositionInfo</summary>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.#ctor">
            <summary> 
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.IsIgnoringPositions">
            <summary> Never ignores positions.  This mapper doesn't make much sense unless there are positions</summary>
            <returns> false
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.Map(System.String,System.Int32,Lucene.Net.Index.TermVectorOffsetInfo[],System.Int32[])">
            <summary> Callback for the TermVectorReader. </summary>
            <param name="term">
            </param>
            <param name="frequency">
            </param>
            <param name="offsets">
            </param>
            <param name="positions">
            </param>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.SetExpectations(System.String,System.Int32,System.Boolean,System.Boolean)">
            <summary> Callback mechanism used by the TermVectorReader</summary>
            <param name="field"> The field being read
            </param>
            <param name="numTerms">The number of terms in the vector
            </param>
            <param name="storeOffsets">Whether offsets are available
            </param>
            <param name="storePositions">Whether positions are available
            </param>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.GetFieldToTerms">
            <summary> Get the mapping between fields and terms, sorted by the comparator
            
            </summary>
            <returns> A map between field names and a Map.  The sub-Map key is the position as the integer, the value is {@link Lucene.Net.Index.PositionBasedTermVectorMapper.TVPositionInfo}.
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.PositionBasedTermVectorMapper.TVPositionInfo">
            <summary> Container for a term at a position</summary>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.TVPositionInfo.GetPosition">
            <summary> </summary>
            <returns> The position of the term
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.TVPositionInfo.GetTerms">
            <summary> Note, there may be multiple terms at the same position</summary>
            <returns> A List of Strings
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.PositionBasedTermVectorMapper.TVPositionInfo.GetOffsets">
            <summary> Parallel list (to {@link #GetTerms()}) of TermVectorOffsetInfo objects.  There may be multiple entries since there may be multiple terms at a position</summary>
            <returns> A List of TermVectorOffsetInfo objects, if offsets are store.
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.BufferedDeletes">
            <summary>
            Holds buffered deletes, by docID, term or query.  We
            hold two instances of this class: one for the deletes
            prior to the last flush, the other for deletes after
            the last flush.  This is so if we need to abort
            (discard all buffered docs) we can also discard the
            buffered deletes yet keep the deletes done during
            previously flushed segments.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.CharArraySet">
            <summary> A simple class that stores Strings as char[]'s in a
            hash table.  Note that this is not a general purpose
            class.  For example, it cannot remove items from the
            set, nor does it resize its hash table to be smaller,
            etc.  It is designed to be quick to test if a char[]
            is in the set without the necessity of converting it
            to a String first.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharArraySet.#ctor(System.Int32,System.Boolean)">
            <summary>Create set with enough capacity to hold startSize
            terms 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharArraySet.#ctor(System.Collections.ICollection,System.Boolean)">
            <summary>Create set from a Collection of char[] or String </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharArraySet.Contains(System.Char[],System.Int32,System.Int32)">
            <summary>true if the <code>len</code> chars of <code>text</code> starting at <code>off</code>
            are in the set 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharArraySet.Add(System.String)">
            <summary>Add this String into the set </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharArraySet.Add(System.Char[])">
            <summary>Add this char[] directly to the set.
            If ignoreCase is true for this Set, the text array will be directly modified.
            The user should never modify this text array after calling this method.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.CharArraySet.CharArraySetIterator" -->
        <member name="M:Lucene.Net.Analysis.CharArraySet.CharArraySetIterator.NextCharArray">
            <summary>do not modify the returned char[] </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Analysis.CharArraySet.CharArraySetIterator.Current" -->
        <member name="T:Lucene.Net.Analysis.CachingTokenFilter">
            <summary> This class can be used if the Tokens of a TokenStream
            are intended to be consumed more than once. It caches
            all Tokens locally in a List.
            
            CachingTokenFilter implements the optional method
            {@link TokenStream#Reset()}, which repositions the
            stream to the first Token. 
            
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.BitUtil">
            <summary>
            A variety of high efficiencly bit twiddling routines.
            (from org.apache.solr.util rev 555343)
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.pop(System.Int64)">
            Returns the number of bits set in the long 
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.pop_intersect(System.Int64[],System.Int64[],System.Int32,System.Int32)">
            Returns the popcount or cardinality of the two sets after an intersection.
            Neither array is modified.
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.pop_union(System.Int64[],System.Int64[],System.Int32,System.Int32)">
            Returns the popcount or cardinality of the union of two sets.
            Neither array is modified.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BitUtil.pop_andnot(System.Int64[],System.Int64[],System.Int32,System.Int32)" -->
        <member name="F:Lucene.Net.Util.BitUtil.ntzTable">
            table of number of trailing zeros in a byte 
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.ntz(System.Int64)">
            Returns number of trailing zeros in the 64 bit long value. 
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.ntz2(System.Int64)">
            returns 0 based index of first set bit
            (only works for x!=0)
            <br/> This is an alternate implementation of ntz()
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.ntz3(System.Int64)">
            returns 0 based index of first set bit
            <br/> This is an alternate implementation of ntz()
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.isPowerOfTwo(System.Int32)">
            returns true if v is a power of two or zero
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.isPowerOfTwo(System.Int64)">
            returns true if v is a power of two or zero
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.nextHighestPowerOfTwo(System.Int32)">
            returns the next highest power of two, or the current value if it's already a power of two or zero
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.nextHighestPowerOfTwo(System.Int64)">
            returns the next highest power of two, or the current value if it's already a power of two or zero
        </member>
        <member name="T:Lucene.Net.Store.RAMDirectory">
            <summary> A memory-resident {@link Directory} implementation.  Locking
            implementation is by default the {@link SingleInstanceLockFactory}
            but can be changed with {@link #setLockFactory}.
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor">
            <summary>Constructs an empty {@link Directory}. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Store.RAMDirectory.#ctor(Lucene.Net.Store.Directory)" -->
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor(System.IO.FileInfo)">
            <summary> Creates a new <code>RAMDirectory</code> instance from the {@link FSDirectory}.
            
            </summary>
            <param name="dir">a <code>File</code> specifying the index directory
            
            </param>
            <seealso cref="M:Lucene.Net.Store.RAMDirectory.#ctor(Lucene.Net.Store.Directory)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor(System.String)">
            <summary> Creates a new <code>RAMDirectory</code> instance from the {@link FSDirectory}.
            
            </summary>
            <param name="dir">a <code>String</code> specifying the full index directory path
            
            </param>
            <seealso cref="M:Lucene.Net.Store.RAMDirectory.#ctor(Lucene.Net.Store.Directory)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.List">
            <summary>Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileExists(System.String)">
            <summary>Returns true iff the named file exists in this directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileModified(System.String)">
            <summary>Returns the time the named file was last modified.</summary>
            <throws>  IOException if the file does not exist </throws>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.TouchFile(System.String)">
            <summary>Set the modified time of an existing file to now.</summary>
            <throws>  IOException if the file does not exist </throws>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileLength(System.String)">
            <summary>Returns the length in bytes of a file in the directory.</summary>
            <throws>  IOException if the file does not exist </throws>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.SizeInBytes">
            <summary>Return total size in bytes of all files in this
            directory.  This is currently quantized to
            RAMOutputStream.BUFFER_SIZE. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.DeleteFile(System.String)">
            <summary>Removes an existing file in the directory.</summary>
            <throws>  IOException if the file does not exist </throws>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.RenameFile(System.String,System.String)">
            <summary>Renames an existing file in the directory.</summary>
            <throws>  FileNotFoundException if from does not exist </throws>
            <deprecated>
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.CreateOutput(System.String)">
            <summary>Creates a new, empty file in the directory with the given name. Returns a stream writing this file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.OpenInput(System.String)">
            <summary>Returns a stream reading an existing file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.Close">
            <summary>Closes the store to future operations, releasing associated memory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.EnsureOpen">
            <throws>  AlreadyClosedException if this IndexReader is closed </throws>
        </member>
        <member name="T:Lucene.Net.Search.FilterManager">
            <summary> Filter caching singleton.  It can be used by {@link Lucene.Net.Search.RemoteCachingWrapperFilter}
            or just to save filters locally for reuse.
            This class makes it possble to cache Filters even when using RMI, as it
            keeps the cache on the seaercher side of the RMI connection.
            
            Also could be used as a persistent storage for any filter as long as the
            filter provides a proper hashCode(), as that is used as the key in the cache.
            
            The cache is periodically cleaned up from a separate thread to ensure the
            cache doesn't exceed the maximum size.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilterManager.DEFAULT_CACHE_CLEAN_SIZE">
            <summary>The default maximum number of Filters in the cache </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilterManager.DEFAULT_CACHE_SLEEP_TIME">
            <summary>The default frequency of cache clenup </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilterManager.cache">
            <summary>The cache itself </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilterManager.cacheCleanSize">
            <summary>Maximum allowed cache size </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilterManager.cleanSleepTime">
            <summary>Cache cleaning frequency </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilterManager.filterCleaner">
            <summary>Cache cleaner that runs in a separate thread </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilterManager.#ctor">
            <summary> Sets up the FilterManager singleton.</summary>
        </member>
        <member name="M:Lucene.Net.Search.FilterManager.SetCacheSize(System.Int32)">
            <summary> Sets the max size that cache should reach before it is cleaned up</summary>
            <param name="cacheCleanSize">maximum allowed cache size
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FilterManager.SetCleanThreadSleepTime(System.Int64)">
            <summary> Sets the cache cleaning frequency in milliseconds.</summary>
            <param name="cleanSleepTime">cleaning frequency in millioseconds
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FilterManager.GetFilter(Lucene.Net.Search.Filter)">
            <summary> Returns the cached version of the filter.  Allows the caller to pass up
            a small filter but this will keep a persistent version around and allow
            the caching filter to do its job.
            
            </summary>
            <param name="filter">The input filter
            </param>
            <returns> The cached version of the filter
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.FilterManager.FilterItem">
            <summary> Holds the filter and the last time the filter was used, to make LRU-based
            cache cleaning possible.
            TODO: Clean this up when we switch to Java 1.5
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilterManager.FilterCleaner">
            <summary> Keeps the cache from getting too big.
            If we were using Java 1.5, we could use LinkedHashMap and we would not need this thread
            to clean out the cache.
            
            The SortedSet sortedFilterItems is used only to sort the items from the cache,
            so when it's time to clean up we have the TreeSet sort the FilterItems by
            timestamp.
            
            Removes 1.5 * the numbers of items to make the cache smaller.
            For example:
            If cache clean size is 10, and the cache is at 15, we would remove (15 - 10) * 1.5 = 7.5 round up to 8.
            This way we clean the cache a bit more, and avoid having the cache cleaner having to do it frequently.
            </summary>
        </member>
        <member name="T:Lucene.Net.QueryParsers.Token">
            <summary> Describes the input token stream.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.kind">
            <summary> An integer that describes the kind of this token.  This numbering
            system is determined by JavaCCParser, and a table of these numbers is
            stored in the file ...Constants.java.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.beginLine">
            <summary>The line number of the first character of this Token.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.beginColumn">
            <summary>The column number of the first character of this Token.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.endLine">
            <summary>The line number of the last character of this Token.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.endColumn">
            <summary>The column number of the last character of this Token.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.image">
            <summary> The string image of the token.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.next">
            <summary> A reference to the next regular (non-special) token from the input
            stream.  If this is the last token from the input stream, or if the
            token manager has not read tokens beyond this one, this field is
            set to null.  This is true only if this token is also a regular
            token.  Otherwise, see below for a description of the contents of
            this field.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.Token.specialToken">
            <summary> This field is used to access special tokens that occur prior to this
            token, but after the immediately preceding regular (non-special) token.
            If there are no such special tokens, this field is set to null.
            When there are more than one such special token, this field refers
            to the last of these special tokens, which in turn refers to the next
            previous special token through its specialToken field, and so on
            until the first special token (whose specialToken field is null).
            The next fields of special tokens refer to other special tokens that
            immediately follow it (without an intervening regular token).  If there
            is no such token, this field is null.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Token.GetValue">
            <summary>
            An optional attribute value of the Token.
            Tokens which are not used as syntactic sugar will often contain
            meaningful values that will be used later on by the compiler or
            interpreter. This attribute value is often different from the image.
            Any subclass of Token that actually wants to return a non-null value can
            override this method as appropriate.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Token.#ctor">
            <summary>
            No-argument constructor
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Token.#ctor(System.Int32)">
            <summary>
            Constructs a new token for the specified Image.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Token.#ctor(System.Int32,System.String)">
            <summary>
            Constructs a new token for the specified Image and Kind.
            </summary>
            <param name="kind"></param>
            <param name="image"></param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Token.ToString">
            <summary> Returns the image.</summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.Token.NewToken(System.Int32,System.String)">
            <summary> Returns a new Token object, by default. However, if you want, you
            can create and return subclass objects based on the value of ofKind.
            Simply add the cases to the switch for all those special cases.
            For example, if you have a subclass of Token called IDToken that
            you want to create if ofKind is ID, simply add something like :
            
            case MyParserConstants.ID : return new IDToken(ofKind, image);
            
            to the following switch statement. Then you can cast matchedToken
            variable to the appropriate type and use it in your lexical actions.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultipleTermPositions">
            <summary> Describe class <code>MultipleTermPositions</code> here.
            </summary>
            <version>  1.0
            </version>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term[])">
            <summary> Creates a new <code>MultipleTermPositions</code> instance.
            
            </summary>
            <exception cref="!:"> IOException
            </exception>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Seek(Lucene.Net.Index.Term)">
            <summary> Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Seek(Lucene.Net.Index.TermEnum)">
            <summary> Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.Read(System.Int32[],System.Int32[])">
            <summary> Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.GetPayloadLength">
            <summary> Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.GetPayload(System.Byte[],System.Int32)">
            <summary> Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="M:Lucene.Net.Index.MultipleTermPositions.IsPayloadAvailable">
            <summary> </summary>
            <returns> false
            </returns>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileDeleter.VERBOSE_REF_COUNTS">
            <summary>Change to true to see details of reference counts when
            infoStream != null 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexDeletionPolicy,Lucene.Net.Index.SegmentInfos,System.IO.TextWriter,Lucene.Net.Index.DocumentsWriter)">
            <summary> Initialize the deleter: find all previous commits in
            the Directory, incref the files they reference, call
            the policy to let it delete commits.  The incoming
            segmentInfos must have been loaded from a commit point
            and not yet modified.  This will remove any files not
            referenced by any of the commits.
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.DeleteCommits">
            <summary> Remove the CommitPoints in the commitsToDelete List by
            DecRef'ing all files from each SegmentInfos.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.Refresh(System.String)">
            <summary> Writer calls this when it has hit an error and had to
            roll back, to tell us that there may now be
            unreferenced files in the filesystem.  So we re-list
            the filesystem and delete such files.  If segmentName
            is non-null, we will only delete files corresponding to
            that segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.Checkpoint(Lucene.Net.Index.SegmentInfos,System.Boolean)">
            <summary> For definition of "check point" see IndexWriter comments:
            "Clarification: Check Points (and commits)".
            
            Writer calls this when it has made a "consistent
            change" to the index, meaning new files are written to
            the index and the in-memory SegmentInfos have been
            modified to point to those files.
            
            This may or may not be a commit (segments_N may or may
            not have been written).
            
            We simply incref the files referenced by the new
            SegmentInfos and decref the files we had previously
            seen (if any).
            
            If this is a commit, we also call the policy to give it
            a chance to remove other commits.  If any commits are
            removed, we decref their files as well.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.DeleteNewFiles(System.Collections.Generic.ICollection{System.String})">
            <summary>Delets the specified files, but only if they are new
            (have not yet been incref'd). 
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileDeleter.RefCount">
            <summary> Tracks the reference count for a single index file:</summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileDeleter.CommitPoint">
            <summary> Holds details for each commit point.  This class is
            also passed to the deletion policy.  Note: this class
            has a natural ordering that is inconsistent with
            equals.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.CommitPoint.Delete">
            <summary> Called only be the deletion policy, to remove this
            commit point from the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldsWriter.AddRawDocuments(Lucene.Net.Store.IndexInput,System.Int32[],System.Int32)">
            <summary>Bulk write a contiguous series of documents.  The
            lengths array is the length (in bytes) of each raw
            document.  The stream IndexInput is the
            fieldsStream from which we should bulk-copy all
            bytes. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldsReader">
            <summary> Class responsible for access to stored document fields.
            <p/>
            It uses &lt;segment&gt;.fdt and &lt;segment&gt;.fdx; files.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.EnsureOpen">
            <throws>  AlreadyClosedException if this FieldsReader is closed </throws>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.Close">
            <summary> Closes the underlying {@link Lucene.Net.Store.IndexInput} streams, including any ones associated with a
            lazy implementation of a Field.  This means that the Fields values will not be accessible.
            
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.RawDocs(System.Int32[],System.Int32,System.Int32)">
            <summary>Returns the length in bytes of each raw document in a
            contiguous range of length numDocs starting with
            startDocID.  Returns the IndexInput (the fieldStream),
            already seeked to the starting point for startDocID.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.SkipField(System.Boolean,System.Boolean)">
            <summary> Skip the field.  We still have to read some of the information about the field, but can skip past the actual content.
            This will have the most payoff on large fields.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldsReader.LazyField">
            <summary> A Lazy implementation of Fieldable that differs loading of fields until asked for, instead of when the Document is
            loaded.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.LazyField.BinaryValue">
            <summary>The value of the field in Binary, or null.  If null, the Reader value,
            String value, or TokenStream value is used. Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.LazyField.ReaderValue">
            <summary>The value of the field as a Reader, or null.  If null, the String value,
            binary value, or TokenStream value is used.  Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.LazyField.TokenStreamValue">
            <summary>The value of the field as a TokesStream, or null.  If null, the Reader value,
            String value, or binary value is used. Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldsReader.LazyField.StringValue">
            <summary>The value of the field as a String, or null.  If null, the Reader value,
            binary value, or TokenStream value is used.  Exactly one of stringValue(), 
            readerValue(), binaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ToStringUtils.Boost(System.Single)">
            <summary>for printing boost only if not 1.0 </summary>
        </member>
        <member name="T:Lucene.Net.Util.Cache.SimpleMapCache">
            Simple cache implementation that uses a HashMap to store (key, value) pairs.
            This cache is not synchronized, use {@link Cache#synchronizedCache(Cache)}
            if needed.
        </member>
        <member name="M:Lucene.Net.Util.Cache.SimpleMapCache.keySet">
            Returns a Set containing all keys in this cache.
        </member>
        <member name="T:Lucene.Net.Store.RAMOutputStream">
            <summary> A memory-resident {@link IndexOutput} implementation.
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.#ctor">
            <summary>Construct an empty output buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.WriteTo(Lucene.Net.Store.IndexOutput)">
            <summary>Copy the current contents of this buffer to the named output. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.Reset">
            <summary>Resets this to an empty buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.SizeInBytes">
            <summary>
            Returns the byte usage of all buffers.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Store.NativeFSLockFactory">
            <summary> <p>Implements {@link LockFactory} using native OS file
            locks.  Note that because this LockFactory relies on
            java.nio.* APIs for locking, any problems with those APIs
            will cause locking to fail.  Specifically, on certain NFS
            environments the java.nio.* locks will fail (the lock can
            incorrectly be double acquired) whereas {@link
            SimpleFSLockFactory} worked perfectly in those same
            environments.  For NFS based access to an index, it's
            recommended that you try {@link SimpleFSLockFactory}
            first and work around the one limitation that a lock file
            could be left when the JVM exits abnormally.</p>
            
            <p>The primary benefit of {@link NativeFSLockFactory} is
            that lock files will be properly removed (by the OS) if
            the JVM has an abnormal exit.</p>
            
            <p>Note that, unlike {@link SimpleFSLockFactory}, the existence of
            leftover lock files in the filesystem on exiting the JVM
            is fine because the OS will free the locks held against
            these files even though the files still remain.</p>
            
            <p>If you suspect that this or any other LockFactory is
            not working properly in your environment, you can easily
            test it by using {@link VerifyingLockFactory}, {@link
            LockVerifyServer} and {@link LockStressTest}.</p>
            
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockFactory">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Store.NativeFSLockFactory.lockDir">
            <summary> Directory specified by <code>Lucene.Net.lockDir</code>
            system property.  If that is not set, then <code>java.io.tmpdir</code>
            system property is used.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor">
            <summary> Create a NativeFSLockFactory instance, with null (unset)
            lock directory.  This is package-private and is only
            used by FSDirectory when creating this LockFactory via
            the System property
            Lucene.Net.Store.FSDirectoryLockFactoryClass.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor(System.String)">
            <summary> Create a NativeFSLockFactory instance, storing lock
            files into the specified lockDirName:
            
            </summary>
            <param name="lockDirName">where lock files are created.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor(System.IO.FileInfo)">
            <summary> Create a NativeFSLockFactory instance, storing lock
            files into the specified lockDir:
            
            </summary>
            <param name="lockDir">where lock files are created.
            </param>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.SetLockDir(System.IO.FileInfo)">
            <summary> Set the lock directory.  This is package-private and is
            only used externally by FSDirectory when creating this
            LockFactory via the System property
            Lucene.Net.Store.FSDirectoryLockFactoryClass.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.MMapDirectory" -->
        <member name="T:Lucene.Net.Store.LockVerifyServer">
            <summary> Simple standalone server that must be running when you
            use {@link VerifyingLockFactory}.  This server simply
            verifies at most one process holds the lock at a time.
            Run without any args to see usage.
            
            </summary>
            <seealso cref="T:Lucene.Net.Store.VerifyingLockFactory">
            </seealso>
            <seealso cref="T:Lucene.Net.Store.LockStressTest">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Search.Spans.NearSpans.SpansCell">
            <summary>Wraps a Spans, and can be used to form a linked list. </summary>
        </member>
        <member name="T:Lucene.Net.Search.QueryFilter">
            <summary>Constrains search results to only match those which also match a provided
            query.  Results are cached, so that searches after the first on the same
            index using this filter are much faster.
            
            </summary>
            <version>  $Id: QueryFilter.java 528298 2007-04-13 00:59:28Z hossman $
            </version>
            <deprecated> use a CachingWrapperFilter with QueryWrapperFilter
            </deprecated>
        </member>
        <member name="M:Lucene.Net.Search.QueryFilter.#ctor(Lucene.Net.Search.Query)">
            <summary>Constructs a filter which only matches documents matching
            <code>query</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.PrefixQuery">
            <summary>A Query that matches documents containing terms with a specified prefix. A PrefixQuery
            is built by QueryParser for input like <code>app*</code>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Constructs a query for terms starting with <code>prefix</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.GetPrefix">
            <summary>Returns the prefix of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <member name="T:Lucene.Net.Search.MultiPhraseQuery">
            <summary> MultiPhraseQuery is a generalized version of PhraseQuery, with an added
            method {@link #Add(Term[])}.
            To use this class, to search for the phrase "Microsoft app*" first use
            add(Term) on the term "Microsoft", then find all terms that have "app" as
            prefix using IndexReader.terms(Term), and use MultiPhraseQuery.add(Term[]
            terms) to add them to the query.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.SetSlop(System.Int32)">
            <summary>Sets the phrase slop for this query.</summary>
            <seealso cref="!:PhraseQuery#SetSlop(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetSlop">
            <summary>Sets the phrase slop for this query.</summary>
            <seealso cref="!:PhraseQuery#GetSlop()">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term)">
            <summary>Add a single term at the next position in the phrase.</summary>
            <seealso cref="!:PhraseQuery#Add(Term)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[])">
            <summary>Add multiple terms at the next position in the phrase.  Any of the terms
            may match.
            
            </summary>
            <seealso cref="!:PhraseQuery#Add(Term)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[],System.Int32)">
            <summary> Allows to specify the relative position of terms within the phrase.
            
            </summary>
            <seealso cref="!:int)">
            </seealso>
            <param name="">terms
            </param>
            <param name="">position
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiPhraseQuery.GetTermArrays" -->
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetPositions">
            <summary> Returns the relative positions of terms in this phrase.</summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Equals(System.Object)">
            <summary>Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.ByteFieldSource" -->
        <member name="M:Lucene.Net.Search.Function.ByteFieldSource.#ctor(System.String)">
            <summary> Create a cached byte field source with default string-to-byte parser. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.ByteFieldSource.#ctor(System.String,Lucene.Net.Search.ByteParser)">
            <summary> Create a cached byte field source with a specific string-to-byte parser. </summary>
        </member>
        <member name="T:Lucene.Net.Index.SerialMergeScheduler">
            <summary>A {@link MergeScheduler} that simply does each merge
            sequentially, using the current thread. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeScheduler">
            <summary>Expert: {@link IndexWriter} uses an instance
            implementing this interface to execute the merges
            selected by a {@link MergePolicy}.  The default
            MergeScheduler is {@link ConcurrentMergeScheduler}.
            <p><b>NOTE:</b> This API is new and still experimental
            (subject to change suddenly in the next release)</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeScheduler.Merge(Lucene.Net.Index.IndexWriter)">
            <summary>Run the merges provided by {@link IndexWriter#GetNextMerge()}. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeScheduler.Close">
            <summary>Close this MergeScheduler. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SerialMergeScheduler.Merge(Lucene.Net.Index.IndexWriter)">
            <summary>Just do the merges in sequence. We do this
            "synchronized" so that even if the application is using
            multiple threads, only one merge may run at a time. 
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ReusableStringReader">
            <summary>
            Used by DocumentsWriter to implemented a StringReader
            that can be reset to a new string; we use this when
            tokenizing the string value from a Field.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.LoadFirstFieldSelector">
            <summary> Load the First field and break.
            <p/>
            See {@link FieldSelectorResult#LOAD_AND_BREAK}
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field">
            <summary>A field is a section of a Document.  Each field has two parts, a name and a
            value.  Values may be free text, provided as a String or as a Reader, or they
            may be atomic keywords, which are not further processed.  Such keywords may
            be used to represent dates, urls, etc.  Fields are optionally stored in the
            index, so that they may be returned with hits on the document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.StringValue">
            <summary>The value of the field as a String, or null.  If null, the Reader value,
            binary value, or TokenStream value is used.  Exactly one of stringValue(), 
            readerValue(), getBinaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.ReaderValue">
            <summary>The value of the field as a Reader, or null.  If null, the String value,
            binary value, or TokenStream value is used.  Exactly one of stringValue(), 
            readerValue(), getBinaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.BinaryValue">
            <summary>The value of the field in Binary, or null.  If null, the Reader value,
            String value, or TokenStream value is used. Exactly one of stringValue(), 
            readerValue(), GetBinaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.TokenStreamValue">
            <summary>The value of the field as a TokesStream, or null.  If null, the Reader value,
            String value, or binary value is used. Exactly one of stringValue(), 
            readerValue(), GetBinaryValue(), and tokenStreamValue() must be set. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetValue(System.String)">
            <summary><p>Expert: change the value of this field.  This can
            be used during indexing to re-use a single Field
            instance to improve indexing speed by avoiding GC cost
            of new'ing and reclaiming Field instances.  Typically
            a single {@link Document} instance is re-used as
            well.  This helps most on small documents.</p>
            
            <p>Note that you should only use this method after the
            Field has been consumed (ie, the {@link Document}
            containing this Field has been added to the index).
            Also, each Field instance should only be used once
            within a single {@link Document} instance.  See <a
            href="http://wiki.apache.org/lucene-java/ImproveIndexingSpeed">ImproveIndexingSpeed</a>
            for details.</p> 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetValue(System.IO.TextReader)">
            <summary>Expert: change the value of this field.  See <a href="#setValue(java.lang.String)">setValue(String)</a>. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetValue(System.Byte[])">
            <summary>Expert: change the value of this field.  See <a href="#setValue(java.lang.String)">setValue(String)</a>. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetValue(System.Byte[],System.Int32,System.Int32)">
            <summary>Expert: change the value of this field.  See <a href="#setValue(java.lang.String)">setValue(String)</a>. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetValue(Lucene.Net.Analysis.TokenStream)">
            <summary>Expert: change the value of this field.  See <a href="#setValue(java.lang.String)">setValue(String)</a>. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store,Lucene.Net.Documents.Field.Index)">
            <summary> Create a field by specifying its name, value and how it will
            be saved in the index. Term vectors will not be stored in the index.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="value">The string to process
            </param>
            <param name="store">Whether <code>value</code> should be stored in the index
            </param>
            <param name="index">Whether the field should be indexed, and if so, if it should
            be tokenized before indexing 
            </param>
            <throws>  NullPointerException if name or value is <code>null</code> </throws>
            <throws>  IllegalArgumentException if the field is neither stored nor indexed  </throws>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store,Lucene.Net.Documents.Field.Index,Lucene.Net.Documents.Field.TermVector)">
            <summary> Create a field by specifying its name, value and how it will
            be saved in the index.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="value">The string to process
            </param>
            <param name="store">Whether <code>value</code> should be stored in the index
            </param>
            <param name="index">Whether the field should be indexed, and if so, if it should
            be tokenized before indexing 
            </param>
            <param name="termVector">Whether term vector should be stored
            </param>
            <throws>  NullPointerException if name or value is <code>null</code> </throws>
            <throws>  IllegalArgumentException in any of the following situations: </throws>
            <summary> <ul> 
            <li>the field is neither stored nor indexed</li> 
            <li>the field is not indexed but termVector is <code>TermVector.YES</code></li>
            </ul> 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.IO.TextReader)">
            <summary> Create a tokenized and indexed field that is not stored. Term vectors will
            not be stored.  The Reader is read only when the Document is added to the index,
            i.e. you may not close the Reader until {@link IndexWriter#AddDocument(Document)}
            has been called.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="reader">The reader with the content
            </param>
            <throws>  NullPointerException if name or reader is <code>null</code> </throws>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.IO.TextReader,Lucene.Net.Documents.Field.TermVector)">
            <summary> Create a tokenized and indexed field that is not stored, optionally with 
            storing term vectors.  The Reader is read only when the Document is added to the index,
            i.e. you may not close the Reader until {@link IndexWriter#AddDocument(Document)}
            has been called.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="reader">The reader with the content
            </param>
            <param name="termVector">Whether term vector should be stored
            </param>
            <throws>  NullPointerException if name or reader is <code>null</code> </throws>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Analysis.TokenStream)">
            <summary> Create a tokenized and indexed field that is not stored. Term vectors will
            not be stored. This is useful for pre-analyzed fields.
            The TokenStream is read only when the Document is added to the index,
            i.e. you may not close the TokenStream until {@link IndexWriter#AddDocument(Document)}
            has been called.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="tokenStream">The TokenStream with the content
            </param>
            <throws>  NullPointerException if name or tokenStream is <code>null</code> </throws>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Analysis.TokenStream,Lucene.Net.Documents.Field.TermVector)">
            <summary> Create a tokenized and indexed field that is not stored, optionally with 
            storing term vectors.  This is useful for pre-analyzed fields.
            The TokenStream is read only when the Document is added to the index,
            i.e. you may not close the TokenStream until {@link IndexWriter#AddDocument(Document)}
            has been called.
            
            </summary>
            <param name="name">The name of the field
            </param>
            <param name="tokenStream">The TokenStream with the content
            </param>
            <param name="termVector">Whether term vector should be stored
            </param>
            <throws>  NullPointerException if name or tokenStream is <code>null</code> </throws>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.Byte[],Lucene.Net.Documents.Field.Store)">
            <summary>
            Create a stored field with binary value. Optionally the value may be compressed.
            </summary>
            <param name="name">The name of the field</param>
            <param name="value">The binary value</param>
            <param name="store">How <code>value</code> should be stored (compressed or not)</param>
            <throws>System.ArgumentException if store is <code>Store.NO</code></throws>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.Byte[],System.Int32,System.Int32,Lucene.Net.Documents.Field.Store)">
            <summary>
            Create a stored field with binary value. Optionally the value may be compressed.
            </summary>
            <param name="name">The name of the field</param>
            <param name="value">The binary value</param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="store">How <code>value</code> should be stored (compressed or not)</param>
            <throws>System.ArgumentException if store is <code>Store.NO</code></throws>
        </member>
        <member name="T:Lucene.Net.Documents.Field.Store">
            <summary>Specifies whether and how a field should be stored. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.COMPRESS">
            <summary>Store the original field value in the index in a compressed form. This is
            useful for long documents and for binary valued fields.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.YES">
            <summary>Store the original field value in the index. This is useful for short texts
            like a document's title which should be displayed with the results. The
            value is stored in its original form, i.e. no analyzer is used before it is
            stored.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.NO">
            <summary>Do not store the field value in the index. </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field.Index">
            <summary>Specifies whether and how a field should be indexed. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NO">
            <summary>Do not index the field value. This field can thus not be searched,
            but one can still access its contents provided it is
            {@link Field.Store stored}. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.ANALYZED">
            <summary>
            Index the tokens produced by running the field's value through
            an Analyzer. This is useful for common text.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.TOKENIZED">
            <summary>
            Deprecated.  This has been renamed to ANALYZED.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NOT_ANALYZED">
            <summary>Index the field's value without using an Analyzer, so it can be searched.
            As no analyzer is used the value will be stored as a single term. This is
            useful for unique Ids like product numbers.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.UN_TOKENIZED">
            <summary>
            Deprecated.  This has been renamed to NOT_ANALYZED.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NOT_ANALYZED_NO_NORMS">
            <summary>
            Expert: Index the field's value without an Analyzer, and also
            disable the storing of norms.. Note that you can also separately
            enable/disable norms by calling SetOmitNorms(bool).  No norms means
            that index-time field and document boosting and field length normalization
            are disabled.  The benfit is less memory ysage as norms take up one byte
            of RAM per indexed field for every document in the index, during searching.
            Note that once you index a given field <i>with</i> norms enabled, disabling
            norms will have no effect.  In other words, for this to have the above
            described effect on a field, all instances of that field must be indexed
            with NOT_ANALYZED_NO_NORMS from the beginning.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NO_NORMS">
            <summary>
            Deprecated.  This has been renamed to NOT_ANALYZED_NO_NORMS.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.ANALYZED_NO_NORMS">
            <summary>
            Expert: Index the tokens produced by running the field's value 
            through an Analyzer, and also separately disable the storing of norms.
            See {@link #NOT_ANALYZED_NO_NORMS} for what norms are and why you
            may want to disable them.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field.TermVector">
            <summary>Specifies whether and how a field should have term vectors. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.NO">
            <summary>Do not store term vectors. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.YES">
            <summary>Store the term vectors of each document. A term vector is a list
            of the document's terms and their number of occurences in that document. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS">
            <summary> Store the term vector + token position information
            
            </summary>
            <seealso cref="!:#YES">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_OFFSETS">
            <summary> Store the term vector + Token offset information
            
            </summary>
            <seealso cref="!:#YES">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS_OFFSETS">
            <summary> Store the term vector + Token position and offset information
            
            </summary>
            <seealso cref="!:#YES">
            </seealso>
            <seealso cref="!:#WITH_POSITIONS">
            </seealso>
            <seealso cref="!:#WITH_OFFSETS">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.PerFieldAnalyzerWrapper" -->
        <member name="M:Lucene.Net.Analysis.PerFieldAnalyzerWrapper.#ctor(Lucene.Net.Analysis.Analyzer)">
            <summary> Constructs with default analyzer.
            
            </summary>
            <param name="defaultAnalyzer">Any fields not specifically
            defined to use a different analyzer will use the one provided here.
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.PerFieldAnalyzerWrapper.AddAnalyzer(System.String,Lucene.Net.Analysis.Analyzer)">
            <summary> Defines an analyzer to use for the specified field.
            
            </summary>
            <param name="fieldName">field name requiring a non-default analyzer
            </param>
            <param name="analyzer">non-default analyzer to use for field
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.PerFieldAnalyzerWrapper.GetPositionIncrementGap(System.String)">
            <summary>Return the positionIncrementGap from the analyzer assigned to fieldName </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Analysis.ISOLatin1AccentFilter" -->
        <member name="M:Lucene.Net.Analysis.ISOLatin1AccentFilter.RemoveAccents(System.Char[],System.Int32)">
            <summary> To replace accented characters in a String by unaccented equivalents.</summary>
        </member>
        <member name="T:Lucene.Net.Search.TimeLimitedCollector">
            <p>The TimeLimitedCollector is used to timeout search requests that
            take longer than the maximum allowed search time limit.  After this
            time is exceeded, the search thread is stopped by throwing a
            TimeExceeded Exception.</p>
        </member>
        <member name="F:Lucene.Net.Search.TimeLimitedCollector.DEFAULT_RESOLUTION">
            Default timer resolution.
            @see #setResolution(long) 
        </member>
        <member name="F:Lucene.Net.Search.TimeLimitedCollector.DEFAULT_GREEDY">
            Default for {@link #isGreedy()}.
            @see #isGreedy()
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitedCollector.#ctor(Lucene.Net.Search.HitCollector,System.Int64)">
            Create a TimeLimitedCollector wrapper over another HitCollector with a specified timeout.
            @param hc the wrapped HitCollector
            @param timeAllowed max time allowed for collecting hits after which {@link TimeExceededException} is thrown
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitedCollector.Collect(System.Int32,System.Single)">
            Calls collect() on the decorated HitCollector.
            
            @throws TimeExceededException if the time allowed has been exceeded.
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitedCollector.getResolution">
            Return the timer resolution.
            @see #setResolution(long)
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TimeLimitedCollector.setResolution(System.UInt32)" -->
        <member name="M:Lucene.Net.Search.TimeLimitedCollector.isGreedy">
            Checks if this time limited collector is greedy in collecting the last hit.
            A non greedy collector, upon a timeout, would throw a {@link TimeExceededException} 
            without allowing the wrapped collector to collect current doc. A greedy one would 
            first allow the wrapped hit collector to collect current doc and only then 
            throw a {@link TimeExceededException}.
            @see #setGreedy(bool)
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitedCollector.setGreedy(System.Boolean)">
            Sets whether this time limited collector is greedy.
            @param greedy true to make this time limited greedy
            @see #isGreedy()
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitedCollector.TimerThread.#ctor">
            TimerThread provides a pseudo-clock service to all searching
            threads, so that they can count elapsed time with less overhead
            than repeatedly calling System.currentTimeMillis.  A single
            thread should be created to be used for all searches.
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitedCollector.TimerThread.getMilliseconds">
            Get the timer value in milliseconds.
        </member>
        <member name="T:Lucene.Net.Search.TimeLimitedCollector.TimeExceededException">
            Thrown when elapsed search time exceeds allowed search time. 
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitedCollector.TimeExceededException.getTimeAllowed">
            Returns allowed time (milliseconds).
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitedCollector.TimeExceededException.getTimeElapsed">
            Returns elapsed time (milliseconds).
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitedCollector.TimeExceededException.getLastDocCollected">
            Returns last doc that was collected when the search time exceeded.  
        </member>
        <member name="T:Lucene.Net.Search.ScoreDocComparator_Fields">
            <summary>
            Expert: Compares two ScoreDoc objects for sorting.
            </summary>
            <since>lucene 1.4</since>
            <version>$Id:$</version>
        </member>
        <member name="F:Lucene.Net.Search.ScoreDocComparator_Fields.RELEVANCE">
            <summary>Special comparator for sorting hits according to computed relevance (document score). </summary>
        </member>
        <member name="F:Lucene.Net.Search.ScoreDocComparator_Fields.INDEXORDER">
            <summary>Special comparator for sorting hits according to index order (document number). </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.AddAllDocVectors(Lucene.Net.Index.TermFreqVector[])">
            <summary> Add a complete document specified by all its term vectors. If document has no
            term vectors, add value for tvx.
            
            </summary>
            <param name="vectors">
            </param>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.AddRawDocuments(Lucene.Net.Index.TermVectorsReader,System.Int32[],System.Int32[],System.Int32)">
            Do a bulk copy of numDocs documents from reader to our
            streams.  This is used to expedite merging, if the
            field numbers are congruent.
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsWriter.Close">
            <summary>Close all streams. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsTermsWriterPerField.finish">
            Called once per field per document if term vectors
            are enabled, to write the vectors to
            RAMOutputStream, which is then quickly flushed to
            * the real term vectors files in the Directory. 
        </member>
        <member name="T:Lucene.Net.Index.TermVectorsReader">
            <version>  $Id: TermVectorsReader.java 601337 2007-12-05 13:59:37Z mikemccand $
            </version>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermVectorsReader.RawDocs(System.Int32[],System.Int32[],System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Index.TermVectorsReader.Size">
            <summary> </summary>
            <returns> The number of documents in the reader
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.Get(System.Int32,System.String)">
            Retrieve the term vector for the given document and field
            @param docNum The document number to retrieve the vector for
            @param field The field within the document to retrieve
            @return The TermFreqVector for the document and field or null if there is no termVector for this field.
            @throws IOException if there is an error reading the term vector files
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.Get(System.Int32)">
            Return all term vectors stored for this document or null if the could not be read in.
            
            @param docNum The document number to retrieve the vector for
            @return All term frequency vectors
            @throws IOException if there is an error reading the term vector files 
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsReader.ReadTermVector(System.String,System.Int64,Lucene.Net.Index.TermVectorMapper)">
            <summary> </summary>
            <param name="field">The field to read in
            </param>
            <param name="tvfPointer">The pointer within the tvf file where we should start reading
            </param>
            <param name="mapper">The mapper used to map the TermVector
            </param>
        </member>
        <member name="T:Lucene.Net.Index.ParallelArrayTermVectorMapper">
            <summary> Models the existing parallel array structure</summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelArrayTermVectorMapper.MaterializeVector">
            <summary> Construct the vector</summary>
            <returns> The {@link TermFreqVector} based on the mappings.
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.TermVectorOffsetInfo">
            <summary> The TermVectorOffsetInfo class holds information pertaining to a Term in a {@link Lucene.Net.Index.TermPositionVector}'s
            offset information.  This offset information is the character offset as set during the Analysis phase (and thus may not be the actual offset in the
            original content).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermVectorOffsetInfo.EMPTY_OFFSET_INFO">
            <summary> Convenience declaration when creating a {@link Lucene.Net.Index.TermPositionVector} that stores only position information.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorOffsetInfo.GetEndOffset">
            <summary> The accessor for the ending offset for the term</summary>
            <returns> The offset
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorOffsetInfo.GetStartOffset">
            <summary> The accessor for the starting offset of the term.
            
            </summary>
            <returns> The offset
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorOffsetInfo.Equals(System.Object)">
            <summary> Two TermVectorOffsetInfos are equals if both the start and end offsets are the same</summary>
            <param name="o">The comparison object
            </param>
            <returns> true if both {@link #GetStartOffset()} and {@link #GetEndOffset()} are the same for both objects.
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.SortedTermVectorMapper">
            <summary> Store a sorted collection of {@link Lucene.Net.Index.TermVectorEntry}s.  Collects all term information
            into a single, SortedSet.
            <br/>
            NOTE: This Mapper ignores all Field information for the Document.  This means that if you are using offset/positions you will not
            know what Fields they correlate with.
            <br/>
            This is not thread-safe  
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SortedTermVectorMapper.ALL">
            <summary> Stand-in name for the field in {@link TermVectorEntry}.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedTermVectorMapper.#ctor(System.Collections.Generic.IComparer{System.Object})">
            <summary> </summary>
            <param name="comparator">A Comparator for sorting {@link TermVectorEntry}s
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SortedTermVectorMapper.Map(System.String,System.Int32,Lucene.Net.Index.TermVectorOffsetInfo[],System.Int32[])">
            <summary> </summary>
            <param name="term">The term to map
            </param>
            <param name="frequency">The frequency of the term
            </param>
            <param name="offsets">Offset information, may be null
            </param>
            <param name="positions">Position information, may be null
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SortedTermVectorMapper.GetTermVectorEntrySet">
            <summary> The TermVectorEntrySet.  A SortedSet of {@link TermVectorEntry} objects.  Sort is by the comparator passed into the constructor.
            <br/>
            This set will be empty until after the mapping process takes place.
            
            </summary>
            <returns> The SortedSet of {@link TermVectorEntry}.
            </returns>
        </member>
        <member name="T:Lucene.Net.Index.LogDocMergePolicy">
            <summary>This is a {@link LogMergePolicy} that measures size of a
            segment as the number of documents (not taking deletions
            into account). 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.LogMergePolicy" -->
        <member name="F:Lucene.Net.Index.LogMergePolicy.LEVEL_LOG_SPAN">
            <summary>Defines the allowed range of log(size) for each
            level.  A level is computed by taking the max segment
            log size, minuse LEVEL_LOG_SPAN, and finding all
            segments falling within that range. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.DEFAULT_MERGE_FACTOR">
            <summary>Default merge factor, which is how many segments are
            merged at a time 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.DEFAULT_MAX_MERGE_DOCS">
            <summary>Default maximum segment size.  A segment of this size</summary>
            <seealso cref="!:setMaxMergeDocs">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.GetMergeFactor">
            <summary><p>Returns the number of segments that are merged at
            once and also controls the total number of segments
            allowed to accumulate in the index.</p> 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.LogMergePolicy.SetMergeFactor(System.Int32)" -->
        <member name="M:Lucene.Net.Index.LogMergePolicy.SetUseCompoundFile(System.Boolean)">
            <summary>Sets whether compound file format should be used for
            newly flushed and newly merged segments. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.GetUseCompoundFile">
            <summary>Returns true if newly flushed and newly merge segments</summary>
            <seealso cref="!:">
            #setUseCompoundFile 
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.SetUseCompoundDocStore(System.Boolean)">
            <summary>Sets whether compound file format should be used for
            newly flushed and newly merged doc store
            segment files (term vectors and stored fields). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.GetUseCompoundDocStore">
            <summary>Returns true if newly flushed and newly merge doc
            store segment files (term vectors and stored fields)
            </summary>
            <seealso cref="!:">
            #setUseCompoundDocStore 
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.IsOptimized(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.SegmentInfo)">
            <summary>Returns true if this single nfo is optimized (has no
            pending norms or deletes, is in the same dir as the
            writer, and matches the current compound file setting 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindMergesForOptimize(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.IndexWriter,System.Int32,System.Collections.Generic.Dictionary{Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.SegmentInfo})">
            <summary>Returns the merges necessary to optimize the index.
            This merge policy defines "optimized" to mean only one
            segment in the index, where that segment has no
            deletions pending nor separate norms, and it is in
            compound file format if the current useCompoundFile
            setting is true.  This method returns multiple merges
            (mergeFactor at a time) so the {@link MergeScheduler}
            in use may make use of concurrency. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindMergesToExpungeDeletes(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.IndexWriter)">
            <summary>
            Finds merges necessary to expunge all deletes from the
            index.  We simply merge adjacent segments that have
            deletes, up to mergeFactor at a time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindMerges(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.IndexWriter)">
            <summary>Checks if any merges are now necessary and returns a
            {@link MergePolicy.MergeSpecification} if so.  A merge
            is necessary when there are more than {@link
            #setMergeFactor} segments at a given level.  When
            multiple levels have too many segments, this method
            will return multiple merges, allowing the {@link
            MergeScheduler} to use concurrency. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.SetMaxMergeDocs(System.Int32)">
            <summary><p>Determines the largest segment (measured by
            document count) that may be merged with other segments.
            Small values (e.g., less than 10,000) are best for
            interactive indexing, as this limits the length of
            pauses while indexing to a few seconds.  Larger values
            are best for batched indexing and speedier
            searches.</p>
            
            <p>The default value is {@link Integer#MAX_VALUE}.</p>
            
            <p>The default merge policy ({@link
            LogByteSizeMergePolicy}) also allows you to set this
            limit by net size (in MB) of the segment, using {@link
            LogByteSizeMergePolicy#setMaxMergeMB}.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.GetMaxMergeDocs">
            <summary>Returns the largest segment (measured by document
            count) that may be merged with other segments.
            </summary>
            <seealso cref="!:setMaxMergeDocs">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Index.LogDocMergePolicy.DEFAULT_MIN_MERGE_DOCS">
            <seealso cref="!:setMinMergeDocs">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.LogDocMergePolicy.SetMinMergeDocs(System.Int32)">
            <summary>Sets the minimum size for the lowest level segments.
            Any segments below this size are considered to be on
            the same level (even if they vary drastically in size)
            and will be merged whenever there are mergeFactor of
            them.  This effectively truncates the "long tail" of
            small segments that would otherwise be created into a
            single level.  If you set this too large, it could
            greatly increase the merging cost during indexing (if
            you flush many small segments). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogDocMergePolicy.GetMinMergeDocs">
            <summary>Get the minimum size for a segment to remain
            un-merged.
            </summary>
            <seealso cref="!:setMinMergeDocs *">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.NumberTools" -->
        <member name="F:Lucene.Net.Documents.NumberTools.MIN_STRING_VALUE">
            <summary> Equivalent to longToString(Long.MIN_VALUE)</summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumberTools.MAX_STRING_VALUE">
            <summary> Equivalent to longToString(Long.MAX_VALUE)</summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumberTools.STR_SIZE">
            <summary> The length of (all) strings returned by {@link #longToString}</summary>
        </member>
        <member name="M:Lucene.Net.Documents.NumberTools.LongToString(System.Int64)">
            <summary> Converts a long to a String suitable for indexing.</summary>
        </member>
        <member name="M:Lucene.Net.Documents.NumberTools.StringToLong(System.String)">
            <summary> Converts a String that was returned by {@link #longToString} back to a
            long.
            
            </summary>
            <throws>  IllegalArgumentException </throws>
            <summary>             if the input is null
            </summary>
            <throws>  NumberFormatException </throws>
            <summary>             if the input does not parse (it was not a String returned by
            longToString()).
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.KeywordTokenizer">
            <summary> Emits the entire input as a single token.</summary>
        </member>
        <member name="T:Lucene.Net.Util.OpenBitSetIterator">
            An iterator to iterate over set bits in an OpenBitSet.
             This is faster than nextSetBit() for iterating over the complete set of bits,
             especially when the density of the bits set is high.
            
             @version $Id$
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Spans.NearSpansOrdered" -->
        <member name="F:Lucene.Net.Search.Spans.NearSpansOrdered.subSpans">
            <summary>The spans in the same order as the SpanNearQuery </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.NearSpansOrdered.inSameDoc">
            <summary>Indicates that all subSpans have same doc() </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.AdvanceAfterOrdered">
            <summary>Advances the subSpans to just after an ordered match with a minimum slop
            that is smaller than the slop allowed by the SpanNearQuery.
            </summary>
            <returns> true iff there is such a match.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.ToSameDoc">
            <summary>Advance the subSpans to the same document </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.DocSpansOrdered(Lucene.Net.Search.Spans.Spans,Lucene.Net.Search.Spans.Spans)">
            <summary>Check whether two Spans in the same document are ordered.</summary>
            <param name="spans1">
            </param>
            <param name="spans2">
            </param>
            <returns> true iff spans1 starts before spans2
            or the spans start at the same position,
            and spans1 ends before spans2.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.DocSpansOrdered(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Like {@link #DocSpansOrdered(Spans,Spans)}, but use the spans
            starts and ends as parameters.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.StretchToOrder">
            <summary>Order the subSpans within the same document by advancing all later spans
            after the previous one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.ShrinkToAfterShortestMatch">
            <summary>The subSpans are ordered in the same doc, so there is a possible match.
            Compute the slop while making the match as short as possible by advancing
            all subSpans except the last one in reverse order.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ConstantScoreQuery">
            <summary>
            A query that wraps a filter and simply returns a constant score equal to the
            query boost for every document in the filter.
            </summary>
            <version>$Id:$</version>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreQuery.GetFilter">
            <summary>Returns the encapsulated filter </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreQuery.Equals(System.Object)">
            <summary>Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreQuery.GetHashCode">
            <summary>Returns a hash code value for this object. </summary>
        </member>
        <member name="T:Lucene.Net.LucenePackage">
            <summary>Lucene's package information, including version. *</summary>
        </member>
        <member name="T:Lucene.Net.Index.TermVectorEntry">
            <summary> Convenience class for holding TermVector information.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SegmentMerger" -->
        <member name="F:Lucene.Net.Index.SegmentMerger.MAX_RAW_MERGE_DOCS">
            <summary>Maximum number of contiguous documents to bulk-copy
            when merging stored fields 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentMerger.NORMS_HEADER">
            <summary>norms header placeholder </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary>This ctor used only by test code.
            
            </summary>
            <param name="dir">The Directory to merge the other segments into
            </param>
            <param name="name">The name of the new segment
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.Add(Lucene.Net.Index.IndexReader)">
            <summary> Add an IndexReader to the collection of readers that are to be merged</summary>
            <param name="reader">
            </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.SegmentReader(System.Int32)">
            <summary> </summary>
            <param name="i">The index of the reader to return
            </param>
            <returns> The ith reader to be merged
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.Merge">
            <summary> Merges the readers specified by the {@link #add} method into the directory passed to the constructor</summary>
            <returns> The number of documents that were merged
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.Merge(System.Boolean)">
            <summary> Merges the readers specified by the {@link #add} method
            into the directory passed to the constructor.
            </summary>
            <param name="mergeDocStores">if false, we will not merge the
            stored fields nor vectors files
            </param>
            <returns> The number of documents that were merged
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.CloseReaders">
            <summary> close all IndexReaders that have been added.
            Should not be called before merge().
            </summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeFields">
            <summary> </summary>
            <returns> The number of documents in all of the readers
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeVectors">
            <summary> Merge the TermVectors from each of the segments into the new one.</summary>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeTermInfo(Lucene.Net.Index.SegmentMergeInfo[],System.Int32)">
            <summary>Merge one term found in one or more segments. The array <code>smis</code>
            contains segments that are positioned at the same term. <code>N</code>
            is the number of cells in the array actually occupied.
            
            </summary>
            <param name="smis">array of segments
            </param>
            <param name="n">number of cells in the array actually occupied
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.AppendPostings(Lucene.Net.Index.SegmentMergeInfo[],System.Int32)">
            <summary>Process postings from multiple segments all positioned on the
            same term. Writes out merged entries into freqOutput and
            the proxOutput streams.
            
            </summary>
            <param name="smis">array of segments
            </param>
            <param name="n">number of cells in the array actually occupied
            </param>
            <returns> number of documents across all segments where this term was found
            </returns>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.AppendPostingsNoTf(Lucene.Net.Index.SegmentMergeInfo[],System.Int32)">
            <summary>
            Process postings from multiple segments without tf, all positioned on the same term.
            Writes out merged entries only into freqOutput, proxOut is not written.
            </summary>
            <param name="smis">smis array of segments</param>
            <param name="n">number of cells in the array actually occupied</param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.CheckAbort.Work(System.Double)">
            <summary> Records the fact that roughly units amount of work
            have been done since this method was last called.
            When adding time-consuming code into SegmentMerger,
            you should test different values for units to ensure
            that the time in between calls to merge.checkAborted
            is up to ~ 1 second.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.LogByteSizeMergePolicy">
            <summary>This is a {@link LogMergePolicy} that measures size of a
            segment as the total byte size of the segment's files. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogByteSizeMergePolicy.DEFAULT_MIN_MERGE_MB">
            <seealso cref="!:setMinMergeMB">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Index.LogByteSizeMergePolicy.DEFAULT_MAX_MERGE_MB">
            <summary>Default maximum segment size.  A segment of this size</summary>
            <seealso cref="M:Lucene.Net.Index.LogByteSizeMergePolicy.SetMaxMergeMB(System.Double)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.LogByteSizeMergePolicy.SetMaxMergeMB(System.Double)">
            <summary><p>Determines the largest segment (measured by total
            byte size of the segment's files, in MB) that may be
            merged with other segments.  Small values (e.g., less
            than 50 MB) are best for interactive indexing, as this
            limits the length of pauses while indexing to a few
            seconds.  Larger values are best for batched indexing
            and speedier searches.</p>
            
            <p>Note that {@link #setMaxMergeDocs} is also
            used to check whether a segment is too large for
            merging (it's either or).</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogByteSizeMergePolicy.GetMaxMergeMB">
            <summary>Returns the largest segment (meaured by total byte
            size of the segment's files, in MB) that may be merged
            with other segments.
            </summary>
            <seealso cref="!:setMaxMergeMB">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.LogByteSizeMergePolicy.SetMinMergeMB(System.Double)">
            <summary>Sets the minimum size for the lowest level segments.
            Any segments below this size are considered to be on
            the same level (even if they vary drastically in size)
            and will be merged whenever there are mergeFactor of
            them.  This effectively truncates the "long tail" of
            small segments that would otherwise be created into a
            single level.  If you set this too large, it could
            greatly increase the merging cost during indexing (if
            you flush many small segments). 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogByteSizeMergePolicy.GetMinMergeMB">
            <summary>Get the minimum size for a segment to remain
            un-merged.
            </summary>
            <seealso cref="!:setMinMergeMB *">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.FreqProxTermsWriter.copyBytes(Lucene.Net.Store.IndexInput,Lucene.Net.Store.IndexOutput,System.Int64)">
            Copy numBytes from srcIn to destIn 
        </member>
        <member name="T:Lucene.Net.Analysis.LengthFilter">
            <summary> Removes words that are too long and too short from the stream.
            
            
            </summary>
            <version>  $Id: LengthFilter.java 564715 2007-08-10 18:34:33Z mikemccand $
            </version>
        </member>
        <member name="M:Lucene.Net.Analysis.LengthFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.Int32,System.Int32)">
            <summary> Build a filter that removes words that are too long or too
            short from the text.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.LengthFilter.Next(Lucene.Net.Analysis.Token)">
            <summary> Returns the next input Token whose term() is the right len</summary>
        </member>
        <member name="T:Lucene.Net.Util.ScorerDocQueue">
            <summary>A ScorerDocQueue maintains a partial ordering of its Scorers such that the
            least Scorer can always be found in constant time.  Put()'s and pop()'s
            require log(size) time. The ordering is by Scorer.doc().
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.#ctor(System.Int32)">
            <summary>Create a ScorerDocQueue with a maximum size. </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.Put(Lucene.Net.Search.Scorer)">
            <summary> Adds a Scorer to a ScorerDocQueue in log(size) time.
            If one tries to add more Scorers than maxSize
            a SystemException (ArrayIndexOutOfBound) is thrown.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.Insert(Lucene.Net.Search.Scorer)">
            <summary> Adds a Scorer to the ScorerDocQueue in log(size) time if either
            the ScorerDocQueue is not full, or not lessThan(scorer, top()).
            </summary>
            <param name="">scorer
            </param>
            <returns> true if scorer is added, false otherwise.
            </returns>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.Top">
            <summary>Returns the least Scorer of the ScorerDocQueue in constant time.
            Should not be used when the queue is empty.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.TopDoc">
            <summary>Returns document number of the least Scorer of the ScorerDocQueue
            in constant time.
            Should not be used when the queue is empty.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.Pop">
            <summary>Removes and returns the least scorer of the ScorerDocQueue in log(size)
            time.
            Should not be used when the queue is empty.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.PopNoResult">
            <summary>Removes the least scorer of the ScorerDocQueue in log(size) time.
            Should not be used when the queue is empty.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.AdjustTop">
            <summary>Should be called when the scorer at top changes doc() value.
            Still log(n) worst case, but it's at least twice as fast to <pre>
            { pq.top().change(); pq.adjustTop(); }
            </pre> instead of <pre>
            { o = pq.pop(); o.change(); pq.push(o); }
            </pre>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.Size">
            <summary>Returns the number of scorers currently stored in the ScorerDocQueue. </summary>
        </member>
        <member name="M:Lucene.Net.Util.ScorerDocQueue.Clear">
            <summary>Removes all entries from the ScorerDocQueue. </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.HashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Returns hash of chars in range start (inclusive) to end (inclusive).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.HashCode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns hash of chars in range start (inclusive) to end (inclusive).
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.LockReleaseFailedException">
            <summary> This exception is thrown when the <code>write.lock</code>
            could not be released.
            </summary>
            <seealso cref="!:Lock.release().">
            </seealso>
        </member>
        <member name="T:Lucene.Net.Search.Spans.NearSpansUnordered.SpansCell">
            <summary>Wraps a Spans, and can be used to form a linked list. </summary>
        </member>
        <member name="T:Lucene.Net.Search.PrefixFilter">
            <summary> </summary>
            <version>  $Id$
            </version>
        </member>
        <member name="M:Lucene.Net.Search.PrefixFilter.ToString">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldDocSortedHitQueue">
            <summary> Expert: Collects sorted results from Searchable's and collates them.
            The elements put into this queue must be of type FieldDoc.
            </summary>
            <since>   lucene 1.4
            </since>
            <version>  $Id: FieldDocSortedHitQueue.java 590530 2007-10-31 01:28:25Z gsingers $
            </version>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.#ctor(Lucene.Net.Search.SortField[],System.Int32)">
            <summary> Creates a hit queue sorted by the given list of fields.</summary>
            <param name="fields">Fieldable names, in priority order (highest priority first).
            </param>
            <param name="size"> The number of hits to retain.  Must be greater than zero.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.SetFields(Lucene.Net.Search.SortField[])">
            <summary> Allows redefinition of sort fields if they are <code>null</code>.
            This is to handle the case using ParallelMultiSearcher where the
            original list contains AUTO and we don't know the actual sort
            type until the values come back.  The fields can only be set once.
            This method is thread safe.
            </summary>
            <param name="">fields
            </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.GetFields">
            <summary>Returns the fields being used to sort. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.HasCollators(Lucene.Net.Search.SortField[])">
            <summary>Returns an array of collators, possibly <code>null</code>.  The collators
            correspond to any SortFields which were given a specific locale.
            </summary>
            <param name="fields">Array of sort fields.
            </param>
            <returns> Array, possibly <code>null</code>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.FieldDocSortedHitQueue.LessThan(System.Object,System.Object)">
            <summary> Returns whether <code>a</code> is less relevant than <code>b</code>.</summary>
            <param name="a">ScoreDoc
            </param>
            <param name="b">ScoreDoc
            </param>
            <returns> <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.FieldDoc">
            <summary> Expert: A ScoreDoc which also contains information about
            how to sort the referenced document.  In addition to the
            document number and score, this object contains an array
            of values for the document from the field(s) used to sort.
            For example, if the sort criteria was to sort by fields
            "a", "b" then "c", the <code>fields</code> object array
            will have three elements, corresponding respectively to
            the term values for the document in fields "a", "b" and "c".
            The class of each element in the array will be either
            Integer, Float or String depending on the type of values
            in the terms of each field.
            </summary>
            <since>lucene 1.4</since>
            <version>$Id:$</version>
            <seealso cref="T:Lucene.Net.Search.ScoreDoc"/>
            <seealso cref="T:Lucene.Net.Search.TopFieldDocs"/>
        </member>
        <member name="F:Lucene.Net.Search.FieldDoc.fields">
            <summary>Expert: The values which are used to sort the referenced document.
            The order of these will match the original sort criteria given by a
            Sort object.  Each object will be either an Integer, Float or String,
            depending on the type of values in the terms of the original field.
            </summary>
            <seealso cref="T:Lucene.Net.Search.Sort">
            </seealso>
            <seealso cref="!:Searcher#Search(Query,Filter,int,Sort)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single)">
            <summary>Expert: Creates one of these objects with empty sort information. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single,System.IComparable[])">
            <summary>Expert: Creates one of these objects with the given sort information. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermInfo">
            <summary>A TermInfo is the record of information stored for a term.</summary>
        </member>
        <member name="F:Lucene.Net.Index.TermInfo.docFreq">
            <summary>The number of documents which contain the term. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeDocIDRemapper">
            <summary>
            Remaps docIDs after a merge has completed, where the
            merged segments had at least one deletion.  This is used
            to renumber the buffered deletes in IndexWriter when a
            merge of segments with deletions commits.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileNames">
            <summary> Useful constants representing filenames and extensions used by lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.SEGMENTS">
            <summary>Name of the index segment file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.SEGMENTS_GEN">
            <summary>Name of the generation reference file name </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.DELETABLE">
            <summary>Name of the index deletable file (only used in
            pre-lockless indices) 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.NORMS_EXTENSION">
            <summary>Extension of norms file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.FREQ_EXTENSION">
            <summary>Extension of freq postings file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.PROX_EXTENSION">
            <summary>Extension of prox postings file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.TERMS_EXTENSION">
            <summary>Extension of terms file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.TERMS_INDEX_EXTENSION">
            <summary>Extension of terms index file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.FIELDS_INDEX_EXTENSION">
            <summary>Extension of stored fields index file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.FIELDS_EXTENSION">
            <summary>Extension of stored fields file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.VECTORS_FIELDS_EXTENSION">
            <summary>Extension of vectors fields file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.VECTORS_DOCUMENTS_EXTENSION">
            <summary>Extension of vectors documents file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.VECTORS_INDEX_EXTENSION">
            <summary>Extension of vectors index file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.COMPOUND_FILE_EXTENSION">
            <summary>Extension of compound file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.COMPOUND_FILE_STORE_EXTENSION">
            <summary>Extension of compound file for doc store files</summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.DELETES_EXTENSION">
            <summary>Extension of deletes </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.FIELD_INFOS_EXTENSION">
            <summary>Extension of field infos </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.PLAIN_NORMS_EXTENSION">
            <summary>Extension of plain norms </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.SEPARATE_NORMS_EXTENSION">
            <summary>Extension of separate norms </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.GEN_EXTENSION">
            <summary>Extension of gen file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.INDEX_EXTENSIONS">
            <summary> This array contains all filename extensions used by
            Lucene's index files, with two exceptions, namely the
            extension made up from <code>.f</code> + a number and
            from <code>.s</code> + a number.  Also note that
            Lucene's <code>segments_N</code> files do not have any
            filename extension.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.INDEX_EXTENSIONS_IN_COMPOUND_FILE">
            <summary>File extensions that are added to a compound file
            (same as above, minus "del", "gen", "cfs"). 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.COMPOUND_EXTENSIONS">
            <summary>File extensions of old-style index files </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.VECTOR_EXTENSIONS">
            <summary>File extensions for term vector support </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexFileNames.FileNameFromGeneration(System.String,System.String,System.Int64)" -->
        <member name="M:Lucene.Net.Index.IndexFileNames.IsDocStoreFile(System.String)">
            <summary> Returns true if the provided filename is one of the doc
            store files (ends with an extension in
            STORE_INDEX_EXTENSIONS).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FreqProxFieldMergeState">
            <summary>
            Used by DocumentsWriter to merge the postings from
            multiple ThreadStates when creating a segment
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ConcurrentMergeScheduler">
            <summary>
            A {@link MergeScheduler} that runs each merge using a
            separate thread, up until a maximum number of threads
            ({@link #setMaxThreadCount}) at which when a merge is
            needed, the thread(s) that are updating the index will
            pause until one or more merges completes.  This is a
            simple way to use concurrency in the indexing process
            without having to create and manage application level
            threads.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMaxThreadCount(System.Int32)">
            <summary>Sets the max # simultaneous threads that may be
            running.  If a merge is necessary yet we already have
            this many threads running, the incoming thread (that
            is calling add/updateDocument) will block until
            a merge thread has completed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.GetMaxThreadCount">
            <summary>Get the max # simultaneous threads that may be</summary>
            <seealso cref="!:setMaxThreadCount.">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.GetMergeThreadPriority">
            <summary>Return the priority that merge threads run at.  By
            default the priority is 1 plus the priority of (ie,
            slightly higher priority than) the first thread that
            calls merge. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMergeThreadPriority(System.Int32)">
            <summary>Return the priority that merge threads run at. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.DoMerge(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Does the acural merge, by calling IndexWriter.Merge().
            </summary>
            <param name="merge"></param>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.GetMergeThread(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Create and return a new MergeThread.
            </summary>
            <param name="writer"></param>
            <param name="merge"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.AnyUnhandledExceptions">
            <summary>Used for testing </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.AddMyself">
            <summary>Used for testing </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetSuppressExceptions">
            <summary>Used for testing </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.ClearSuppressExceptions">
            <summary>Used for testing </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.allInstances">
            <summary>Used for testing </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.StopFilter">
            <summary> Removes stop words from a token stream.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.String[])">
            <summary> Construct a token stream filtering the given input.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.String[],System.Boolean)">
            <summary> Constructs a filter which removes words from the input
            TokenStream that are named in the array of words.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.Collections.Hashtable,System.Boolean)">
            <summary> Construct a token stream filtering the given input.
            If <code>stopWords</code> is an instance of {@link CharArraySet} (true if
            <code>makeStopSet()</code> was used to construct the set) it will be directly used
            and <code>ignoreCase</code> will be ignored since <code>CharArraySet</code>
            directly controls case sensitivity.
            <p/>
            If <code>stopWords</code> is not an instance of {@link CharArraySet},
            a new CharArraySet will be constructed and <code>ignoreCase</code> will be
            used to specify the case sensitivity of that set.
            
            </summary>
            <param name="input">
            </param>
            <param name="stopWords">The set of Stop Words.
            </param>
            <param name="ignoreCase">-Ignore case when stopping.
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.#ctor(Lucene.Net.Analysis.TokenStream,System.Collections.Hashtable)">
            <summary> Constructs a filter which removes words from the input
            TokenStream that are named in the Set.
            
            </summary>
            <seealso cref="!:MakeStopSet(java.lang.String[])">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.MakeStopSet(System.String[])">
            <summary> Builds a Set from an array of stop words,
            appropriate for passing into the StopFilter constructor.
            This permits this stopWords construction to be cached once when
            an Analyzer is constructed.
            
            </summary>
            <seealso cref="!:MakeStopSet(java.lang.String[], boolean) passing false to ignoreCase">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.MakeStopSet(System.String[],System.Boolean)">
            <summary> </summary>
            <param name="stopWords">
            </param>
            <param name="ignoreCase">If true, all words are lower cased first.  
            </param>
            <returns> a Set containing the words
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.Next(Lucene.Net.Analysis.Token)">
            <summary> Returns the next input Token whose term() is not a stop word.</summary>
        </member>
        <member name="M:Lucene.Net.Analysis.StopFilter.GetEnablePositionIncrementsDefault">
            <seealso cref="!:setEnablePositionIncrementsDefault(boolean).">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.StopFilter.SetEnablePositionIncrementsDefault(System.Boolean)" -->
        <member name="M:Lucene.Net.Analysis.StopFilter.GetEnablePositionIncrements">
            <seealso cref="!:setEnablePositionIncrements(boolean).">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.StopFilter.SetEnablePositionIncrements(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.SortedVIntList" -->
        <member name="F:Lucene.Net.Util.SortedVIntList.BITS2VINTLIST_SIZE">
            When a BitSet has fewer than 1 in BITS2VINTLIST_SIZE bits set,
            a SortedVIntList representing the index numbers of the set bits
            will be smaller than that BitSet.
        </member>
        <member name="M:Lucene.Net.Util.SortedVIntList.#ctor(System.Int32[])">
              Create a SortedVIntList from all elements of an array of integers.
            
             @param  sortedInts  A sorted array of non negative integers.
        </member>
        <member name="M:Lucene.Net.Util.SortedVIntList.#ctor(System.Int32[],System.Int32)">
            Create a SortedVIntList from an array of integers.
            @param  sortedInts  An array of sorted non negative integers.
            @param  inputSize   The number of integers to be used from the array.
        </member>
        <member name="M:Lucene.Net.Util.SortedVIntList.#ctor(SupportClass.CollectionsSupport.BitSet)">
            Create a SortedVIntList from a BitSet.
            @param  bits  A bit set representing a set of integers.
        </member>
        <member name="M:Lucene.Net.Util.SortedVIntList.#ctor(Lucene.Net.Util.OpenBitSet)">
            Create a SortedVIntList from an OpenBitSet.
            @param  bits  A bit set representing a set of integers.
        </member>
        <member name="M:Lucene.Net.Util.SortedVIntList.#ctor(Lucene.Net.Search.DocIdSetIterator)">
            Create a SortedVIntList.
            @param  docIdSetIterator  An iterator providing document numbers as a set of integers.
                             This DocIdSetIterator is iterated completely when this constructor
                             is called and it must provide the integers in non
                             decreasing order.
        </member>
        <member name="M:Lucene.Net.Util.SortedVIntList.Size">
            @return    The total number of sorted integers.
        </member>
        <member name="M:Lucene.Net.Util.SortedVIntList.GetByteSize">
            @return The size of the byte array storing the compressed sorted integers.
        </member>
        <member name="M:Lucene.Net.Util.SortedVIntList.Iterator">
            @return    An iterator over the sorted integers.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.#ctor(Lucene.Net.Search.DocIdSetIterator,System.Int32)">
            Construct an OpenBitSetDISI with its bits set
            from the doc ids of the given DocIdSetIterator.
            Also give a maximum size one larger than the largest doc id for which a
            bit may ever be set on this OpenBitSetDISI.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.#ctor(System.Int32)">
            Construct an OpenBitSetDISI with no bits set, and a given maximum size
            one larger than the largest doc id for which a bit may ever be set
            on this OpenBitSetDISI.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceOr(Lucene.Net.Search.DocIdSetIterator)">
            Perform an inplace OR with the doc ids from a given DocIdSetIterator,
            setting the bit for each such doc id.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceAnd(Lucene.Net.Search.DocIdSetIterator)">
            Perform an inplace AND with the doc ids from a given DocIdSetIterator,
            leaving only the bits set for which the doc ids are in common.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceNot(Lucene.Net.Search.DocIdSetIterator)">
            Perform an inplace NOT with the doc ids from a given DocIdSetIterator,
            clearing all the bits for each such doc id.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceXor(Lucene.Net.Search.DocIdSetIterator)">
            Perform an inplace XOR with the doc ids from a given DocIdSetIterator,
            flipping all the bits for each such doc id.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
        </member>
        <member name="T:Lucene.Net.Search.TermQuery">
            <summary>A Query that matches documents containing a term.
            This may be combined with other terms with a {@link BooleanQuery}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>Constructs a query for the term <code>t</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.GetTerm">
            <summary>Returns the term of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.ToString(System.String)">
            <summary>Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.GetHashCode">
            <summary>Returns a hash code value for this object.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ReqExclScorer" -->
        <member name="M:Lucene.Net.Search.ReqExclScorer.#ctor(Lucene.Net.Search.Scorer,Lucene.Net.Search.Scorer)">
            <summary>Construct a <code>ReqExclScorer</code>.</summary>
            <param name="reqScorer">The scorer that must match, except where
            </param>
            <param name="exclScorer">indicates exclusion.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ReqExclScorer.ToNonExcluded" -->
        <member name="M:Lucene.Net.Search.ReqExclScorer.Score">
            <summary>Returns the score of the current document matching the query.
            Initially invalid, until {@link #next()} is called the first time.
            </summary>
            <returns> The score of the required scorer.
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ReqExclScorer.SkipTo(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ParallelMultiSearcher" -->
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.#ctor(Lucene.Net.Search.Searchable[])">
            <summary>Creates a searcher which searches <i>searchables</i>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.DocFreq(Lucene.Net.Index.Term)">
            <summary> TODO: parallelize this one too</summary>
        </member>
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,System.Int32)">
            <summary> A search implementation which spans a new thread for each
            Searchable, waits for each search to complete and merge
            the results back together.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ParallelMultiSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)">
            <summary> A search implementation allowing sorting which spans a new thread for each
            Searchable, waits for each search to complete and merges
            the results back together.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ParallelMultiSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.Filter,Lucene.Net.Search.HitCollector)" -->
        <member name="T:Lucene.Net.Search.MultiSearcherThread">
            <summary> A thread subclass for searching a single searchable </summary>
        </member>
        <member name="T:Lucene.Net.Search.Hit">
            <summary>
            Wrapper used by {@link HitIterator} to provide a lazily loaded hit from {@link Hits}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Hit.#ctor(Lucene.Net.Search.Hits,System.Int32)">
            <summary> Constructed from {@link HitIterator}</summary>
            <param name="hits">Hits returned from a search
            </param>
            <param name="hitNumber">Hit index in Hits
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Hit.GetDocument">
            <summary> Returns document for this hit.
            
            </summary>
            <seealso cref="M:Lucene.Net.Search.Hits.Doc(System.Int32)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Search.Hit.GetScore">
            <summary> Returns score for this hit.
            
            </summary>
            <seealso cref="M:Lucene.Net.Search.Hits.Score(System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Hit.GetId">
            <summary> Returns id for this hit.
            
            </summary>
            <seealso cref="!:Hits#Id(int)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Hit.GetBoost">
            <summary> Returns the boost factor for this hit on any field of the underlying document.
            
            </summary>
            <seealso cref="M:Lucene.Net.Documents.Document.GetBoost">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Search.Hit.Get(System.String)">
            <summary> Returns the string value of the field with the given name if any exist in
            this document, or null.  If multiple fields exist with this name, this
            method returns the first value added. If only binary fields with this name
            exist, returns null.
            
            </summary>
            <seealso cref="M:Lucene.Net.Documents.Document.Get(System.String)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Search.Hit.ToString">
            <summary> Prints the parameters to be used to discover the promised result.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.ShortFieldSource" -->
        <member name="M:Lucene.Net.Search.Function.ShortFieldSource.#ctor(System.String)">
            <summary> Create a cached short field source with default string-to-short parser. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.ShortFieldSource.#ctor(System.String,Lucene.Net.Search.ShortParser)">
            <summary> Create a cached short field source with a specific string-to-short parser. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Function.CustomScoreQuery" -->
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.#ctor(Lucene.Net.Search.Query)">
            <summary> Create a CustomScoreQuery over input subQuery.</summary>
            <param name="subQuery">the sub query whose scored is being customed. Must not be null. 
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Function.ValueSourceQuery)">
            <summary> Create a CustomScoreQuery over input subQuery and a {@link ValueSourceQuery}.</summary>
            <param name="subQuery">the sub query whose score is being customed. Must not be null.
            </param>
            <param name="valSrcQuery">a value source query whose scores are used in the custom score
            computation. For most simple/convineient use case this would be a 
            {@link Lucene.Net.Search.Function.FieldScoreQuery FieldScoreQuery}.
            This parameter is optional - it can be null.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Function.ValueSourceQuery[])">
            <summary> Create a CustomScoreQuery over input subQuery and a {@link ValueSourceQuery}.</summary>
            <param name="subQuery">the sub query whose score is being customed. Must not be null.
            </param>
            <param name="valSrcQueries">value source queries whose scores are used in the custom score
            computation. For most simple/convineient use case these would be 
            {@link Lucene.Net.Search.Function.FieldScoreQuery FieldScoreQueries}.
            This parameter is optional - it can be null or even an empty array.
            </param>
        </member>
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.Equals(System.Object)">
            <summary>Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.GetHashCode">
            <summary>Returns a hash code value for this object. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.CustomScoreQuery.CustomScore(System.Int32,System.Single,System.Single[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.CustomScoreQuery.CustomScore(System.Int32,System.Single,System.Single)" -->
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.CustomExplain(System.Int32,Lucene.Net.Search.Explanation,Lucene.Net.Search.Explanation[])">
            <summary> Explain the custom score.
            Whenever overriding {@link #CustomScore(int, float, float[])}, 
            this method should also be overridden to provide the correct explanation
            for the part of the custom scoring.
            
            </summary>
            <param name="doc">doc being explained.
            </param>
            <param name="subQueryExpl">explanation for the sub-query part.
            </param>
            <param name="valSrcExpls">explanation for the value source part.
            </param>
            <returns> an explanation for the custom score
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.CustomExplain(System.Int32,Lucene.Net.Search.Explanation,Lucene.Net.Search.Explanation)">
            <summary> Explain the custom score.
            Whenever overriding {@link #CustomScore(int, float, float)}, 
            this method should also be overridden to provide the correct explanation
            for the part of the custom scoring.
            
            </summary>
            <param name="doc">doc being explained.
            </param>
            <param name="subQueryExpl">explanation for the sub-query part.
            </param>
            <param name="valSrcExpl">explanation for the value source part.
            </param>
            <returns> an explanation for the custom score
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Function.CustomScoreQuery.IsStrict" -->
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.SetStrict(System.Boolean)">
            <summary> Set the strict mode of this query. </summary>
            <param name="strict">The strict mode to set.
            </param>
            <seealso cref="M:Lucene.Net.Search.Function.CustomScoreQuery.IsStrict">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Function.CustomScoreQuery.Name">
            <summary> A short name of this query, used in {@link #ToString(String)}.</summary>
        </member>
        <member name="T:Lucene.Net.Search.Function.CustomScoreQuery.CustomScorer">
            <summary> A scorer that applies a (callback) function on scores of the subQuery.</summary>
        </member>
        <member name="T:Lucene.Net.Search.StringIndex">
            <summary> Expert: Maintains caches of term values.
            </summary>
            <since>lucene 1.4</since>
            <version>$Id:$</version>
            <summary>Expert: Stores term text values and document ordering data. </summary>
        </member>
        <member name="F:Lucene.Net.Search.StringIndex.Lookup">
            <summary>All the term values, in natural order. </summary>
        </member>
        <member name="F:Lucene.Net.Search.StringIndex.Order">
            <summary>For each document, an index into the lookup array. </summary>
        </member>
        <member name="M:Lucene.Net.Search.StringIndex.#ctor(System.Int32[],System.String[])">
            <summary>Creates one of these objects </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache_Fields.STRING_INDEX">
            <summary>Indicator for StringIndex values in the cache. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache_Fields.DEFAULT">
            <summary>Expert: The cache used internally by sorting and range query classes. </summary>
        </member>
        <member name="T:Lucene.Net.Search.ExtendedFieldCache_Fields">
            <summary> 
            
            
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.CachingSpanFilter">
            <summary> Wraps another SpanFilter's result and caches it.  The purpose is to allow
            filters to simply filter, and then wrap with this class to add caching.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.CachingSpanFilter.cache">
            <summary> A transient Filter cache.  To cache Filters even when using {@link Lucene.Net.Search.RemoteSearchable} use
            {@link Lucene.Net.Search.RemoteCachingWrapperFilter} instead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingSpanFilter.#ctor(Lucene.Net.Search.SpanFilter)">
            <param name="filter">Filter to cache results of
            </param>
        </member>
        <member name="T:Lucene.Net.QueryParsers.TokenMgrError">
            <summary>
            Token Manager Error.
            </summary>	
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.LEXICAL_ERROR">
            <summary> Lexical error occured.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.STATIC_LEXER_ERROR">
            <summary> An attempt wass made to create a second instance of a static token manager.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.INVALID_LEXICAL_STATE">
            <summary> Tried to change to an invalid lexical state.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.LOOP_DETECTED">
            <summary> Detected (and bailed out of) an infinite loop in the token manager.</summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.TokenMgrError.errorCode">
            <summary> Indicates the reason why the exception is thrown. It will have
            one of the above 4 values.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.TokenMgrError.addEscapes(System.String)">
            <summary> Replaces unprintable characters by their espaced (or unicode escaped)
            equivalents in the given string
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.TokenMgrError.LexicalError(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char)">
            <summary> Returns a detailed message for the Error when it is thrown by the
            token manager to indicate a lexical error.
            Parameters : 
            EOFSeen     : indicates if EOF caused the lexicl error
            curLexState : lexical state in which this error occured
            errorLine   : line number when the error occured
            errorColumn : column number when the error occured
            errorAfter  : prefix that was seen before this error occured
            curchar     : the offending character
            Note: You can customize the lexical error message by modifying this method.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.TokenMgrError.#ctor">
            <summary>
            No-arg constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.TokenMgrError.#ctor(System.String,System.Int32)">
            <summary>
            Constructor with message and reason.
            </summary>
            <param name="message"></param>
            <param name="reason"></param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.TokenMgrError.#ctor(System.Boolean,System.Int32,System.Int32,System.Int32,System.String,System.Char,System.Int32)">
            <summary>
            Full constructor.
            </summary>
            <param name="EOFSeen"></param>
            <param name="lexState"></param>
            <param name="errorLine"></param>
            <param name="errorColumn"></param>
            <param name="errorAfter"></param>
            <param name="curChar"></param>
            <param name="reason"></param>
        </member>
        <member name="P:Lucene.Net.QueryParsers.TokenMgrError.Message">
            <summary> You can also modify the body of this method to customize your error messages.
            For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
            of end-users concern, so you can return something like : 
            
            "Internal Error : Please file a bug report .... "
            
            from this method for such cases in the release version of your parser.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserTokenManager.jjstrLiteralImages">
            <summary>
            Token literal values.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserTokenManager.lexStateNames">
            <summary>
            Lexer state names.
            </summary>
        </member>
        <member name="F:Lucene.Net.QueryParsers.QueryParserTokenManager.jjnewLexState">
            <summary>
            Lex state array.
            </summary>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParserTokenManager.#ctor(Lucene.Net.QueryParsers.CharStream)">
            <summary>
            Constructor.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParserTokenManager.#ctor(Lucene.Net.QueryParsers.CharStream,System.Int32)">
            <summary>
            Constructor.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParserTokenManager.ReInit(Lucene.Net.QueryParsers.CharStream)">
            <summary>
            Reinitialise parser.
            </summary>
            <param name="stream"></param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParserTokenManager.ReInit(Lucene.Net.QueryParsers.CharStream,System.Int32)">
            <summary>
            Reinitialise parser.
            </summary>
            <param name="stream"></param>
            <param name="lexState"></param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParserTokenManager.SwitchTo(System.Int32)">
            <summary>
            Switch to specified lex state.
            </summary>
            <param name="lexState"></param>
        </member>
        <member name="M:Lucene.Net.QueryParsers.QueryParserTokenManager.GetNextToken">
            <summary>
            Get the next Token.
            </summary>
            <returns></returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermInfosWriter" -->
        <member name="F:Lucene.Net.Index.TermInfosWriter.FORMAT">
            <summary>The file format version, a negative number. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermInfosWriter.indexInterval">
            <summary>Expert: The fraction of terms in the "dictionary" which should be stored
            in RAM.  Smaller values use more memory, but make searching slightly
            faster, while larger values use less memory and make searching slightly
            slower.  Searching is typically not dominated by dictionary lookup, so
            tweaking this is rarely useful.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermInfosWriter.skipInterval">
            <summary>Expert: The fraction of {@link TermDocs} entries stored in skip tables,
            used to accellerate {@link TermDocs#SkipTo(int)}.  Larger values result in
            smaller indexes, greater acceleration, but fewer accelerable cases, while
            smaller values result in bigger indexes, less acceleration and more
            accelerable cases. More detailed experiments would be useful here. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermInfosWriter.maxSkipLevels">
            <summary>Expert: The maximum number of skip levels. Smaller values result in 
            slightly smaller indexes, but slower skipping in big posting lists.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermInfosWriter.Add(System.Int32,System.Byte[],System.Int32,Lucene.Net.Index.TermInfo)" -->
        <member name="M:Lucene.Net.Index.TermInfosWriter.Close">
            <summary>Called to complete TermInfos creation. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermInfosReader" -->
        <member name="M:Lucene.Net.Index.TermInfosReader.SetIndexDivisor(System.Int32)">
            <summary> <p>Sets the indexDivisor, which subsamples the number
            of indexed terms loaded into memory.  This has a
            similar effect as {@link
            IndexWriter#setTermIndexInterval} except that setting
            must be done at indexing time while this setting can be
            set per reader.  When set to N, then one in every
            N*termIndexInterval terms in the index is loaded into
            memory.  By setting this to a value > 1 you can reduce
            memory usage, at the expense of higher latency when
            loading a TermInfo.  The default value is 1.</p>
            
            <b>NOTE:</b> you must call this before the term
            index is loaded.  If the index is already loaded,
            an IllegalStateException is thrown.
            
            + @throws IllegalStateException if the term index has
            already been loaded into memory.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.GetIndexDivisor">
            <summary>Returns the indexDivisor.</summary>
            <seealso cref="!:setIndexDivisor">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Size">
            <summary>Returns the number of term/value pairs in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.GetIndexOffset(Lucene.Net.Index.Term)">
            <summary>Returns the offset of the greatest index entry which is less than or equal to term.</summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Get(Lucene.Net.Index.Term)">
            <summary>Returns the TermInfo for a Term in the set, or null. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Get(Lucene.Net.Index.Term,System.Boolean)">
            <summary>Returns the TermInfo for a Term in the set, or null. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Get(System.Int32)">
            <summary>Returns the nth term in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.GetPosition(Lucene.Net.Index.Term)">
            <summary>Returns the position of a Term in the set or -1. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Terms">
            <summary>Returns an enumeration of all the Terms and TermInfos in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermInfosReader.Terms(Lucene.Net.Index.Term)">
            <summary>Returns an enumeration of terms starting at or after the named term. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermInfosReader.ThreadResources">
            <summary>
            Per-thread resources managed by ThreadLocal.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.Term">
            <summary>A Term represents a word from text.  This is the unit of search.  It is
            composed of two elements, the text of the word, as a string, and the name of
            the field that the text occured in, an interned string.
            Note that terms may represent more than words from text fields, but also
            things like dates, email addresses, urls, etc.  
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.Term.#ctor(System.String,System.String)" -->
        <member name="M:Lucene.Net.Index.Term.#ctor(System.String)">
            <summary>Constructs a Term with the given field and empty text.
            This serves 2 purposes:
            1) reuse of a Term with the same field
            2) pattern for a query
            </summary>
            <param name="fld"/>
        </member>
        <member name="M:Lucene.Net.Index.Term.Field">
            <summary>Returns the field of this term, an interned string.   The field indicates
            the part of a document which this term came from. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Text">
            <summary>Returns the text of this term.  In the case of words, this is simply the
            text of the word.  In the case of dates and other types, this is an
            encoding of the object as a string.  
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.CreateTerm(System.String)">
            <summary> Optimized construction of new Terms by reusing same field as this Term
            - avoids field.intern() overhead 
            </summary>
            <param name="text">The text of the new term (field is implicitly same as this Term instance)
            </param>
            <returns> A new Term
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.Term.Equals(System.Object)">
            <summary>Compares two terms, returning true iff they have the same
            field and text. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.GetHashCode">
            <summary>Combines the hashCode() of the field and the text. </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.CompareTo(Lucene.Net.Index.Term)">
            <summary>Compares two terms, returning a negative integer if this
            term belongs before the argument, zero if this term is equal to the
            argument, and a positive integer if this term belongs after the argument.
            The ordering of terms is first by field, then by text.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Set(System.String,System.String)">
            <summary>Resets the field and text of a Term. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Next">
            <summary>Increments the enumeration to the next element.  True if one exists.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.ScanTo(Lucene.Net.Index.Term)">
            <summary>Optimized scan, without allocating new terms.  Return numver of invocations to Next(). </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Term">
            <summary>Returns the current Term in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Prev">
            <summary>Returns the previous Term enumerated. Initially null.</summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.TermInfo">
            <summary>Returns the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.TermInfo(Lucene.Net.Index.TermInfo)">
            <summary>Sets the argument to the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.DocFreq">
            <summary>Returns the docFreq from the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentTermEnum.Close">
            <summary>Closes the enumeration to further activity, freeing resources. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.CompoundFileWriter" -->
        <member name="M:Lucene.Net.Index.CompoundFileWriter.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary>Create the compound stream in the specified file. The file name is the
            entire name (no extensions are added).
            </summary>
            <throws>  NullPointerException if <code>dir</code> or <code>name</code> is null </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.GetDirectory">
            <summary>Returns the directory of the compound file. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.GetName">
            <summary>Returns the name of the compound file. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.AddFile(System.String)">
            <summary>Add a source stream. <code>file</code> is the string by which the 
            sub-stream will be known in the compound stream.
            
            </summary>
            <throws>  IllegalStateException if this writer is closed </throws>
            <throws>  NullPointerException if <code>file</code> is null </throws>
            <throws>  IllegalArgumentException if a file with the same name </throws>
            <summary>   has been added already
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.Close">
            <summary>Merge files with the extensions added up to now.
            All files with these extensions are combined sequentially into the
            compound stream. After successful merge, the source files
            are deleted.
            </summary>
            <throws>  IllegalStateException if close() had been called before or </throws>
            <summary>   if no file has been added to this object
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileWriter.CopyFile(Lucene.Net.Index.CompoundFileWriter.FileEntry,Lucene.Net.Store.IndexOutput,System.Byte[])">
            <summary>Copy the contents of the file with specified extension into the
            provided output stream. Use the provided buffer for moving data
            to reduce memory allocation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CompoundFileWriter.FileEntry.file">
            <summary>source file </summary>
        </member>
        <member name="F:Lucene.Net.Index.CompoundFileWriter.FileEntry.directoryOffset">
            <summary>temporary holder for the start of directory entry for this file </summary>
        </member>
        <member name="F:Lucene.Net.Index.CompoundFileWriter.FileEntry.dataOffset">
            <summary>temporary holder for the start of this file's data section </summary>
        </member>
        <member name="T:Lucene.Net.Index.CompoundFileReader">
            <summary> Class for accessing a compound stream.
            This class implements a directory, but is limited to only read operations.
            Directory methods that would normally modify data throw an exception.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.List">
            <summary>Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.FileExists(System.String)">
            <summary>Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.FileModified(System.String)">
            <summary>Returns the time the compound file was last modified. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.TouchFile(System.String)">
            <summary>Set the modified time of the compound file to now. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.DeleteFile(System.String)">
            <summary>Not implemented</summary>
            <throws>  UnsupportedOperationException  </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.RenameFile(System.String,System.String)">
            <summary>Not implemented</summary>
            <throws>  UnsupportedOperationException  </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.FileLength(System.String)">
            <summary>Returns the length of a file in the directory.</summary>
            <throws>  IOException if the file does not exist  </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CreateOutput(System.String)">
            <summary>Not implemented</summary>
            <throws>  UnsupportedOperationException  </throws>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.MakeLock(System.String)">
            <summary>Not implemented</summary>
            <throws>  UnsupportedOperationException  </throws>
        </member>
        <member name="T:Lucene.Net.Index.CompoundFileReader.CSIndexInput">
            <summary>Implementation of an IndexInput that reads from a portion of the
            compound file. The visibility is left as "package" *only* because
            this helps with testing since JUnit test cases in a different class
            can then access package fields of this class.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CSIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>Expert: implements buffer refill.  Reads bytes from the current
            position in the input.
            </summary>
            <param name="b">the array to read bytes into
            </param>
            <param name="offset">the offset in the array to start storing bytes
            </param>
            <param name="len">the number of bytes to read
            </param>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CSIndexInput.SeekInternal(System.Int64)">
            <summary>Expert: implements seek.  Sets current position in this file, where
            the next {@link #ReadInternal(byte[],int,int)} will occur.
            </summary>
            <seealso cref="M:Lucene.Net.Index.CompoundFileReader.CSIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.CompoundFileReader.CSIndexInput.Close">
            <summary>Closes the stream to further operations. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.CheckIndex" -->
        <member name="F:Lucene.Net.Index.CheckIndex.out_Renamed">
            <summary>
            Default print stream for all CheckIndex instances.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.#ctor(Lucene.Net.Store.Directory)">
            Create a new CheckIndex on the directory. 
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.SetInfoStream(System.IO.TextWriter)">
            Set infoStream where messages should go.  If null, no
            messages are printed 
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.Check(Lucene.Net.Store.Directory,System.Boolean)">
            Returns true if index is clean, else false. 
            @deprecated Please instantiate a CheckIndex and then use {@link #CheckIndex()} instead 
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.Check(Lucene.Net.Store.Directory,System.Boolean,System.Collections.Generic.IList{System.Object})">
            Returns true if index is clean, else false.
            @deprecated Please instantiate a CheckIndex and then use {@link #CheckIndex(List)} instead 
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.CheckIndex.CheckIndex_Renamed" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.CheckIndex.CheckIndex_Renamed(System.Collections.Generic.IList{System.Object})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.CheckIndex.FixIndex(Lucene.Net.Index.CheckIndex.Status)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.CheckIndex.Main(System.String[])" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.CheckIndex.Status" -->
        <member name="F:Lucene.Net.Index.CheckIndex.Status.clean">
            True if no problems were found with the index. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.missingSegments">
            True if we were unable to locate and load the segments_N file. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.cantOpenSegments">
            True if we were unable to open the segments_N file. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.missingSegmentVersion">
            True if we were unable to read the version number from segments_N file. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.segmentsFileName">
            Name of latest segments_N file in the index. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.numSegments">
            Number of segments in the index. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.segmentFormat">
            string description of the version of the index. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.segmentsChecked">
            Empty unless you passed specific segments list to check as optional 3rd argument.
            @see CheckIndex#CheckIndex(List) 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.toolOutOfDate">
            True if the index was created with a newer version of Lucene than the CheckIndex tool. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.segmentInfos">
            List of {@link SegmentInfoStatus} instances, detailing status of each segment. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.dir">
            Directory index is in. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.newSegments">
            SegmentInfos instance containing only segments that
            had no problems (this is used with the {@link
            CheckIndex#fix} method to repair the index. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.totLoseDocCount">
            How many documents will be lost to bad segments. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.numBadSegments">
            How many bad segments were found. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.partial">
            True if we checked only specific segments ({@link
            #CheckIndex(List)}) was called with non-null
            argument). 
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus" -->
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.name">
            Name of the segment. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.docCount">
            Document count (does not take deletions into account). 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.compound">
            True if segment is compound file format. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.numFiles">
            Number of files referenced by this segment. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.sizeMB">
            Net size (MB) of the files referenced by this
            segment. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.docStoreOffset">
            Doc store offset, if this segment shares the doc
            store files (stored fields and term vectors) with
            other segments.  This is -1 if it does not share. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.docStoreSegment">
            string of the shared doc store segment, or null if
            this segment does not share the doc store files. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.docStoreCompoundFile">
            True if the shared doc store files are compound file
            format. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.hasDeletions">
            True if this segment has pending deletions. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.deletionsFileName">
            Name of the current deletions file name. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.numDeleted">
            Number of deleted documents. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.openReaderPassed">
            True if we were able to open a SegmentReader on this
            segment. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.numFields">
            Number of fields in this segment. 
        </member>
        <member name="F:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.hasProx">
            True if at least one of the fields in this segment
            does not omitTf.
            @see Fieldable#setOmitTf 
        </member>
        <member name="T:Lucene.Net.Documents.SetBasedFieldSelector">
            <summary> Declare what fields to load normally and what fields to load lazily
            
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SetBasedFieldSelector.#ctor(System.Collections.Hashtable,System.Collections.Hashtable)">
            <summary> Pass in the Set of {@link Field} names to load and the Set of {@link Field} names to load lazily.  If both are null, the
            Document will not have any {@link Field} on it.  
            </summary>
            <param name="fieldsToLoad">A Set of {@link String} field names to load.  May be empty, but not null
            </param>
            <param name="lazyFieldsToLoad">A Set of {@link String} field names to load lazily.  May be empty, but not null  
            </param>
        </member>
        <member name="M:Lucene.Net.Documents.SetBasedFieldSelector.Accept(System.String)">
            <summary> Indicate whether to load the field with the given name or not. If the {@link Field#Name()} is not in either of the 
            initializing Sets, then {@link Lucene.Net.Documents.FieldSelectorResult#NO_LOAD} is returned.  If a Field name
            is in both <code>fieldsToLoad</code> and <code>lazyFieldsToLoad</code>, lazy has precedence.
            
            </summary>
            <param name="fieldName">The {@link Field} name to check
            </param>
            <returns> The {@link FieldSelectorResult}
            </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Documents.DateTools" -->
        <member name="M:Lucene.Net.Documents.DateTools.DateToString(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Converts a Date to a string suitable for indexing.
            
            </summary>
            <param name="date">the date to be converted
            </param>
            <param name="resolution">the desired resolution, see
            {@link #Round(Date, DateTools.Resolution)}
            </param>
            <returns> a string in format <code>yyyyMMddHHmmssSSS</code> or shorter,
            depeding on <code>resolution</code>; using GMT as timezone 
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.TimeToString(System.Int64,Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Converts a millisecond time to a string suitable for indexing.
            
            </summary>
            <param name="time">the date expressed as milliseconds since January 1, 1970, 00:00:00 GMT
            </param>
            <param name="resolution">the desired resolution, see
            {@link #Round(long, DateTools.Resolution)}
            </param>
            <returns> a string in format <code>yyyyMMddHHmmssSSS</code> or shorter,
            depeding on <code>resolution</code>; using GMT as timezone
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.StringToTime(System.String)">
            <summary> Converts a string produced by <code>timeToString</code> or
            <code>dateToString</code> back to a time, represented as the
            number of milliseconds since January 1, 1970, 00:00:00 GMT.
            
            </summary>
            <param name="dateString">the date string to be converted
            </param>
            <returns> the number of milliseconds since January 1, 1970, 00:00:00 GMT
            </returns>
            <throws>  ParseException if <code>dateString</code> is not in the  </throws>
            <summary>  expected format 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.StringToDate(System.String)">
            <summary> Converts a string produced by <code>timeToString</code> or
            <code>dateToString</code> back to a time, represented as a
            Date object.
            
            </summary>
            <param name="dateString">the date string to be converted
            </param>
            <returns> the parsed time as a Date object 
            </returns>
            <throws>  ParseException if <code>dateString</code> is not in the  </throws>
            <summary>  expected format 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.Round(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Limit a date's resolution. For example, the date <code>2004-09-21 13:50:11</code>
            will be changed to <code>2004-09-01 00:00:00</code> when using
            <code>Resolution.MONTH</code>. 
            
            </summary>
            <param name="resolution">The desired resolution of the date to be returned
            </param>
            <returns> the date with all values more precise than <code>resolution</code>
            set to 0 or 1
            </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.Round(System.Int64,Lucene.Net.Documents.DateTools.Resolution)">
            <summary> Limit a date's resolution. For example, the date <code>1095767411000</code>
            (which represents 2004-09-21 13:50:11) will be changed to 
            <code>1093989600000</code> (2004-09-01 00:00:00) when using
            <code>Resolution.MONTH</code>.
            
            </summary>
            <param name="resolution">The desired resolution of the date to be returned
            </param>
            <returns> the date with all values more precise than <code>resolution</code>
            set to 0 or 1, expressed as milliseconds since January 1, 1970, 00:00:00 GMT
            </returns>
        </member>
        <member name="T:Lucene.Net.Documents.DateTools.Resolution">
            <summary>Specifies the time granularity. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.WhitespaceTokenizer">
            <summary>A WhitespaceTokenizer is a tokenizer that divides text at whitespace.
            Adjacent sequences of non-Whitespace characters form tokens. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.WhitespaceTokenizer.#ctor(System.IO.TextReader)">
            <summary>Construct a new WhitespaceTokenizer. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.WhitespaceTokenizer.IsTokenChar(System.Char)">
            <summary>Collects only characters which do not satisfy
            {@link Character#isWhitespace(char)}.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.WhitespaceAnalyzer">
            <summary>An Analyzer that uses WhitespaceTokenizer. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Cache.SimpleLRUCache_LUCENENET_190_1" -->
        <member name="T:Lucene.Net.Util.Cache.SimpleLRUCache_OrgPort">
            <summary>
            This class is the original port for 2.4.0
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Cache.SimpleLRUCache_LUCENENET_190_2">
            <summary>
            Implemented for LUCENENET-190. Good for capacity > 1536
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Store.VerifyingLockFactory" -->
        <member name="M:Lucene.Net.Store.VerifyingLockFactory.#ctor(System.Byte,Lucene.Net.Store.LockFactory,System.String,System.Int32)">
            <param name="id">should be a unique id across all clients
            </param>
            <param name="lf">the LockFactory that we are testing
            </param>
            <param name="host">host or IP where {@link LockVerifyServer}
            is running
            </param>
            <param name="port">the port {@link LockVerifyServer} is
            listening on
            </param>
        </member>
        <member name="M:Lucene.Net.Store.RAMFile.NewBuffer(System.Int32)">
            <summary> Expert: allocate a new buffer. 
            Subclasses can allocate differently. 
            </summary>
            <param name="size">size of allocated buffer.
            </param>
            <returns> allocated buffer.
            </returns>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanNotQuery">
            <summary>Removes matches which overlap with another SpanQuery. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,Lucene.Net.Search.Spans.SpanQuery)">
            <summary>Construct a SpanNotQuery matching spans from <code>include</code> which
            have no overlap with spans from <code>exclude</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.GetInclude">
            <summary>Return the SpanQuery whose matches are filtered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.GetExclude">
            <summary>Return the SpanQuery whose matches must not overlap those returned. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.GetTerms">
            <summary>Returns a collection of all terms matched by this query.</summary>
            <deprecated> use extractTerms instead
            </deprecated>
            <seealso cref="!:#ExtractTerms(Set)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanNearQuery">
            <summary>Matches spans which are near one another.  One can specify <i>slop</i>, the
            maximum number of intervening unmatched positions, as well as whether
            matches are required to be in-order. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery[],System.Int32,System.Boolean)">
            <summary>Construct a SpanNearQuery.  Matches spans matching a span from each
            clause, with up to <code>slop</code> total unmatched positions between
            them.  * When <code>inOrder</code> is true, the spans from each clause
            must be * ordered as in <code>clauses</code>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.GetClauses">
            <summary>Return the clauses whose spans are matched. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.GetSlop">
            <summary>Return the maximum number of intervening unmatched positions permitted.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.IsInOrder">
            <summary>Return true if matches are required to be in-order.</summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.GetTerms">
            <summary>Returns a collection of all terms matched by this query.</summary>
            <deprecated> use extractTerms instead
            </deprecated>
            <seealso cref="!:#ExtractTerms(Set)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.Equals(System.Object)">
            <summary>Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Payloads.PayloadSpanUtil">
            <summary>
            Experimental class to get set of payloads for most standard Lucene queries.
            Operates like Highlighter - IndexReader should only contain doc of interest,
            best to use MemoryIndex.
            
            <p/>
            <font color="#FF0000">
            WARNING: The status of the <b>Payloads</b> feature is experimental.
            The APIs introduced here might change in the future and will not be
            supported anymore in such a case.</font>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Payloads.PayloadSpanUtil.#ctor(Lucene.Net.Index.IndexReader)">
            <summary>
            @param reader
            that contains doc with payloads to extract
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Payloads.PayloadSpanUtil.GetPayloadsForQuery(Lucene.Net.Search.Query)">
            <summary>
            Query should be rewritten for wild/fuzzy support.
            
            @param query
            @return payloads Collection
            @throws IOException
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FuzzyTermEnum" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermEnum.#ctor(Lucene.Net.Index.IndexReader,Lucene.Net.Index.Term,System.Single,System.Int32)" -->
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.TermCompare(Lucene.Net.Index.Term)">
            <summary> The termCompare method in FuzzyTermEnum uses Levenshtein distance to 
            calculate the distance between the given term and the comparing term. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.min(System.Int32,System.Int32,System.Int32)">
            <summary> Finds and returns the smallest of three integers </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermEnum.Similarity(System.String)" -->
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.GrowDistanceArray(System.Int32)">
            <summary> Grow the second dimension of the array, so that we can calculate the
            Levenshtein difference.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermEnum.GetMaxDistance(System.Int32)">
            <summary> The max Distance is the maximum Levenshtein distance for the text
            compared to some other value that results in score that is
            better than the minimum similarity.
            </summary>
            <param name="m">the length of the "other value"
            </param>
            <returns> the maximum levenshtein distance that we care about
            </returns>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsTermsWriter.fill(System.Int32)">
            Fills in no-term-vectors for all docs we haven't seen
            since the last doc that had term vectors. 
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.ParallelReader" -->
        <member name="M:Lucene.Net.Index.ParallelReader.#ctor">
            <summary>Construct a ParallelReader. 
            <p>Note that all subreaders are closed if this ParallelReader is closed.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelReader.#ctor(System.Boolean)">
            <summary>Construct a ParallelReader. </summary>
            <param name="closeSubReaders">indicates whether the subreaders should be closed
            when this ParallelReader is closed
            </param>
        </member>
        <member name="M:Lucene.Net.Index.ParallelReader.Add(Lucene.Net.Index.IndexReader)">
            <summary>Add an IndexReader. </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.ParallelReader.Add(Lucene.Net.Index.IndexReader,System.Boolean)">
            <summary>Add an IndexReader whose stored fields will not be returned.  This can
            accellerate search when stored fields are only needed from a subset of
            the IndexReaders.
            
            </summary>
            <throws>  IllegalArgumentException if not all indexes contain the same number </throws>
            <summary>     of documents
            </summary>
            <throws>  IllegalArgumentException if not all indexes have the same value </throws>
            <summary>     of {@link IndexReader#MaxDoc()}
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.ParallelReader.Reopen" -->
        <member name="M:Lucene.Net.Index.ParallelReader.IsCurrent">
            <summary> Checks recursively if all subreaders are up to date. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelReader.IsOptimized">
            <summary> Checks recursively if all subindexes are optimized </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelReader.GetVersion">
            <summary>Not implemented.</summary>
            <throws>  UnsupportedOperationException </throws>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter">
             <summary>
             An <code>IndexWriter</code> creates and maintains an index.
              <p>The <code>create</code> argument to the 
             <a href="#IndexWriter(org.apache.lucene.store.Directory, org.apache.lucene.analysis.Analyzer, bool)"><b>constructor</b></a>
             determines whether a new index is created, or whether an existing index is
             opened.  Note that you
             can open an index with <code>create=true</code> even while readers are
             using the index.  The old readers will continue to search
             the "point in time" snapshot they had opened, and won't
             see the newly created index until they re-open.  There are
             also <a href="#IndexWriter(org.apache.lucene.store.Directory, org.apache.lucene.analysis.Analyzer)"><b>constructors</b></a>
             with no <code>create</code> argument which
             will create a new index if there is not already an index at the
             provided path and otherwise open the existing index.</p>
            
             <p>In either case, documents are added with <a
             href="#addDocument(org.apache.lucene.document.Document)"><b>addDocument</b></a>
             and removed with <a
             href="#deleteDocuments(org.apache.lucene.index.Term)"><b>deleteDocuments(Term)</b></a>
             or <a
             href="#deleteDocuments(org.apache.lucene.search.Query)"><b>deleteDocuments(Query)</b></a>.
             A document can be updated with <a href="#updateDocument(org.apache.lucene.index.Term, org.apache.lucene.document.Document)"><b>updateDocument</b></a> 
             (which just deletes and then adds the entire document).
             When finished adding, deleting and updating documents, <a href="#Close()"><b>close</b></a> should be called.</p>
            
             <a name="flush"></a>
             <p>These changes are buffered in memory and periodically
             flushed to the {@link Directory} (during the above method
             calls).  A flush is triggered when there are enough
             buffered deletes (see {@link #setMaxBufferedDeleteTerms})
             or enough added documents since the last flush, whichever
             is sooner.  For the added documents, flushing is triggered
             either by RAM usage of the documents (see {@link
             #setRAMBufferSizeMB}) or the number of added documents.
             The default is to flush when RAM usage hits 16 MB.  For
             best indexing speed you should flush by RAM usage with a
             large RAM buffer.  Note that flushing just moves the
             internal buffered state in IndexWriter into the index, but
             these changes are not visible to IndexReader until either
             {@link #Commit()} or {@link #close} is called.  A flush may
             also trigger one or more segment merges which by default
             run with a background thread so as not to block the
             addDocument calls (see <a href="#mergePolicy">below</a>
             for changing the {@link MergeScheduler}).</p>
            
             <a name="autoCommit"></a>
             <p>The optional <code>autoCommit</code> argument to the <a
             href="#IndexWriter(org.apache.lucene.store.Directory,
             bool,
             org.apache.lucene.analysis.Analyzer)"><b>constructors</b></a>
             controls visibility of the changes to {@link IndexReader}
             instances reading the same index.  When this is
             <code>false</code>, changes are not visible until {@link
             #Close()} or {@link #Commit()} is called.  Note that changes will still be
             flushed to the {@link org.apache.lucene.store.Directory}
             as new files, but are not committed (no new
             <code>segments_N</code> file is written referencing the
             new files, nor are the files sync'd to stable storage)
             until {@link #Close()} or {@link #Commit()} is called.  If something
             goes terribly wrong (for example the JVM crashes), then
             the index will reflect none of the changes made since the
             last commit, or the starting state if commit was not called.
             You can also call {@link #rollback}, which closes the writer
             without committing any changes, and removes any index
             files that had been flushed but are now unreferenced.
             This mode is useful for preventing readers from refreshing
             at a bad time (for example after you've done all your
             deletes but before you've done your adds).  It can also be
             used to implement simple single-writer transactional
             semantics ("all or none").  You can do a two-phase commit
             by calling {@link #PrepareCommit()}
             followed by {@link #Commit()}. This is necessary when
             Lucene is working with an external resource (for example,
             a database) and both must either commit or rollback the
             transaction.</p>
            
             <p>When <code>autoCommit</code> is <code>true</code> then
             the writer will periodically commit on its own.  [<b>Deprecated</b>: Note that in 3.0, IndexWriter will
             no longer accept autoCommit=true (it will be hardwired to
             false).  You can always call {@link #Commit()} yourself
             when needed]. There is
             no guarantee when exactly an auto commit will occur (it
             used to be after every flush, but it is now after every
             completed merge, as of 2.4).  If you want to force a
             commit, call {@link #Commit()}, or, close the writer.  Once
             a commit has finished, newly opened {@link IndexReader} instances will
             see the changes to the index as of that commit.  When
             running in this mode, be careful not to refresh your
             readers while optimize or segment merges are taking place
             as this can tie up substantial disk space.</p>
            
             <p>Regardless of <code>autoCommit</code>, an {@link
             IndexReader} or {@link org.apache.lucene.search.IndexSearcher} will only see the
             index as of the "point in time" that it was opened.  Any
             changes committed to the index after the reader was opened
             are not visible until the reader is re-opened.</p>
            
             <p>If an index will not have more documents added for a while and optimal search
             performance is desired, then either the full <a href="#Optimize()"><b>optimize</b></a>
             method or partial {@link #Optimize(int)} method should be
             called before the index is closed.</p>
            
             <p>Opening an <code>IndexWriter</code> creates a lock file for the directory in use. Trying to open
             another <code>IndexWriter</code> on the same directory will lead to a
             {@link LockObtainFailedException}. The {@link LockObtainFailedException}
             is also thrown if an IndexReader on the same directory is used to delete documents
             from the index.</p>
            
             <a name="deletionPolicy"></a>
             <p>Expert: <code>IndexWriter</code> allows an optional
             {@link IndexDeletionPolicy} implementation to be
             specified.  You can use this to control when prior commits
             are deleted from the index.  The default policy is {@link
             KeepOnlyLastCommitDeletionPolicy} which removes all prior
             commits as soon as a new commit is done (this matches
             behavior before 2.2).  Creating your own policy can allow
             you to explicitly keep previous "point in time" commits
             alive in the index for some time, to allow readers to
             refresh to the new commit without having the old commit
             deleted out from under them.  This is necessary on
             filesystems like NFS that do not support "delete on last
             close" semantics, which Lucene's "point in time" search
             normally relies on. </p>
            
             <a name="mergePolicy"></a> <p>Expert:
             <code>IndexWriter</code> allows you to separately change
             the {@link MergePolicy} and the {@link MergeScheduler}.
             The {@link MergePolicy} is invoked whenever there are
             changes to the segments in the index.  Its role is to
             select which merges to do, if any, and return a {@link
             MergePolicy.MergeSpecification} describing the merges.  It
             also selects merges to do for Optimize().  (The default is
             {@link LogByteSizeMergePolicy}.  Then, the {@link
             MergeScheduler} is invoked with the requested merges and
             it decides when and how to run the merges.  The default is
             {@link ConcurrentMergeScheduler}. </p>
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.WRITE_LOCK_NAME">
            <summary> Name of the write lock in the index.</summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DISABLE_AUTO_FLUSH">
            <summary> Value to denote a flush trigger is disabled</summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_RAM_BUFFER_SIZE_MB">
            <summary> Default value is 16 MB (which means flush when buffered
            docs consume 16 MB RAM).  Change using {@link #setRAMBufferSizeMB}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MAX_FIELD_LENGTH">
            <summary> Default value is 10,000. Change using {@link #SetMaxFieldLength(int)}.</summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_TERM_INDEX_INTERVAL">
            <summary> Default value is 128. Change using {@link #SetTermIndexInterval(int)}.</summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.WRITE_LOCK_TIMEOUT">
            <summary> Default value for the write lock timeout (1,000).</summary>
            <seealso cref="!:setDefaultWriteLockTimeout">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MERGE_FACTOR">
            <deprecated>
            </deprecated>
            <seealso cref="F:Lucene.Net.Index.LogMergePolicy.DEFAULT_MERGE_FACTOR">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MAX_BUFFERED_DOCS">
            <summary> Disabled by default (because IndexWriter flushes by RAM usage
            by default). Change using {@link #SetMaxBufferedDocs(int)}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MAX_BUFFERED_DELETE_TERMS">
            <summary> Disabled by default (because IndexWriter flushes by RAM usage
            by default). Change using {@link #SetMaxBufferedDeleteTerms(int)}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MAX_MERGE_DOCS">
            <deprecated>
            </deprecated>
            <seealso cref="!:LogDocMergePolicy.DEFAULT_MAX_MERGE_DOCS">
            </seealso>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.MAX_TERM_LENGTH">
            <summary> Absolute hard maximum length for a term.  If a term
            arrives from the analyzer longer than this length, it
            is skipped and a message is printed to infoStream, if
            set (see {@link #setInfoStream}).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.DEFAULT_MAX_SYNC_PAUSE_SECONDS">
            <summary>
            Default for {@link #getMaxSyncPauseSeconds}.  On
            Windows this defaults to 10.0 seconds; elsewhere it's
            0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.EnsureOpen(System.Boolean)">
            <summary> Used internally to throw an {@link
            AlreadyClosedException} if this IndexWriter has been
            closed.
            </summary>
            <throws>  AlreadyClosedException if this IndexWriter is </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Message(System.String)">
            <summary> Prints a message to the infoStream (if non-null),
            prefixed with the identifying information for this
            writer and the thread that's calling it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetLogMergePolicy">
            <summary> Casts current mergePolicy to LogMergePolicy, and throws
            an exception if the mergePolicy is not a LogMergePolicy.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetUseCompoundFile">
            <summary><p>Get the current setting of whether newly flushed
            segments will use the compound file format.  Note that
            this just returns the value previously set with
            setUseCompoundFile(bool), or the default value
            (true).  You cannot use this to query the status of
            previously flushed segments.</p>
            
            <p>Note that this method is a convenience method: it
            just calls mergePolicy.GetUseCompoundFile as long as
            mergePolicy is an instance of {@link LogMergePolicy}.
            Otherwise an System.ArgumentException is thrown.</p>
            
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.SetUseCompoundFile(System.Boolean)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetUseCompoundFile(System.Boolean)">
            <summary><p>Setting to turn on usage of a compound file. When on,
            multiple files for each segment are merged into a
            single file when a new segment is flushed.</p>
            
            <p>Note that this method is a convenience method: it
            just calls mergePolicy.SetUseCompoundFile as long as
            mergePolicy is an instance of {@link LogMergePolicy}.
            Otherwise an System.ArgumentException is thrown.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetSimilarity(Lucene.Net.Search.Similarity)">
            <summary>Expert: Set the Similarity implementation used by this IndexWriter.
            
            </summary>
            <seealso cref="M:Lucene.Net.Search.Similarity.SetDefault(Lucene.Net.Search.Similarity)">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.GetSimilarity" -->
        <member name="M:Lucene.Net.Index.IndexWriter.SetTermIndexInterval(System.Int32)">
            <summary>Expert: Set the interval between indexed terms.  Large values cause less
            memory to be used by IndexReader, but slow random-access to terms.  Small
            values cause more memory to be used by an IndexReader, and speed
            random-access to terms.
            
            This parameter determines the amount of computation required per query
            term, regardless of the number of documents that contain that term.  In
            particular, it is the maximum number of other terms that must be
            scanned before a term is located and its frequency and position information
            may be processed.  In a large index with user-entered query terms, query
            processing time is likely to be dominated not by term lookup but rather
            by the processing of frequency and positional data.  In a small index
            or when many uncommon query terms are generated (e.g., by wildcard
            queries) term lookup may become a dominant cost.
            
            In particular, <code>numUniqueTerms/interval</code> terms are read into
            memory by an IndexReader, and, on average, <code>interval/2</code> terms
            must be scanned for each random term access.
            
            </summary>
            <seealso cref="F:Lucene.Net.Index.IndexWriter.DEFAULT_TERM_INDEX_INTERVAL">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetTermIndexInterval">
            <summary>Expert: Return the interval between indexed terms.
            
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.SetTermIndexInterval(System.Int32)">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.String,Lucene.Net.Analysis.Analyzer,System.Boolean,Lucene.Net.Index.IndexWriter.MaxFieldLength)">
            <summary>
            Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>path</code>, replacing the index already there, if any.
            <para>
            NOTE: autoCommit (see above) is set to false with this constructor.
            </para>
            <para>Throws CorruptIndexException if the index is corrupt</para>
            <para>Throws LockObtainFailedException if another writer has this index open (<code>write.lock</code> could not be obtained)</para>
            <para>Throws System.IO.IOException if the directory cannot be read/written to, or if it does not exist and <code>create</code> is <code>false</code> or if there is any other low-level IO error</para>
            </summary>
            <param name="path">the path to the index directory</param>
            <param name="a">the analyzer to use</param>
            <param name="create"><code>true</code> to create the index or overwrite the existing one; <code>false</code> to append to the existing index</param>
            <param name="mfl">Maximum field Length: LIMITED, UNLIMITED, or user-specified</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.String,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary>
            Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>path</code>, replacing the index already there, if any.
            <para>Throws CorruptIndexException if the index is corrupt</para>
            <para>Throws LockObtainFailedException if another writer has this index open (<code>write.lock</code> could not be obtained)</para>
            <para>Throws System.IO.IOException if the directory cannot be read/written to, or if it does not exist and <code>create</code> is <code>false</code> or if there is any other low-level IO error</para>
            </summary>
            <param name="path">the path to the index directory</param>
            <param name="a">the analyzer to use</param>
            <param name="create"><code>true</code> to create the index or overwrite the existing one; <code>false</code> to append to the existing index</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.IO.FileInfo,Lucene.Net.Analysis.Analyzer,System.Boolean,Lucene.Net.Index.IndexWriter.MaxFieldLength)">
            <summary>
            Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>path</code>, replacing the index already there, if any.
            <para>
            NOTE: autoCommit (see above) is set to false with this constructor.
            </para>
            <para>Throws CorruptIndexException if the index is corrupt</para>
            <para>Throws LockObtainFailedException if another writer has this index open (<code>write.lock</code> could not be obtained)</para>
            <para>Throws System.IO.IOException if the directory cannot be read/written to, or if it does not exist and <code>create</code> is <code>false</code> or if there is any other low-level IO error</para>
            </summary>
            <param name="path">the path to the index directory</param>
            <param name="a">the analyzer to use</param>
            <param name="create"><code>true</code> to create the index or overwrite the existing one; <code>false</code> to append to the existing index</param>
            <param name="mfl">Maximum field Length: LIMITED, UNLIMITED, or user-specified</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.IO.FileInfo,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary>
            Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>path</code>, replacing the index already there, if any.
            <para>Throws CorruptIndexException if the index is corrupt</para>
            <para>Throws LockObtainFailedException if another writer has this index open (<code>write.lock</code> could not be obtained)</para>
            <para>Throws System.IO.IOException if the directory cannot be read/written to, or if it does not exist and <code>create</code> is <code>false</code> or if there is any other low-level IO error</para>
            </summary>
            <param name="path">the path to the index directory</param>
            <param name="a">the analyzer to use</param>
            <param name="create"><code>true</code> to create the index or overwrite the existing one; <code>false</code> to append to the existing index</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,System.Boolean,Lucene.Net.Index.IndexWriter.MaxFieldLength)">
            <summary>
            Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>d</code>, replacing the index already there, if any.
            <para>
            NOTE: autoCommit (see above) is set to false with this constructor.
            </para>
            <para>Throws CorruptIndexException if the index is corrupt</para>
            <para>Throws LockObtainFailedException if another writer has this index open (<code>write.lock</code> could not be obtained)</para>
            <para>Throws System.IO.IOException if the directory cannot be read/written to, or if it does not exist and <code>create</code> is <code>false</code> or if there is any other low-level IO error</para>
            </summary>
            <param name="d">the index directory</param>
            <param name="a">the analyzer to use</param>
            <param name="create"><code>true</code> to create the index or overwrite the existing one; <code>false</code> to append to the existing index</param>
            <param name="mfl">Maximum field Length: LIMITED, UNLIMITED, or user-specified</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary>
            Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>d</code>, replacing the index already there, if any.
            <para>Throws CorruptIndexException if the index is corrupt</para>
            <para>Throws LockObtainFailedException if another writer has this index open (<code>write.lock</code> could not be obtained)</para>
            <para>Throws System.IO.IOException if the directory cannot be read/written to, or if it does not exist and <code>create</code> is <code>false</code> or if there is any other low-level IO error</para>
            </summary>
            <param name="d">the index directory</param>
            <param name="a">the analyzer to use</param>
            <param name="create"><code>true</code> to create the index or overwrite the existing one; <code>false</code> to append to the existing index</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.String,Lucene.Net.Analysis.Analyzer,Lucene.Net.Index.IndexWriter.MaxFieldLength)">
            <summary>
            Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.
            <para>
            NOTE: autoCommit (see above) is set to false with this constructor.
            </para>
            <para>Throws CorruptIndexException if the index is corrupt</para>
            <para>Throws LockObtainFailedException if another writer has this index open (<code>write.lock</code> could not be obtained)</para>
            <para>Throws System.IO.IOException if the directory cannot be read/written to or if there is any other low-level IO error</para>
            </summary>
            <param name="path">the path to the index directory</param>
            <param name="a">the analyzer to use</param>
            <param name="mfl">Maximum field Length: LIMITED, UNLIMITED, or user-specified</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.String,Lucene.Net.Analysis.Analyzer)">
            <summary>
            Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.
            <para>Throws CorruptIndexException if the index is corrupt</para>
            <para>Throws LockObtainFailedException if another writer has this index open (<code>write.lock</code> could not be obtained)</para>
            <para>Throws System.IO.IOException if the directory cannot be read/written to or if there is any other low-level IO error</para>
            </summary>
            <param name="path">the path to the index directory</param>
            <param name="a">the analyzer to use</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.IO.FileInfo,Lucene.Net.Analysis.Analyzer,Lucene.Net.Index.IndexWriter.MaxFieldLength)">
            <summary>
            Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.
            <para>
            NOTE: autoCommit (see above) is set to false with this constructor.
            </para>
            <para>Throws CorruptIndexException if the index is corrupt</para>
            <para>Throws LockObtainFailedException if another writer has this index open (<code>write.lock</code> could not be obtained)</para>
            <para>Throws System.IO.IOException if the directory cannot be read/written to or if there is any other low-level IO error</para>
            </summary>
            <param name="path">the path to the index directory</param>
            <param name="a">the analyzer to use</param>
            <param name="mfl">Maximum field Length: LIMITED, UNLIMITED, or user-specified</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(System.IO.FileInfo,Lucene.Net.Analysis.Analyzer)">
            <summary>
            Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.
            <para>Throws CorruptIndexException if the index is corrupt</para>
            <para>Throws LockObtainFailedException if another writer has this index open (<code>write.lock</code> could not be obtained)</para>
            <para>Throws System.IO.IOException if the directory cannot be read/written to or if there is any other low-level IO error</para>
            </summary>
            <param name="path">the path to the index directory</param>
            <param name="a">the analyzer to use</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,Lucene.Net.Index.IndexWriter.MaxFieldLength)">
            <summary>
            Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.
            <para>
            NOTE: autoCommit (see above) is set to false with this constructor.
            </para>
            <para>Throws CorruptIndexException if the index is corrupt</para>
            <para>Throws LockObtainFailedException if another writer has this index open (<code>write.lock</code> could not be obtained)</para>
            <para>Throws System.IO.IOException if the directory cannot be read/written to or if there is any other low-level IO error</para>
            </summary>
            <param name="d">the index directory</param>
            <param name="a">the analyzer to use</param>
            <param name="mfl">Maximum field Length: LIMITED, UNLIMITED, or user-specified</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer)">
            <summary>
            Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.
            <para>Throws CorruptIndexException if the index is corrupt</para>
            <para>Throws LockObtainFailedException if another writer has this index open (<code>write.lock</code> could not be obtained)</para>
            <para>Throws System.IO.IOException if the directory cannot be read/written to or if there is any other low-level IO error</para>
            </summary>
            <param name="d">the index directory</param>
            <param name="a">the analyzer to use</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,System.Boolean,Lucene.Net.Analysis.Analyzer)">
            <summary>
            Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.
            <para>Throws CorruptIndexException if the index is corrupt</para>
            <para>Throws LockObtainFailedException if another writer has this index open (<code>write.lock</code> could not be obtained)</para>
            <para>Throws System.IO.IOException if the directory cannot be read/written to or if there is any other low-level IO error</para>
            </summary>
            <param name="d">the index directory</param>
            <param name="autoCommit">see autoCommit above</param>
            <param name="a">the analyzer to use</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,System.Boolean,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary>
            Constructs an IndexWriter for the index in <code>path</code>.
            Text will be analyzed with <code>a</code>.  If <code>create</code>
            is true, then a new, empty index will be created in
            <code>d</code>, replacing the index already there, if any.
            <para>Throws CorruptIndexException if the index is corrupt</para>
            <para>Throws LockObtainFailedException if another writer has this index open (<code>write.lock</code> could not be obtained)</para>
            <para>Throws System.IO.IOException if the directory cannot be read/written to, or if it does not exist and <code>create</code> is <code>false</code> or if there is any other low-level IO error</para>
            </summary>
            <param name="path">the path to the index directory</param>
            <param name="autoCommit">see autoCommit above</param>
            <param name="a">the analyzer to use</param>
            <param name="create"><code>true</code> to create the index or overwrite the existing one; <code>false</code> to append to the existing index</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,Lucene.Net.Index.IndexDeletionPolicy,Lucene.Net.Index.IndexWriter.MaxFieldLength)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,System.Boolean,Lucene.Net.Analysis.Analyzer,Lucene.Net.Index.IndexDeletionPolicy)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,System.Boolean,Lucene.Net.Index.IndexDeletionPolicy,Lucene.Net.Index.IndexWriter.MaxFieldLength)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,System.Boolean,Lucene.Net.Analysis.Analyzer,System.Boolean,Lucene.Net.Index.IndexDeletionPolicy)" -->
        <member name="M:Lucene.Net.Index.IndexWriter.SetMergePolicy(Lucene.Net.Index.MergePolicy)">
            <summary> Expert: set the merge policy used by this writer.</summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetMergePolicy">
            <summary> Expert: returns the current MergePolicy in use by this writer.</summary>
            <seealso cref="!:setMergePolicy">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetMergeScheduler(Lucene.Net.Index.MergeScheduler)">
            <summary> Expert: set the merge scheduler used by this writer.</summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetMergeScheduler">
            <summary> Expert: returns the current MergePolicy in use by this
            writer.
            </summary>
            <seealso cref="!:setMergePolicy">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetMaxMergeDocs(System.Int32)">
            <summary><p>Determines the largest segment (measured by
            document count) that may be merged with other segments.
            Small values (e.g., less than 10,000) are best for
            interactive indexing, as this limits the length of
            pauses while indexing to a few seconds.  Larger values
            are best for batched indexing and speedier
            searches.</p>
            
            <p>The default value is {@link Integer#MAX_VALUE}.</p>
            
            <p>Note that this method is a convenience method: it
            just calls mergePolicy.SetMaxMergeDocs as long as
            mergePolicy is an instance of {@link LogMergePolicy}.
            Otherwise an System.ArgumentException is thrown.</p>
            
            <p>The default merge policy ({@link
            LogByteSizeMergePolicy}) also allows you to set this
            limit by net size (in MB) of the segment, using {@link
            LogByteSizeMergePolicy#setMaxMergeMB}.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetMaxMergeDocs">
            <summary> <p>Returns the largest segment (measured by document
            count) that may be merged with other segments.</p>
            
            <p>Note that this method is a convenience method: it
            just calls mergePolicy.GetMaxMergeDocs as long as
            mergePolicy is an instance of {@link LogMergePolicy}.
            Otherwise an System.ArgumentException is thrown.</p>
            
            </summary>
            <seealso cref="!:setMaxMergeDocs">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetMaxFieldLength(System.Int32)">
            <summary> The maximum number of terms that will be indexed for a single field in a
            document.  This limits the amount of memory required for indexing, so that
            collections with very large files will not crash the indexing process by
            running out of memory.  This setting refers to the number of running terms,
            not to the number of different terms.<p/>
            <strong>Note:</strong> this silently truncates large documents, excluding from the
            index all terms that occur further in the document.  If you know your source
            documents are large, be sure to set this value high enough to accomodate
            the expected size.  If you set it to Integer.MAX_VALUE, then the only limit
            is your memory, but you should anticipate an System.OutOfMemoryException.<p/>
            By default, no more than DEFAULT_MAX_FIELD_LENGTH terms will be indexed for a field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetMaxFieldLength">
            <summary> Returns the maximum number of terms that will be
            indexed for a single field in a document.
            </summary>
            <seealso cref="!:setMaxFieldLength">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetMaxBufferedDocs(System.Int32)">
            <summary>Determines the minimal number of documents required
            before the buffered in-memory documents are flushed as
            a new Segment.  Large values generally gives faster
            indexing.
            
            <p>When this is set, the writer will flush every
            maxBufferedDocs added documents.  Pass in {@link
            #DISABLE_AUTO_FLUSH} to prevent triggering a flush due
            to number of buffered documents.  Note that if flushing
            by RAM usage is also enabled, then the flush will be
            triggered by whichever comes first.</p>
            
            <p>Disabled by default (writer flushes by RAM usage).</p>
            
            </summary>
            <throws>  System.ArgumentException if maxBufferedDocs is </throws>
            <summary> enabled but smaller than 2, or it disables maxBufferedDocs
            when ramBufferSize is already disabled
            </summary>
            <seealso cref="!:setRAMBufferSizeMB">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.PushMaxBufferedDocs">
            <summary> If we are flushing by doc count (not by RAM usage), and
            using LogDocMergePolicy then push maxBufferedDocs down
            as its minMergeDocs, to keep backwards compatibility.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetMaxBufferedDocs">
            <summary> Returns the number of buffered added documents that will
            trigger a flush if enabled.
            </summary>
            <seealso cref="!:setMaxBufferedDocs">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetRAMBufferSizeMB(System.Double)">
            <summary>Determines the amount of RAM that may be used for
            buffering added documents before they are flushed as a
            new Segment.  Generally for faster indexing performance
            it's best to flush by RAM usage instead of document
            count and use as large a RAM buffer as you can.
            
            <p>When this is set, the writer will flush whenever
            buffered documents use this much RAM.  Pass in {@link
            #DISABLE_AUTO_FLUSH} to prevent triggering a flush due
            to RAM usage.  Note that if flushing by document count
            is also enabled, then the flush will be triggered by
            whichever comes first.</p>
            
            <p> The default value is {@link #DEFAULT_RAM_BUFFER_SIZE_MB}.</p>
            
            </summary>
            <throws>  System.ArgumentException if ramBufferSize is </throws>
            <summary> enabled but non-positive, or it disables ramBufferSize
            when maxBufferedDocs is already disabled
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetRAMBufferSizeMB">
            <summary> Returns the value set by {@link #setRAMBufferSizeMB} if enabled.</summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetMaxBufferedDeleteTerms(System.Int32)">
            <summary> <p>Determines the minimal number of delete terms required before the buffered
            in-memory delete terms are applied and flushed. If there are documents
            buffered in memory at the time, they are merged and a new segment is
            created.</p>
            <p>Disabled by default (writer flushes by RAM usage).</p>
            
            </summary>
            <throws>  System.ArgumentException if maxBufferedDeleteTerms </throws>
            <summary> is enabled but smaller than 1
            </summary>
            <seealso cref="!:setRAMBufferSizeMB">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetMaxBufferedDeleteTerms">
            <summary> Returns the number of buffered deleted terms that will
            trigger a flush if enabled.
            </summary>
            <seealso cref="!:setMaxBufferedDeleteTerms">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.SetMergeFactor(System.Int32)" -->
        <member name="M:Lucene.Net.Index.IndexWriter.GetMergeFactor">
            <summary> <p>Returns the number of segments that are merged at
            once and also controls the total number of segments
            allowed to accumulate in the index.</p>
            
            <p>Note that this method is a convenience method: it
            just calls mergePolicy.GetMergeFactor as long as
            mergePolicy is an instance of {@link LogMergePolicy}.
            Otherwise an System.ArgumentException is thrown.</p>
            
            </summary>
            <seealso cref="!:setMergeFactor">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetMaxSyncPauseSeconds">
            <summary>
            Expert: returns max delay inserted before syncing a
            commit point.  On Windows, at least, pausing before
            syncing can increase net indexing throughput.  The
            delay is variable based on size of the segment's files,
            and is only inserted when using ConcurrentMergeScheduler for merges.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetMaxSyncPauseSeconds(System.Double)">
            <summary>Expert: sets the max delay before syncing a commit point.</summary>
            <param name="seconds"></param>
            <para>See GetMaxSyncPauseSeconds()</para>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetDefaultInfoStream(System.IO.TextWriter)">
            <summary>If non-null, this will be the default infoStream used
            by a newly instantiated IndexWriter.
            </summary>
            <seealso cref="!:setInfoStream">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetDefaultInfoStream">
            <summary> Returns the current default infoStream for newly
            instantiated IndexWriters.
            </summary>
            <seealso cref="!:setDefaultInfoStream">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetInfoStream(System.IO.TextWriter)">
            <summary>If non-null, information about merges, deletes and a
            message when maxFieldLength is reached will be printed
            to this.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetInfoStream">
            <summary> Returns the current infoStream in use by this writer.</summary>
            <seealso cref="!:setInfoStream">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetWriteLockTimeout(System.Int64)">
            <seealso cref="!:">
            </seealso>
            <seealso cref="!:setDefaultWriteLockTimeout to change the default value for all instances of IndexWriter.">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetWriteLockTimeout">
            <summary> Returns allowed timeout when acquiring the write lock.</summary>
            <seealso cref="!:setWriteLockTimeout">
            </seealso>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetDefaultWriteLockTimeout(System.Int64)">
            <summary> Sets the default (for any instance of IndexWriter) maximum time to wait for a write lock (in
            milliseconds).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetDefaultWriteLockTimeout">
            <summary> Returns default write lock timeout for newly
            instantiated IndexWriters.
            </summary>
            <seealso cref="!:setDefaultWriteLockTimeout">
            </seealso>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.Close" -->
        <member name="M:Lucene.Net.Index.IndexWriter.Close(System.Boolean)">
            <summary> Closes the index with or without waiting for currently
            running merges to finish.  This is only meaningful when
            using a MergeScheduler that runs merges in background
            threads.
            </summary>
            <param name="waitForMerges">if true, this call will block
            until all merges complete; else, it will ask all
            running merges to abort, wait until those merges have
            finished (which should be at most a few seconds), and
            then return.
            </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.FlushDocStores" -->
        <member name="M:Lucene.Net.Index.IndexWriter.Finalize">
            <summary>Release the write lock, if needed. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetDirectory">
            <summary>Returns the Directory used by this index. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetAnalyzer">
            <summary>Returns the analyzer used by this index. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DocCount">
            <summary>Returns the number of documents currently in this index, not counting deletions. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MaxDoc">
            <summary>
            Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer),
            without regard for deletions (see NumDocs()).
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.NumDocs">
            <summary>
            Returns total number of docs in this index, including docs not yet flushed (still in the RAM buffer),
            with regard for deletions.  NOTE: Buffered deletions are not excluded.  If these need to be excluded,
            call Commit() first.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.maxFieldLength">
            <summary> The maximum number of terms that will be indexed for a single field in a
            document.  This limits the amount of memory required for indexing, so that
            collections with very large files will not crash the indexing process by
            running out of memory.<p/>
            Note that this effectively truncates large documents, excluding from the
            index terms that occur further in the document.  If you know your source
            documents are large, be sure to set this value high enough to accomodate
            the expected size.  If you set it to Integer.MAX_VALUE, then the only limit
            is your memory, but you should anticipate an System.OutOfMemoryException.<p/>
            By default, no more than 10,000 terms will be indexed for a field.
            </summary>
            <see cref="T:Lucene.Net.Index.IndexWriter.MaxFieldLength"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.AddDocument(Lucene.Net.Documents.Document)" -->
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocument(Lucene.Net.Documents.Document,Lucene.Net.Analysis.Analyzer)">
            <summary> Adds a document to this index, using the provided analyzer instead of the
            value of {@link #GetAnalyzer()}.  If the document contains more than
            {@link #SetMaxFieldLength(int)} terms for a given field, the remainder are
            discarded.
            
            <p>See {@link #AddDocument(Document)} for details on
            index and IndexWriter state after an Exception, and
            flushing/merging temporary free space requirements.</p>
            
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  System.IO.IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term)">
            <summary> Deletes the document(s) containing <code>term</code>.</summary>
            <param name="term">the term to identify the documents to be deleted
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  System.IO.IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term[])">
            <summary> Deletes the document(s) containing any of the
            terms. All deletes are flushed at the same time.
            </summary>
            <param name="terms">array of terms to identify the documents
            to be deleted
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  System.IO.IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query)">
            <summary>
            Deletes the document(s) matching the provided query.
            @param query the query to identify the documents to be deleted
            @throws CorruptIndexException if the index is corrupt
            @throws System.IO.IOException if there is a low-level IO error
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query[])">
            <summary>
            Deletes the document(s) matching any of the provided queries.
            All deletes are flushed at the same time.
            @param queries array of queries to identify the documents
            to be deleted
            @throws CorruptIndexException if the index is corrupt
            @throws System.IO.IOException if there is a low-level IO error
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocument(Lucene.Net.Index.Term,Lucene.Net.Documents.Document)">
            <summary> Updates a document by first deleting the document(s)
            containing <code>term</code> and then adding the new
            document.  The delete and then add are atomic as seen
            by a reader on the same index (flush may happen only after
            the add).
            </summary>
            <param name="term">the term to identify the document(s) to be
            deleted
            </param>
            <param name="doc">the document to be added
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  System.IO.IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocument(Lucene.Net.Index.Term,Lucene.Net.Documents.Document,Lucene.Net.Analysis.Analyzer)">
            <summary> Updates a document by first deleting the document(s)
            containing <code>term</code> and then adding the new
            document.  The delete and then add are atomic as seen
            by a reader on the same index (flush may happen only after
            the add).
            </summary>
            <param name="term">the term to identify the document(s) to be
            deleted
            </param>
            <param name="doc">the document to be added
            </param>
            <param name="analyzer">the analyzer to use when analyzing the document
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  System.IO.IOException if there is a low-level IO error </throws>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.infoStream">
            <summary>If non-null, information about merges will be printed to this.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.Optimize" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.Optimize(System.Int32)" -->
        <member name="M:Lucene.Net.Index.IndexWriter.Optimize(System.Boolean)">
            <summary>Just like {@link #Optimize()}, except you can specify
            whether the call should block until the optimize
            completes.  This is only meaningful with a
            {@link MergeScheduler} that is able to run merges in
            background threads. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Optimize(System.Int32,System.Boolean)">
            <summary>Just like {@link #Optimize(int)}, except you can
            specify whether the call should block until the
            optimize completes.  This is only meaningful with a
            {@link MergeScheduler} that is able to run merges in
            background threads. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.OptimizeMergesPending">
            <summary>Returns true if any merges in pendingMerges or
            runningMerges are optimization merges. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ExpungeDeletes(System.Boolean)">
            <summary>
            Just like {@link #expungeDeletes()}, except you can
            specify whether the call should block until the
            operation completes.  This is only meaningful with a
            {@link MergeScheduler} that is able to run merges in
            background threads.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ExpungeDeletes">
            <summary>
            Expunges all deletes from the index.  When an index
            has many document deletions (or updates to existing
            documents), it's best to either call optimize or
            expungeDeletes to remove all unused data in the index
            associated with the deleted documents.  To see how
            many deletions you have pending in your index, call
            {@link IndexReader#numDeletedDocs}
            This saves disk space and memory usage while
            searching.  expungeDeletes should be somewhat faster
            than optimize since it does not insist on reducing the
            index to a single segment (though, this depends on the
            {@link MergePolicy}; see {@link
            MergePolicy#findMergesToExpungeDeletes}.). Note that
            this call does not first commit any buffered
            documents, so you must do so yourself if necessary.
            See also {@link #expungeDeletes(bool)}
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MaybeMerge">
            <summary> Expert: asks the mergePolicy whether any merges are
            necessary now and if so, runs the requested merges and
            then iterate (test again if merges are needed) until no
            more merges are returned by the mergePolicy.
            
            Explicit calls to MaybeMerge() are usually not
            necessary. The most common case is when merge policy
            parameters have changed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetNextMerge">
            <summary>Expert: the {@link MergeScheduler} calls this method
            to retrieve the next merge requested by the
            MergePolicy 
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetNextExternalMerge">
            <summary>
            Like getNextMerge() except only returns a merge if it's external.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.StartTransaction(System.Boolean)">
             <summary>
             Begin a transaction.  During a transaction, any segment
             merges that happen (or ram segments flushed) will not
             write a new segments file and will not remove any files
             that were present at the start of the transaction.  You
             must make a matched (try/finally) call to
             CommitTransaction() or RollbackTransaction() to finish
             the transaction.
            
             Note that buffered documents and delete terms are not handled
             within the transactions, so they must be flushed before the
             transaction is started.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Rollback">
            <summary> Close the <code>IndexWriter</code> without committing
            any of the changes that have occurred since it was
            opened. This removes any temporary files that had been
            created, after which the state of the index will be the
            same as it was when this writer was first opened.  This
            can only be called when this IndexWriter was opened
            with <code>autoCommit=false</code>.  This also clears a previous
            call to PrepareCommit().
            </summary>
            <throws>  System.Exception if this is called when </throws>
            <summary>  the writer was opened with <code>autoCommit=true</code>.
            </summary>
            <throws>  System.IO.IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Store.Directory[])">
            Merges all segments from an array of indexes into this index.
            @deprecated Use {@link #addIndexesNoOptimize} instead,
            then separately call {@link #optimize} afterwards if
            you need to.
            @throws CorruptIndexException if the index is corrupt
            @throws System.IO.IOException if there is a low-level IO error
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.AddIndexesNoOptimize(Lucene.Net.Store.Directory[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.Flush" -->
        <member name="M:Lucene.Net.Index.IndexWriter.PrepareCommit">
            <p>Expert: prepare for commit.  This does the first
              phase of 2-phase commit.  You can only call this when
              autoCommit is false.  This method does all steps
              necessary to commit changes since this writer was
              opened: flushes pending added and deleted docs, syncs
              the index files, writes most of next segments_N file.
              After calling this you must call either {@link
              #Commit()} to finish the commit, or {@link
              #rollback()} to revert the commit and undo all changes
              done since the writer was opened.</p>
            
             You can also just call {@link #Commit()} directly
             without prepareCommit first in which case that method
             will internally call prepareCommit.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.Commit" -->
        <member name="M:Lucene.Net.Index.IndexWriter.Flush(System.Boolean,System.Boolean,System.Boolean)">
            Flush all in-memory buffered udpates (adds and deletes)
            to the Directory.
            @param triggerMerge if true, we may merge segments (if
             deletes or docs were flushed) if necessary
            @param flushDocStores if false we are allowed to keep
             doc stores open to share with the next segment
            @param flushDeletes whether pending deletes should also
             be flushed
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.RamSizeInBytes">
            Expert:  Return the total size of all index files currently cached in memory.
            Useful for size management with flushRamDocs()
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.NumRamDocs">
            Expert:  Return the number of documents currently
            buffered in RAM. 
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.CommitMergedDeletes(Lucene.Net.Index.MergePolicy.OneMerge)">
            Carefully merges deletes for the segments we just
            merged.  This is tricky because, although merging will
            clear all deletes (compacts the documents), new
            deletes may have been flushed to the segments since
            the merge was started.  This method "carries over"
            such new deletes onto the newly merged segment, and
            saves the resulting deletes file (incrementing the
            delete generation for merge.info).  If no deletes were
            flushed, no new deletes file is saved. 
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Merge(Lucene.Net.Index.MergePolicy.OneMerge)">
            Merges the indicated segments, replacing them in the stack with a
            single segment.
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.RegisterMerge(Lucene.Net.Index.MergePolicy.OneMerge)">
            Checks whether this merge involves any segments
            already participating in a merge.  If not, this merge
            is "registered", meaning we record that its segments
            are now participating in a merge, and true is
            returned.  Else (the merge conflicts) false is
            returned. 
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeInit(Lucene.Net.Index.MergePolicy.OneMerge)">
            Does initial setup for a merge, which is fast but holds
            the synchronized lock on IndexWriter instance.  
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.DoCommitBeforeMergeCFS(Lucene.Net.Index.MergePolicy.OneMerge)" -->
        <member name="M:Lucene.Net.Index.IndexWriter.MergeFinish(Lucene.Net.Index.MergePolicy.OneMerge)">
            Does fininishing for a merge, which is fast but holds
            the synchronized lock on IndexWriter instance. 
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeMiddle(Lucene.Net.Index.MergePolicy.OneMerge)">
            Does the actual (time-consuming) work of the merge,
            but without holding synchronized lock on IndexWriter
            instance 
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.WaitForAllSynced(System.Collections.Generic.ICollection{System.String})">
            Blocks until all files in syncing are sync'd 
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SyncPause(System.Int64)">
            Pauses before syncing.  On Windows, at least, it's
            best (performance-wise) to pause in order to let OS
            flush writes to disk on its own, before forcing a
            sync.
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.StartCommit(System.Int64)">
            Walk through all files referenced by the current
            segmentInfos and ask the Directory to sync each file,
            if it wasn't already.  If that succeeds, then we
            prepare a new segments_N file but do not fully commit
            it. 
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.IsLocked(Lucene.Net.Store.Directory)">
            Returns <code>true</code> iff the index in the named directory is
            currently locked.
            @param directory the directory to check for a lock
            @throws System.IO.IOException if there is a low-level IO error
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.IsLocked(System.String)">
            Returns <code>true</code> iff the index in the named directory is
            currently locked.
            @param directory the directory to check for a lock
            @throws System.IO.IOException if there is a low-level IO error
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexWriter.Unlock(Lucene.Net.Store.Directory)" -->
        <member name="T:Lucene.Net.Index.IndexWriter.MaxFieldLength">
            Specifies maximum field length in {@link IndexWriter} constructors.
            {@link #setMaxFieldLength(int)} overrides the value set by
            the constructor.
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MaxFieldLength.#ctor(System.String,System.Int32)">
            Private type-safe-enum-pattern constructor.
            
            @param name instance name
            @param limit maximum field length
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MaxFieldLength.#ctor(System.Int32)">
            Public constructor to allow users to specify the maximum field size limit.
            
            @param limit The maximum field length
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.MaxFieldLength.UNLIMITED">
            Sets the maximum field length to {@link Integer#MAX_VALUE}. 
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.MaxFieldLength.LIMITED">
             Sets the maximum field length to 
            {@link #DEFAULT_MAX_FIELD_LENGTH} 
            
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.IndexModifier" -->
        <member name="M:Lucene.Net.Index.IndexModifier.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Open an index with write access.
            
            </summary>
            <param name="directory">the index directory
            </param>
            <param name="analyzer">the analyzer to use for adding new documents
            </param>
            <param name="create"><code>true</code> to create the index or overwrite the existing one;
            <code>false</code> to append to the existing index
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.#ctor(System.String,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Open an index with write access.
            
            </summary>
            <param name="dirName">the index directory
            </param>
            <param name="analyzer">the analyzer to use for adding new documents
            </param>
            <param name="create"><code>true</code> to create the index or overwrite the existing one;
            <code>false</code> to append to the existing index
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.#ctor(System.IO.FileInfo,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Open an index with write access.
            
            </summary>
            <param name="file">the index directory
            </param>
            <param name="analyzer">the analyzer to use for adding new documents
            </param>
            <param name="create"><code>true</code> to create the index or overwrite the existing one;
            <code>false</code> to append to the existing index
            </param>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.Init(Lucene.Net.Store.Directory,Lucene.Net.Analysis.Analyzer,System.Boolean)">
            <summary> Initialize an IndexWriter.</summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.AssureOpen">
            <summary> Throw an IllegalStateException if the index is closed.</summary>
            <throws>  IllegalStateException </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.CreateIndexWriter">
            <summary> Close the IndexReader and open an IndexWriter.</summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.CreateIndexReader">
            <summary> Close the IndexWriter and open an IndexReader.</summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.Flush">
            <summary> Make sure all changes are written to disk.</summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.AddDocument(Lucene.Net.Documents.Document,Lucene.Net.Analysis.Analyzer)">
            <summary> Adds a document to this index, using the provided analyzer instead of the
            one specific in the constructor.  If the document contains more than
            {@link #SetMaxFieldLength(int)} terms for a given field, the remainder are
            discarded.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.AddDocument(Lucene.Net.Documents.Document,Lucene.Net.Analysis.Analyzer)">
            </seealso>
            <throws>  IllegalStateException if the index is closed </throws>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.AddDocument(Lucene.Net.Documents.Document)">
            <summary> Adds a document to this index.  If the document contains more than
            {@link #SetMaxFieldLength(int)} terms for a given field, the remainder are
            discarded.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.AddDocument(Lucene.Net.Documents.Document)">
            </seealso>
            <throws>  IllegalStateException if the index is closed </throws>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.DeleteDocuments(Lucene.Net.Index.Term)">
            <summary> Deletes all documents containing <code>term</code>.
            This is useful if one uses a document field to hold a unique ID string for
            the document.  Then to delete such a document, one merely constructs a
            term with the appropriate field and the unique ID string as its text and
            passes it to this method.  Returns the number of documents deleted.
            </summary>
            <returns> the number of documents deleted
            </returns>
            <seealso cref="M:Lucene.Net.Index.IndexReader.DeleteDocuments(Lucene.Net.Index.Term)">
            </seealso>
            <throws>  IllegalStateException if the index is closed </throws>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary>  since this reader was opened
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.DeleteDocument(System.Int32)">
            <summary> Deletes the document numbered <code>docNum</code>.</summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.DeleteDocument(System.Int32)">
            </seealso>
            <throws>  StaleReaderException if the index has changed </throws>
            <summary>  since this reader was opened
            </summary>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IllegalStateException if the index is closed </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.DocCount">
            <summary>
            Returns the number of documents currently in this index.  If the writer is currently open,
            this returns IndexWriter.DocCount(), else IndexReader.NumDocs().  But, note that
            IndexWriter.DocCount() does not take deltions into account, unlike IndexReader.NumDocs().
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.DocCount">
            </seealso>
            <seealso cref="M:Lucene.Net.Index.IndexReader.NumDocs">
            </seealso>
            <throws>  IllegalStateException if the index is closed </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.Optimize">
            <summary> Merges all segments together into a single segment, optimizing an index
            for search.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.Optimize">
            </seealso>
            <throws>  IllegalStateException if the index is closed </throws>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexModifier.SetInfoStream(System.IO.StreamWriter)" -->
        <member name="M:Lucene.Net.Index.IndexModifier.GetInfoStream">
            <seealso cref="!:IndexModifier.SetInfoStream(PrintStream)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.SetUseCompoundFile(System.Boolean)">
            <summary> Setting to turn on usage of a compound file. When on, multiple files
            for each segment are merged into a single file once the segment creation
            is finished. This is done regardless of what directory is in use.
            </summary>
            <seealso cref="!:IndexWriter.SetUseCompoundFile(boolean)">
            </seealso>
            <throws>  IllegalStateException if the index is closed </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.GetUseCompoundFile">
            <seealso cref="!:IndexModifier.SetUseCompoundFile(boolean)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.SetMaxFieldLength(System.Int32)">
            <summary> The maximum number of terms that will be indexed for a single field in a
            document.  This limits the amount of memory required for indexing, so that
            collections with very large files will not crash the indexing process by
            running out of memory.<p/>
            Note that this effectively truncates large documents, excluding from the
            index terms that occur further in the document.  If you know your source
            documents are large, be sure to set this value high enough to accomodate
            the expected size.  If you set it to Integer.MAX_VALUE, then the only limit
            is your memory, but you should anticipate an OutOfMemoryError.<p/>
            By default, no more than 10,000 terms will be indexed for a field.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.SetMaxFieldLength(System.Int32)">
            </seealso>
            <throws>  IllegalStateException if the index is closed </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.GetMaxFieldLength">
            <seealso cref="M:Lucene.Net.Index.IndexModifier.SetMaxFieldLength(System.Int32)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexModifier.SetMaxBufferedDocs(System.Int32)" -->
        <member name="M:Lucene.Net.Index.IndexModifier.GetMaxBufferedDocs">
            <seealso cref="M:Lucene.Net.Index.IndexModifier.SetMaxBufferedDocs(System.Int32)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.IndexModifier.SetMergeFactor(System.Int32)" -->
        <member name="M:Lucene.Net.Index.IndexModifier.GetMergeFactor">
            <seealso cref="M:Lucene.Net.Index.IndexModifier.SetMergeFactor(System.Int32)">
            </seealso>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  LockObtainFailedException if another writer </throws>
            <summary>  has this index open (<code>write.lock</code> could not
            be obtained)
            </summary>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="M:Lucene.Net.Index.IndexModifier.Close">
            <summary> Close this index, writing all pending changes to disk.
            
            </summary>
            <throws>  IllegalStateException if the index has been closed before already </throws>
            <throws>  CorruptIndexException if the index is corrupt </throws>
            <throws>  IOException if there is a low-level IO error </throws>
        </member>
        <member name="T:Lucene.Net.Index.DocFieldProcessor">
            <summary>
            This is a DocConsumer that gathers all fields under the
            same name, and calls per-field consumers to process field
            by field.  This class doesn't doesn't do any "real" work
            of its own: it just forwards the fields to a
            DocFieldConsumer.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.SinkTokenizer">
            <summary> A SinkTokenizer can be used to cache Tokens for use in an Analyzer
            
            </summary>
            <seealso cref="T:Lucene.Net.Analysis.TeeTokenFilter">
            
            
            </seealso>
        </member>
        <member name="M:Lucene.Net.Analysis.SinkTokenizer.GetTokens">
            <summary> Get the tokens in the internal List.
            <p/>
            WARNING: Adding tokens to this list requires the {@link #Reset()} method to be called in order for them
            to be made available.  Also, this Tokenizer does nothing to protect against {@link java.util.ConcurrentModificationException}s
            in the case of adds happening while {@link #Next(Lucene.Net.Analysis.Token)} is being called.
            <p/>
            WARNING: Since this SinkTokenizer can be reset and the cached tokens made available again, do not modify them.  Modify clones instead.
            </summary>
            <returns> A List of {@link Lucene.Net.Analysis.Token}s
            </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.SinkTokenizer.Next(Lucene.Net.Analysis.Token)">
            <summary> Returns the next token out of the list of cached tokens</summary>
            <returns> The next {@link Lucene.Net.Analysis.Token} in the Sink.
            </returns>
            <throws>  IOException </throws>
        </member>
        <member name="M:Lucene.Net.Analysis.SinkTokenizer.Add(Lucene.Net.Analysis.Token)">
            <summary> Override this method to cache only certain tokens, or new tokens based
            on the old tokens.
            
            </summary>
            <param name="t">The {@link Lucene.Net.Analysis.Token} to add to the sink
            </param>
        </member>
        <member name="M:Lucene.Net.Analysis.SinkTokenizer.Reset">
            <summary> Reset the internal data structures to the start at the front of the list of tokens.  Should be called
            if tokens were added to the list after an invocation of {@link #Next(Token)}
            </summary>
            <throws>  IOException </throws>
        </member>
    </members>
</doc>
